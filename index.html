<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Tabletop Card Sandbox (4P) — Canvas + Realtime</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33cc;
      --panelSolid:#121a33;
      --border:#2a3566;
      --text:#e9ecff;
      --muted:#9aa6d6;
      --accent:#7aa2ff;
      --danger:#ff6b8b;
      --ok:#49d17c;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      background:
        radial-gradient(1200px 800px at 20% 10%, #18224b 0%, transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #1c2f66 0%, transparent 55%),
        radial-gradient(700px 600px at 50% 85%, #12214b 0%, transparent 50%),
        var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* Layout */
    #app{
      position:relative;
      width:100%;
      height:100%;
    }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      top:12px; left:12px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      z-index:10;
      pointer-events:auto; /* let canvas interactions through */
    }
    .panel{
      pointer-events:auto;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      min-width: 280px;
    }
    .panel header{
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .panel header .title{
      font-weight:700;
      letter-spacing:.2px;
      font-size:13px;
      color:var(--text);
    }
    .panel header .badge{
      font-size:11px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:4px 8px;
      background: rgba(0,0,0,.12);
    }
    .panel .content{
      padding:12px;
    }

    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .col{display:flex; flex-direction:column; gap:8px;}
    label{font-size:12px; color:var(--muted);}
    input,button,select{
      font-family:inherit;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:10px 12px;
      outline:none;
    }
    input::placeholder{color:rgba(233,236,255,.45)}
    button{
      cursor:pointer;
      border:1px solid rgba(122,162,255,.35);
      background: linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.08));
    }
    button:hover{border-color: rgba(122,162,255,.6)}
    button.secondary{
      border-color: rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
    }
    button.danger{
      border-color: rgba(255,107,139,.45);
      background: rgba(255,107,139,.12);
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    /* Chat */
    #chatPanel{
      position:absolute;
      right:12px;
      top:12px;
      width:min(360px, 40vw);
      height:min(420px, 52vh);
      z-index:10;
      display:flex;
      flex-direction:column;
      pointer-events:auto;
    }
    #chatPanel.collapsed{
      height:auto !important;
    }
    #chatPanel .panel{height:100%; display:flex; flex-direction:column; pointer-events:auto;}
    #chatLog{
      flex:1;
      overflow:auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .msg{
      display:flex;
      gap:8px;
      align-items:flex-start;
    }
    .msg .dot{
      width:10px; height:10px; border-radius:999px;
      margin-top:4px;
      flex:0 0 auto;
      box-shadow: 0 0 0 3px rgba(0,0,0,.15);
      border:1px solid rgba(255,255,255,.18);
    }
    .msg .bubble{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding:8px 10px;
      max-width: 100%;
    }
    .msg .meta{
      font-size:11px;
      color:rgba(233,236,255,.6);
      margin-bottom:4px;
      display:flex;
      gap:8px;
      align-items:baseline;
      flex-wrap:wrap;
    }
    .msg .text{font-size:13px; line-height:1.35; white-space:pre-wrap; word-break:break-word;}
    #chatForm{
      display:flex;
      gap:8px;
      padding:10px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.10);
    }
    #chatInput{flex:1}

    /* Floating help */
    #help{
      position:absolute;
      left:12px;
      bottom:12px;
      z-index:10;
      width:min(520px, 56vw);
      pointer-events:auto;
    }
    #help .panel{pointer-events:auto}
    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      padding: 2px 6px;
      margin: 0 2px;
      border-radius: 7px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      font-size: 11px;
      color: rgba(233,236,255,.85);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,.22);
    }

    /* Toast */
    #toast{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      top:14px;
      z-index:20;
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(233,236,255,.92);
      box-shadow: var(--shadow);
      display:none;
      pointer-events:none;
      backdrop-filter: blur(8px);
      font-size: 12px;
    }

    /* Small */
    @media (max-width: 880px){
      #help{display:none;}
      #chatPanel{width:min(340px, 48vw);}
      .hud{flex-direction:column;}
    }

     #inspector{
      position:absolute;
      z-index:30;
      display:none;
      pointer-events:auto;
      width: 280px;
      max-width: min(320px, 40vw);
    }
    
    #inspector .panel{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }


    .panel.collapsed .content {
      display: none;
    }
    
    .panel.collapsed {
      min-height: unset;
    }
    
    .collapse-btn {
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      color: #e9ecff;
      line-height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .collapse-btn:hover {
      background: rgba(122,162,255,.25);
    }

    .modal{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal-card{
      width:min(860px, 92vw);
      max-height:min(86vh, 780px);
      overflow:auto;
    }
    .card-url-row{
      display:flex; gap:8px; align-items:center;
    }
    .card-url-row input{ flex:1; }


    /* Make HUD smaller + collapsible */
    .hud{ gap:10px; }
    .panel{ max-width: 360px; }
    
    /* Optional: minimize buttons row */
    .hud .panel header{ cursor:default; }
    
    .screen{ display:none; width:100%; height:100%; }
    .screen.active{ display:block; }
    #authScreen{ display:flex; align-items:flex-start; justify-content:center; }
    #lobbyScreen .hud{ position:relative; top:auto; left:auto; padding:12px; }
    #matchScreen{ position:relative; width:100%; height:100%; }

    
  </style>
</head>
<body>
<!-- =========================
  SCREEN: AUTH (mặc định hiện)
  Giữ nguyên #authPanel của bạn
========================= -->
<div id="authScreen" class="screen active">
  <!-- Đăng nhập / Đăng ký -->
  <div class="panel" id="authPanel" style="max-width:320px; margin:40px auto;">
    <header>
      <div class="title">ĐĂNG NHẬP</div>
    </header>
    <div class="content col">
      <input id="authEmail" placeholder="Email" />
      <input id="authPassword" type="password" placeholder="Mật khẩu" />
      <input id="authUsername" placeholder="Tên hiển thị (khi đăng ký)" />

      <div class="row">
        <button id="loginBtn">Đăng nhập</button>
        <button id="registerBtn" class="secondary">Đăng ký</button>
      </div>

      <div class="row">
        <button id="playAnonBtn" class="secondary" style="flex:1">Chơi thử (Anonymous)</button>
      </div>

      <div id="authStatus" style="font-size:12px;color:var(--muted)"></div>
    </div>
  </div>
</div>


<!-- =========================
  SCREEN: LOBBY (ẩn ban đầu)
  Dùng lại roomPanel làm "Sảnh chờ"
  (Không đổi id roomPanel để JS/CSS khỏi vỡ)
========================= -->
<div id="lobbyScreen" class="screen">
  <!-- GIỮ NGUYÊN deckModal ở ngoài screen cũng được,
       nhưng để lobby vẫn ok; mình để deckModal ngoài cùng phía dưới -->
  <div class="hud">
    <div class="panel collapsible" id="roomPanel">
      <header>
        <div class="title">PHÒNG CHƠI</div>
        <div class="row" style="gap:8px">
          <div class="badge" id="netBadge">OFFLINE</div>
        </div>
        <button class="collapse-btn" data-target="roomPanel">−</button>
      </header>

      <button id="openDeckBtn" class="secondary">Deck / SetCard</button>

      <div class="content col">
        <div class="row">
          <div class="content col" style="flex:1; min-width:220px">
            <label>Front folder (host)</label>
            <input id="frontBaseInput" class="mono" placeholder="VD: ./cards/" />
          </div>
          <div class="col" style="flex:1; min-width:220px">
            <label>Back image URL</label>
            <input id="backUrlInput" class="mono" placeholder="VD: ./cards/BACK.png" />
          </div>
          <button id="applyDeckBtn" class="secondary">Apply deck images (Host)</button>
        </div>

        <div class="col">
          <div class="row">
            <div class="col" style="flex:1; min-width:150px">
              <label>Tên hiển thị</label>
              <input id="nameInput" placeholder="VD: HIC / Player" maxlength="18" />
            </div>
            <div class="col" style="min-width:120px">
              <label>Chế độ</label>
              <select id="modeSelect">
                <option value="firebase">Firebase RTDB</option>
                <option value="local">Local (4 tab)</option>
                <option value="ws">WebSocket</option>
              </select>
            </div>
          </div>

          <div id="wsRow" class="row" style="display:none">
            <div class="col" style="flex:1; min-width:200px">
              <label>WebSocket URL</label>
              <input id="wsUrlInput" class="mono" placeholder="ws://localhost:8080" />
            </div>
          </div>

          <div class="row">
            <div class="col" style="flex:1; min-width:160px">
              <label>Mã phòng</label>
              <input id="roomInput" class="mono" placeholder="Tự tạo / nhập" />
            </div>
            <button id="createBtn">Tạo phòng (Host)</button>
            <button id="joinBtn" class="secondary">Vào phòng</button>
          </div>

          <div class="row">
            <button id="copyLinkBtn" class="secondary">Copy link</button>
            <button id="resetBtn" class="danger">Reset bàn (Host)</button>
            <button id="logoutBtn" class="danger" style="margin-left:auto">Đăng xuất</button>
          </div>

          <div class="hint">
            - Local mode: mở 4 tab, cùng mã phòng để test 4 người.<br/>
            - Server authoritative: Host giữ state, client chỉ gửi intent.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


<!-- =========================
  SCREEN: MATCH (ẩn ban đầu)
  Giữ nguyên #app và mọi id bên trong
========================= -->
<div id="matchScreen" class="screen">
  <div id="app">
    <canvas id="c"></canvas>
    <div id="toast"></div>

    <div class="hud">
      <!-- Trạng thái -->
      <div class="panel collapsible" id="sttPanel">
        <header>
          <div class="title">TRẠNG THÁI</div>
          <div class="badge" id="roomBadge">—</div>
          <button class="collapse-btn" data-target="sttPanel">−</button>
        </header>
        <div class="content col">
          <div class="row" style="justify-content:space-between">
            <div class="col" style="gap:4px">
              <div style="font-size:12px; color:var(--muted)">Bạn là</div>
              <div id="meLine" style="font-weight:700">—</div>
            </div>
            <div class="col" style="gap:4px; align-items:flex-end">
              <div style="font-size:12px; color:var(--muted)">Host</div>
              <div id="hostLine" style="font-weight:700">—</div>
            </div>
          </div>

          <div class="row" style="justify-content:space-between">
            <div class="col" style="gap:6px">
              <div style="font-size:12px; color:var(--muted)">Người chơi (tối đa 6)</div>
              <div id="playersLine" style="font-size:13px; line-height:1.4">—</div>
            </div>
          </div>

          <div class="row">
            <button id="leaveMatchBtn" class="danger" style="flex:1">Rời phòng</button>
          </div>

          <div class="hint">
            Privacy: bài trong <b>hand</b> của người khác chỉ hiện mặt sau với bạn.
          </div>
        </div>
      </div>
    </div>

    <!-- Chat -->
    <div class="panel collapsible" id="chatPanel">
      <header>
        <div class="title">CHAT</div>
        <div class="badge" id="chatBadge">—</div>
        <button class="collapse-btn" data-target="chatPanel">−</button>
      </header>
      <div class="content">
        <div id="chatLog"></div>
        <form id="chatForm">
          <input id="chatInput" placeholder="Nhập chat rồi Enter..." />
          <button type="submit">Gửi</button>
        </form>
      </div>
    </div>

    <!-- Inspector -->
    <div id="inspector">
      <div class="panel" style="height:100%; display:flex; flex-direction:column;">
        <header>
          <div class="title">CARD INSPECTOR</div>
          <div class="badge" id="insBadge">—</div>
        </header>

        <div class="content" style="display:flex; flex-direction:column; gap:10px; height:100%;">
          <div id="insPreview" style="
            flex:1;
            border:1px solid rgba(255,255,255,.12);
            border-radius: 14px;
            background: rgba(0,0,0,.18);
            display:flex; align-items:center; justify-content:center;
            overflow:hidden;
          ">
            <div style="color:rgba(233,236,255,.55); font-size:12px">Chọn 1 lá bài...</div>
          </div>

          <div class="row" style="justify-content:space-between">
            <button id="btnFlip" class="secondary" style="flex:1">Flip</button>
            <button id="btnDiscard" class="danger" style="flex:1">Discard</button>
          </div>
          <div class="row" style="justify-content:space-between">
            <button id="btnUnstack" class="secondary" style="flex:1">Unstack</button>
            <button id="btnShuffle" class="secondary" style="flex:1">Shuffle</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Help -->
    <div class="panel collapsible" id="help">
      <div class="panel">
        <header>
          <div class="title">PHÍM TẮT / TƯƠNG TÁC</div><div class="badge">Canvas</div>
          <button class="collapse-btn" data-target="help">−</button>
        </header>
        <div class="content hint">
          <div>
            <span class="kbd">Kéo thả</span> chuột để di chuyển bài (table / hand).<br/>
            <span class="kbd">D</span> rút 1 lá từ Deck về Hand của bạn (đứng gần Deck hoặc chọn Deck).<br/>
            <span class="kbd">F</span> lật lá / chồng (stack).<br/>
            <span class="kbd">S</span> trộn chồng (deck/stack).<br/>
            <span class="kbd">U</span> tách 1 lá ra khỏi chồng (lấy top).<br/>
            <span class="kbd">G</span> gom chồng: thả 1 lá lên lá khác (auto), hoặc nhấn G khi đang kéo để ép gom.<br/>
            <span class="kbd">Click</span> chọn lá/chồng. <span class="kbd">Esc</span> bỏ chọn.
          </div>
        </div>
      </div>
    </div>

  </div>
</div>


<!-- =========================
  POPUP: Deck / SetCard (giữ nguyên)
========================= -->
<div id="deckModal" class="modal" style="display:none;">
  <div class="modal-card panel">
    <header style="display:flex;align-items:center;justify-content:space-between;gap:10px">
      <div class="title">DECK / SET CARD</div>
      <button id="closeDeckBtn" class="collapse-btn">×</button>
    </header>

    <div class="content col" style="gap:10px">
      <div class="row" style="justify-content:space-between">
        <div class="badge" id="deckUserBadge">—</div>
        <button id="newSetBtn" class="secondary">+ Tạo set mới</button>
      </div>

      <div class="col" style="gap:6px">
        <label>Set đã lưu</label>
        <div class="row">
          <select id="setSelect" style="flex:1; min-width:220px"></select>
          <button id="loadSetBtn" class="secondary">Load</button>
          <button id="deleteSetBtn" class="danger">Xóa</button>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);width:100%">

      <div class="col" style="gap:6px">
        <label>Tên set</label>
        <input id="setNameInput" placeholder="VD: Poker / Game A" />
      </div>

      <div class="col" style="gap:6px">
        <label>Back URL (mặt sau — 1 link)</label>
        <input id="setBackUrlInput" class="mono" placeholder="https://.../back.png" />
      </div>

      <div class="row" style="justify-content:space-between">
        <div class="hint">Front URL (mặt trước). Bấm <b>+</b> để thêm lá.</div>
        <button id="addCardUrlBtn" class="secondary">+ Card</button>
      </div>

      <div id="cardUrlList" class="col" style="gap:8px; max-height:240px; overflow:auto; padding-right:6px"></div>

      <div class="row" style="justify-content:flex-end">
        <button id="saveSetBtn">Lưu set</button>
        <button id="loadSetToRoomBtn" class="secondary">Host: Load set vào Room</button>
      </div>

      <div class="hint" style="opacity:.9">
        - Khi host load set vào room: <b>D</b> sẽ rút ngẫu nhiên 1 lá từ set.<br/>
        - Người khác vào room sẽ tự dùng deck của host.
      </div>
    </div>
  </div>
</div>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script> 
<script>
/* =========================================================
   0) Utils / Core helpers
========================================================= */
"use strict";

const clamp   = (v, a, b) => Math.max(a, Math.min(b, v));
const randInt = (a, b) => (Math.random() * (b - a + 1) + a) | 0;
const now     = () => Date.now();
const uid     = () => (crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + "_" + Date.now()));
const deepClone = (obj) => (typeof structuredClone === "function" ? structuredClone(obj) : JSON.parse(JSON.stringify(obj)));

function escapeHtml(str){
  return (str ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function toast(text, ms=1600){
  const el = document.getElementById("toast");
  if (!el) return;
  el.textContent = text;
  el.style.display = "block";
  clearTimeout(el._t);
  el._t = setTimeout(()=> el.style.display="none", ms);
}

/* =========================================================
   1) Constants / Layout
========================================================= */
const COLORS = {
  red:   "#ff5c7a",
  blue:  "#5aa7ff",
  green: "#4ad37d",
  yellow:"#ffd166",
};
const COLOR_ORDER = ["red","blue","green","yellow"];

const ZONES = {
  table: "table",
  hand: "hand",
  deck: "deck",
  discard: "discard",
};

const CARD = { w: 86, h: 122, r: 12 };

const TABLE = {
  w: 1700,
  h: 900,
  margin: 40,
  handH: 150,
  sideW: 220,
  rightW: 260,
};

function zoneRects(){
  const m = TABLE.margin;
  const { w, h, handH, sideW, rightW } = TABLE;

  const tableRect = {
    x: m + sideW,
    y: m + handH,
    w: w - 2*m - sideW - rightW,
    h: h - 2*m - 2*handH
  };

  return {
    table: tableRect,

    handTopLeft: {
      x: tableRect.x,
      y: m,
      w: tableRect.w / 2,
      h: handH
    },
    handTopRight: {
      x: tableRect.x + tableRect.w / 2,
      y: m,
      w: tableRect.w / 2,
      h: handH
    },

    handBottomLeft: {
      x: tableRect.x,
      y: tableRect.y + tableRect.h,
      w: tableRect.w / 2,
      h: handH
    },
    handBottomRight: {
      x: tableRect.x + tableRect.w / 2,
      y: tableRect.y + tableRect.h,
      w: tableRect.w / 2,
      h: handH
    },

    handRightTop: {
      x: w - m - rightW,
      y: tableRect.y,
      w: rightW,
      h: tableRect.h / 2
    },
    handRightBottom: {
      x: w - m - rightW,
      y: tableRect.y + tableRect.h / 2,
      w: rightW,
      h: tableRect.h / 2
    },

    deck: {
      x: m,
      y: tableRect.y,
      w: sideW,
      h: tableRect.h / 2
    },
    discard: {
      x: m,
      y: tableRect.y + tableRect.h / 2,
      w: sideW,
      h: tableRect.h / 2
    }
  };
}

/* =========================================================
   2) Canvas / Camera
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

const camera = { scale: 1, offsetX: 0, offsetY: 0 };

function updateCamera(){
  const pad = 18;
  const sx = (innerWidth - pad*2) / TABLE.w;
  const sy = (innerHeight - pad*2) / TABLE.h;
  camera.scale = Math.min(sx, sy);
  camera.offsetX = (innerWidth - TABLE.w * camera.scale) / 2;
  camera.offsetY = (innerHeight - TABLE.h * camera.scale) / 2;
}
updateCamera();
addEventListener("resize", updateCamera);

function toScreen(p){
  return { x: camera.offsetX + p.x * camera.scale, y: camera.offsetY + p.y * camera.scale };
}
function toWorld(p){
  return { x: (p.x - camera.offsetX) / camera.scale, y: (p.y - camera.offsetY) / camera.scale };
}

/* =========================================================
   3) UI refs (giữ nguyên id của bạn)
========================================================= */
const UI = {
  modeSelect: document.getElementById("modeSelect"),
  wsRow: document.getElementById("wsRow"),
  wsUrlInput: document.getElementById("wsUrlInput"),
  nameInput: document.getElementById("nameInput"),
  roomInput: document.getElementById("roomInput"),
  createBtn: document.getElementById("createBtn"),
  joinBtn: document.getElementById("joinBtn"),
  copyLinkBtn: document.getElementById("copyLinkBtn"),
  resetBtn: document.getElementById("resetBtn"),
  netBadge: document.getElementById("netBadge"),
  roomBadge: document.getElementById("roomBadge"),
  meLine: document.getElementById("meLine"),
  hostLine: document.getElementById("hostLine"),
  playersLine: document.getElementById("playersLine"),
  chatBadge: document.getElementById("chatBadge"),
  chatLog: document.getElementById("chatLog"),
  chatForm: document.getElementById("chatForm"),
  chatInput: document.getElementById("chatInput"),
  frontBaseInput: document.getElementById("frontBaseInput"),
  backUrlInput: document.getElementById("backUrlInput"),
  applyDeckBtn: document.getElementById("applyDeckBtn"),
};

/* =========================================================
   4) Screens Router
   - Bạn đang dùng lẫn: screenAuth/screenLobby/screenMatch và authScreen/lobbyScreen/matchScreen
   - FIX: Tự detect cái nào tồn tại
========================================================= */
function pickScreenEl(a, b){
  return document.getElementById(a) || document.getElementById(b) || null;
}
const SCREENS = {
  auth:  pickScreenEl("screenAuth","authScreen"),
  lobby: pickScreenEl("screenLobby","lobbyScreen"),
  match: pickScreenEl("screenMatch","matchScreen"),
};

function setScreen(name){
  // nếu bạn chưa tạo wrapper screen thì bỏ qua
  const keys = Object.keys(SCREENS);
  const any = keys.some(k => !!SCREENS[k]);
  if (!any) return;

  for (const k of keys){
    if (SCREENS[k]) SCREENS[k].classList.remove("active");
  }
  if (SCREENS[name]) SCREENS[name].classList.add("active");
}

function goAuth(){ setScreen("auth"); }
function goLobby(){ setScreen("lobby"); }
function goMatch(){
  setScreen("match");
  try{ resize(); updateCamera(); }catch(e){}
}

/* =========================================================
   5) Inspector (card inspector popup)
========================================================= */
const INS = {
  badge: document.getElementById("insBadge"),
  preview: document.getElementById("insPreview"),
  btnFlip: document.getElementById("btnFlip"),
  btnDiscard: document.getElementById("btnDiscard"),
  btnUnstack: document.getElementById("btnUnstack"),
  btnShuffle: document.getElementById("btnShuffle"),
};

function getWorldPosOfTarget(st, target){
  if (!st || !target) return null;
  if (target.type === "card"){
    const c = st.cards?.[target.id];
    if (!c) return null;
    return {x: c.x, y: c.y};
  } else {
    const s = st.stacks?.[target.id];
    if (!s) return null;
    return {x: s.x, y: s.y};
  }
}

function positionInspectorNearTarget(){
  const st = getState();
  const sel = client.selected;
  if (!st || !sel) return;

  const wp = getWorldPosOfTarget(st, sel);
  if (!wp) return;

  const sp = toScreen(wp);
  const ins = document.getElementById("inspector");
  if (!ins) return;

  const pad = 10;
  const offsetX = 20;
  const offsetY = -20;

  const rect = ins.getBoundingClientRect();
  let left = sp.x + offsetX;
  let top  = sp.y + offsetY;

  left = clamp(left, pad, innerWidth - rect.width - pad);
  top  = clamp(top,  pad, innerHeight - rect.height - pad);

  ins.style.left = left + "px";
  ins.style.top  = top + "px";
}

function showInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "block";
  updateInspector();
  requestAnimationFrame(positionInspectorNearTarget);
}
function hideInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "none";
}

function updateInspector(){
  const st = getState();
  const sel = client.selected;

  if (!INS.badge || !INS.preview) return;

  if (!st || !sel){
    INS.badge.textContent = "—";
    INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Chọn 1 lá bài...</div>`;
    return;
  }

  // ===== DECK (SPECIAL CASE) =====
  if (sel.type === "stack" && sel.id === "stack_deck"){
    const count = st.stacks?.stack_deck?.cardIds?.length || 0;
    INS.badge.textContent = "DECK";
    INS.preview.innerHTML = `
      <div style="text-align:center;font-size:13px">
        <div>${count} cards</div>
        <div style="opacity:.6;margin-top:6px">Press D to draw</div>
        <div style="opacity:.4;margin-top:4px">Press S to shuffle</div>
      </div>
    `;
    return;
  }

  // ===== CARD =====
  if (sel.type === "card"){
    const c = st.cards?.[sel.id];
    INS.badge.textContent = sel.id + (c?.lockedBy ? " (LOCK)" : "");

    // FIX: ưu tiên frontUrl (setCard), nếu không có thì mới dùng frontBase+id.png
    const frontUrl = c?.frontUrl
      ? c.frontUrl
      : (st.assets?.frontBase ? (st.assets.frontBase + sel.id + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c?.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">
          No image set. Host hãy set Back URL hoặc load setCard.
        </div>`;
    return;
  }

  // ===== STACK (NORMAL) =====
  if (sel.type === "stack"){
    const s = st.stacks?.[sel.id];
    const topId = s?.cardIds?.[0];
    INS.badge.textContent = `${sel.id} (${s?.cardIds?.length || 0})`;

    if (!topId){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Empty stack</div>`;
      return;
    }

    const c = st.cards?.[topId];
    const frontUrl = c?.frontUrl
      ? c.frontUrl
      : (st.assets?.frontBase ? (st.assets.frontBase + topId + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c?.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">No image set.</div>`;
  }
}

/* =========================================================
   6) Networking Abstraction (Local / WS / Firebase)
========================================================= */
class NetTransport {
  constructor(){ this.onMessage = ()=>{}; this.onStatus = ()=>{}; }
  send(_msg) {}
  close() {}
}

class LocalBroadcastTransport extends NetTransport {
  constructor(roomCode, selfId){
    super();
    this.roomCode = roomCode;
    this.selfId = selfId;
    this.bc = new BroadcastChannel("ttc_" + roomCode);
    this.bc.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg || msg._from === this.selfId) return;
      this.onMessage(msg);
    };
    this.onStatus({connected:true, mode:"local"});
  }
  send(msg){
    this.bc.postMessage({...msg, _from:this.selfId});
  }
  close(){
    this.onStatus({connected:false, mode:"local"});
    this.bc.close();
  }
}

class LocalStorageTransport extends NetTransport {
  constructor(roomCode, selfId){
    super();
    this.roomCode = roomCode;
    this.selfId = selfId;
    this.key = "ttc_ls_" + roomCode;

    this._onStorage = (ev) => {
      if (ev.key !== this.key || !ev.newValue) return;
      try{
        const msg = JSON.parse(ev.newValue);
        if (!msg || msg._from === this.selfId) return;
        this.onMessage(msg);
      }catch(e){}
    };
    window.addEventListener("storage", this._onStorage);
    this.onStatus({connected:true, mode:"local"});
  }

  send(msg){
    try{
      const payload = JSON.stringify({...msg, _from:this.selfId, _t: Date.now()});
      localStorage.setItem(this.key, payload);
    }catch(e){}
  }

  close(){
    window.removeEventListener("storage", this._onStorage);
    this.onStatus({connected:false, mode:"local"});
  }
}

class WebSocketTransport extends NetTransport {
  constructor(url){
    super();
    this.ws = new WebSocket(url);
    this.ws.onopen = () => this.onStatus({connected:true, mode:"ws"});
    this.ws.onclose = () => this.onStatus({connected:false, mode:"ws"});
    this.ws.onerror = () => this.onStatus({connected:false, mode:"ws"});
    this.ws.onmessage = (ev) => {
      try{
        const msg = JSON.parse(ev.data);
        this.onMessage(msg);
      }catch(e){}
    };
  }
  send(msg){
    if (this.ws.readyState === 1) this.ws.send(JSON.stringify(msg));
  }
  close(){ try{ this.ws.close(); }catch(e){} }
}

/* =========================================================
   7) Game State / Redaction (Authoritative on Host)
========================================================= */
function makeFreshTableState(roomCode, hostId){
  const st = {
    roomCode,
    hostId,
    players: [],
    cards: {},
    stacks: {},
    chat: [],
    version: 1,
    assets: { frontBase:"", backUrl:"" },
    _deckPool: [], // FIX: bạn dùng _deckPool trong draw => phải có sẵn
  };

  const rects = zoneRects();
  const deckX = rects.deck.x + rects.deck.w/2;
  const deckY = rects.deck.y + rects.deck.h/2;

  const deckStackId = "stack_deck";
  st.stacks[deckStackId] = { id: deckStackId, zone: ZONES.deck, owner: null, x: deckX, y: deckY, cardIds: [] };

  for(let i=1;i<=40;i++){
    const id = "C" + String(i).padStart(2,"0");
    st.cards[id] = {
      id,
      frontSeed: i,
      faceUp: false,
      x: deckX,
      y: deckY,
      zone: ZONES.deck,
      owner: null,
      stackId: deckStackId,
      order: i,
    };
    st.stacks[deckStackId].cardIds.push(id);
  }

  const discardStackId = "stack_discard";
  const discardX = rects.discard.x + rects.discard.w/2;
  const discardY = rects.discard.y + rects.discard.h/2;
  st.stacks[discardStackId] = { id: discardStackId, zone: ZONES.discard, owner: null, x: discardX, y: discardY, cardIds: [] };

  return st;
}

function ensureStateShape(state){
  if (!state || typeof state !== "object") return null;
  const s = deepClone(state);
  if (!Array.isArray(s.players)) s.players = [];
  if (!s.cards || typeof s.cards !== "object") s.cards = {};
  if (!s.stacks || typeof s.stacks !== "object") s.stacks = {};
  if (!Array.isArray(s.chat)) s.chat = [];
  if (!s.assets || typeof s.assets !== "object") s.assets = { frontBase:"", backUrl:"" };
  if (!Array.isArray(s._deckPool)) s._deckPool = [];
  if (typeof s.version !== "number") s.version = 1;
  return s;
}

function redactStateForViewer(state, viewerId){
  const s = ensureStateShape(state);
  if (!s) return null;

  const viewer = s.players.find(p => p && p.id === viewerId) || null;

  for (const cardId in s.cards){
    const c = s.cards[cardId];
    if (!c) continue;

    if (c.zone === ZONES.hand && c.owner && c.owner !== viewerId){
      c.faceUp = false;
      c.frontSeed = 0;
      if (c.frontUrl) c.frontUrl = "";
    }
  }

  s._viewer = viewer ? {id: viewer.id, name: viewer.name, color: viewer.color} : null;
  return s;
}

/* =========================================================
   8) Host Controller (Authoritative)
========================================================= */
function canInteract(card, actorId){
  if (!card) return false;
  if (card.zone === ZONES.hand) return card.owner === actorId;
  return true; // table/deck/discard allow (deck dragging is blocked separately)
}
function canInteractStack(stack, actorId){
  if (!stack) return false;
  if (stack.zone === ZONES.hand) return stack.owner === actorId;
  return true;
}

class HostController {
  constructor(roomCode, hostId){
    this.roomCode = roomCode;
    this.hostId = hostId;
    this.state = makeFreshTableState(roomCode, hostId);
  }

  bumpVersion(){ this.state.version = (this.state.version||0) + 1; }

  addOrUpdatePlayer({id,name}){
    // FIX: chống players undefined
    if (!Array.isArray(this.state.players)) this.state.players = [];

    let p = this.state.players.find(x=>x && x.id===id);
    if (!p){
      if (this.state.players.length >= 6) return {ok:false, reason:"Room full"};

      const used = new Set(this.state.players.map(x=>x.color).filter(Boolean));
      const color = COLOR_ORDER.find(c=>!used.has(c)) || COLOR_ORDER[this.state.players.length % COLOR_ORDER.length];
      const seat = this.state.players.length;
      p = {id, name: name || "Player", color, seat, connectedAt: now()};
      this.state.players.push(p);
    }else{
      p.name = name || p.name;
    }
    this.bumpVersion();
    return {ok:true, player:p};
  }

  removePlayer(id){
    this.state.players = (this.state.players||[]).filter(p=>p && p.id!==id);
    this.bumpVersion();
  }

  applyIntent(fromId, action){
    const st = this.state = ensureStateShape(this.state) || makeFreshTableState(this.roomCode, this.hostId);
    const player = st.players.find(p=>p.id===fromId);
    if (!player) return {ok:false, reason:"Not in room"};

    const rects = zoneRects();
    const ensureCard = (id) => st.cards[id];
    const ensureStack = (id) => st.stacks[id];

    const detachFromStack = (cardId) => {
      const c = ensureCard(cardId);
      if (!c || !c.stackId) return;
      const stack = ensureStack(c.stackId);
      if (!stack) { c.stackId = null; return; }
      stack.cardIds = (stack.cardIds||[]).filter(id=>id!==cardId);
      c.stackId = null;
      if ((stack.cardIds?.length||0) === 0 && stack.id !== "stack_deck" && stack.id !== "stack_discard"){
        delete st.stacks[stack.id];
      }
    };

    const attachToStackTop = (cardId, stackId) => {
      const c = ensureCard(cardId);
      const stack = ensureStack(stackId);
      if (!c || !stack) return;
      detachFromStack(cardId);
      c.stackId = stackId;
      c.zone = stack.zone;
      c.owner = stack.owner;
      c.x = stack.x; c.y = stack.y;
      stack.cardIds = stack.cardIds || [];
      stack.cardIds.unshift(cardId);
    };

    const createStackFromCard = (cardId) => {
      const c = ensureCard(cardId);
      if (!c) return null;
      const sid = "stack_" + uid().slice(0,8);
      st.stacks[sid] = { id:sid, zone:c.zone, owner:c.owner, x:c.x, y:c.y, cardIds:[cardId] };
      c.stackId = sid;
      return sid;
    };

    const HAND_ZONES = [
      { key: "handTopLeft", seat: 0 },
      { key: "handBottomLeft", seat: 1 },
      { key: "handTopRight", seat: 2 },
      { key: "handBottomRight", seat: 3 },
      { key: "handRightTop", seat: 4 },
      { key: "handRightBottom", seat: 5 },
    ];

    function normalizeCardZoneFromPos(x, y){
      for (const hz of HAND_ZONES){
        const r = rects[hz.key];
        if (!r) continue;

        const inRect = (x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h);
        if (!inRect) continue;

        const ownerPlayer = st.players.find(pp => pp.seat === hz.seat);
        if (!ownerPlayer){
          return { zone: ZONES.table, owner: null };
        }
        return { zone: ZONES.hand, owner: ownerPlayer.id };
      }
      return { zone: ZONES.table, owner: null };
    }

    const seatToHandKey = (seat) => {
      switch (seat){
        case 0: return "handTopLeft";
        case 1: return "handBottomLeft";
        case 2: return "handTopRight";
        case 3: return "handBottomRight";
        case 4: return "handRightTop";
        case 5: return "handRightBottom";
        default: return null;
      }
    };

    switch(action.type){
      case "move": {
        const {targetType, id, x, y} = action;

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};

          // chặn kéo card trực tiếp từ deck
          if (c.stackId === "stack_deck") return {ok:false, reason:"Use draw (D) to take from deck"};

          detachFromStack(id);

          const z = normalizeCardZoneFromPos(x, y);
          c.x = x; c.y = y;
          c.zone = z.zone;
          c.owner = (z.zone === ZONES.hand) ? z.owner : null;
          c.stackId = null;
        }

        if (targetType === "stack"){
          const s = ensureStack(id);
          if (!s) return {ok:false, reason:"Missing stack"};
          if (s.id === "stack_deck") return {ok:false, reason:"Deck fixed"};
          if (!canInteractStack(s, fromId)) return {ok:false, reason:"No access"};

          const z = normalizeCardZoneFromPos(x, y);
          s.x = x; s.y = y;
          s.zone = z.zone;
          s.owner = (z.zone === ZONES.hand) ? z.owner : null;

          for (const cid of (s.cardIds||[])){
            const c = ensureCard(cid);
            if (!c) continue;
            c.x = x; c.y = y;
            c.zone = s.zone;
            c.owner = s.owner;
          }
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "flip": {
        const {targetType, id} = action;

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};
          c.faceUp = !c.faceUp;
        } else {
          const s = ensureStack(id);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
          const topId = s.cardIds?.[0];
          if (topId){
            const c = ensureCard(topId);
            if (c) c.faceUp = !c.faceUp;
          }
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "shuffle": {
        const {stackId} = action;
        const s = ensureStack(stackId);
        if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};

        for(let i=(s.cardIds?.length||0)-1;i>0;i--){
          const j = randInt(0,i);
          [s.cardIds[i], s.cardIds[j]] = [s.cardIds[j], s.cardIds[i]];
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "draw": {
        const handKey = seatToHandKey(player.seat);
        const handRect = rects[handKey];
        if (!handRect) return {ok:false, reason:"No hand zone"};

        // draw from custom pool urls if exists
        const pool = (Array.isArray(st._deckPool) ? st._deckPool : []).filter(Boolean);
        if (pool.length > 0){
          const pick = pool[randInt(0, pool.length-1)];
          const newId = "CI_" + uid().slice(0,10);

          st.cards[newId] = {
            id: newId,
            frontSeed: 1,
            faceUp: true,
            x: handRect.x + handRect.w/2 + randInt(-60,60),
            y: handRect.y + handRect.h/2 + randInt(-20,20),
            zone: ZONES.hand,
            owner: fromId,
            stackId: null,
            order: now(),
            frontUrl: pick,
            tintOwner: fromId
          };

          this.bumpVersion();
          return {ok:true};
        }

        // fallback physical deck stack_deck
        const deck = st.stacks["stack_deck"];
        if (!deck || (deck.cardIds?.length||0) === 0) return {ok:false, reason:"Deck empty"};

        const cid = deck.cardIds.shift();
        const c = ensureCard(cid);
        if (!c) return {ok:false, reason:"Missing card"};

        c.zone = ZONES.hand;
        c.owner = fromId;
        c.faceUp = true;
        c.x = handRect.x + handRect.w/2 + randInt(-60,60);
        c.y = handRect.y + handRect.h/2 + randInt(-20,20);
        c.stackId = null;
        c.tintOwner = fromId;

        this.bumpVersion();
        return {ok:true};
      }

      case "discard": {
        const {targetType, id} = action;
        const discard = st.stacks["stack_discard"];
        if (!discard) return {ok:false, reason:"Missing discard"};

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};

          attachToStackTop(id, discard.id);
          discard.zone = ZONES.discard;
          discard.owner = null;

          c.zone = ZONES.discard;
          c.owner = null;
          c.faceUp = true;
        } else {
          const s = ensureStack(id);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};

          const cards = [...(s.cardIds||[])];
          for (const cid of cards.reverse()){
            attachToStackTop(cid, discard.id);
            const c = ensureCard(cid);
            if (!c) continue;
            c.faceUp = true;
            c.owner = null;
            c.zone = ZONES.discard;
          }
          if (s.id !== "stack_deck" && s.id !== "stack_discard") delete st.stacks[s.id];
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "stack": {
        const {dragTargetType, dragId, dropOnType, dropOnId} = action;

        let dragCardIds = [];
        let dragStackId = null;

        if (dragTargetType === "card"){
          const c = ensureCard(dragId);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};
          dragCardIds = [dragId];
          dragStackId = c.stackId;
        } else {
          const s = ensureStack(dragId);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
          dragCardIds = [...(s.cardIds||[])];
          dragStackId = s.id;
        }

        let dropStackId = null;
        if (dropOnType === "card"){
          const c2 = ensureCard(dropOnId);
          if (!c2) return {ok:false, reason:"Missing drop card"};
          dropStackId = c2.stackId || createStackFromCard(c2.id);
        } else {
          const s2 = ensureStack(dropOnId);
          if (!s2) return {ok:false, reason:"Missing drop stack"};
          dropStackId = s2.id;
        }

        if (!dropStackId) return {ok:false, reason:"No drop stack"};
        if (dragStackId && dragStackId === dropStackId) return {ok:true};

        const dropStack = ensureStack(dropStackId);
        if (!canInteractStack(dropStack, fromId)) return {ok:false, reason:"No access"};

        const moving = [...dragCardIds];

        if (dragTargetType === "stack"){
          const s = ensureStack(dragId);
          if (s && s.id !== "stack_deck" && s.id !== "stack_discard") delete st.stacks[s.id];
        } else {
          detachFromStack(dragId);
        }

        for (let i=moving.length-1; i>=0; i--){
          attachToStackTop(moving[i], dropStackId);
        }

        for (const cid of (dropStack.cardIds||[])){
          const c = ensureCard(cid);
          if (!c) continue;
          c.x = dropStack.x; c.y = dropStack.y;
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "unstack": {
        const {stackId} = action;
        const s = ensureStack(stackId);
        if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
        if ((s.cardIds?.length||0) <= 1) return {ok:true};

        const top = s.cardIds.shift();
        const c = ensureCard(top);
        if (!c) return {ok:false, reason:"Missing card"};

        c.stackId = null;
        c.x = s.x + randInt(-90,90);
        c.y = s.y + randInt(-60,60);
        c.zone = s.zone;
        c.owner = s.owner;

        this.bumpVersion();
        return {ok:true};
      }

      case "chat": {
        const text = (action.text || "").toString().slice(0, 300);
        if (!text.trim()) return {ok:true};
        st.chat.push({id: uid(), at: now(), fromId, text});
        if (st.chat.length > 120) st.chat.splice(0, st.chat.length - 120);
        this.bumpVersion();
        return {ok:true};
      }

      case "reset": {
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        const keepPlayers = deepClone(st.players);
        this.state = makeFreshTableState(st.roomCode, st.hostId);
        this.state.players = keepPlayers;
        this.bumpVersion();
        return {ok:true};
      }

      case "setAssets": {
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        st.assets.frontBase = (action.frontBase||"").trim();
        st.assets.backUrl = (action.backUrl||"").trim();
        this.bumpVersion();
        return {ok:true};
      }

      case "join": {
        // no-op; host side already addOrUpdatePlayer
        this.bumpVersion();
        return {ok:true};
      }

      default:
        return {ok:false, reason:"Unknown action"};
    }
  }
}

/* =========================================================
   9) Firebase (Auth + RTDB)
========================================================= */
const firebaseConfig = {
  apiKey: "AIzaSyBze3rgBuJ8Ex7c_yWnEVu76huNAuSFll8",
  authDomain: "tablegame-dc4a8.firebaseapp.com",
  databaseURL: "https://tablegame-dc4a8-default-rtdb.firebaseio.com",
  projectId: "tablegame-dc4a8",
  storageBucket: "tablegame-dc4a8.firebasestorage.app",
  messagingSenderId: "715606656270",
  appId: "1:715606656270:web:a1c4055c2d307201f1035f",
  measurementId: "G-KHWGKGT3GE"
};

let FB = { app:null, auth:null, db:null, user:null, uid:null, username:null };

function fbInitOnce(){
  if (FB.app) return;
  FB.app = firebase.initializeApp(firebaseConfig);
  FB.auth = firebase.auth();
  FB.db = firebase.database();
}

async function fbEnsureAuth(){
  fbInitOnce();
  if (!FB.auth.currentUser) await FB.auth.signInAnonymously();

  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  // ưu tiên nameInput (lobby), nếu rỗng thì fallback "Player"
  FB.username = ((UI.nameInput?.value || "").trim().slice(0,18)) || "Player";

  const uref = FB.db.ref(`AllUser/${FB.uid}`);
  const snap = await uref.get();

  if (!snap.exists()){
    await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
  }else{
    const cur = snap.val() || {};
    if ((cur.username||"") !== FB.username){
      await uref.update({ username: FB.username });
    }
    if (!cur.setCard) await uref.update({ setCard:{} });
  }
}

async function fbAllocateRoomNo(){
  const db = FB.db;

  const freeRef = db.ref("RoomIndex/freeNos");
  const freeSnap = await freeRef.get();
  if (freeSnap.exists()){
    const obj = freeSnap.val() || {};
    const nums = Object.keys(obj).map(x=>parseInt(x,10)).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
    for (const n of nums){
      const oneRef = db.ref(`RoomIndex/freeNos/${n}`);
      const r = await oneRef.transaction((cur)=>{ if (cur === true) return null; return; });
      if (r.committed) return n;
    }
  }

  const nextRef = db.ref("RoomIndex/nextNo");
  const res = await nextRef.transaction((cur)=> (typeof cur !== "number" ? 1 : cur + 1));
  const newVal = res.snapshot.val();
  const roomNo = Math.max(1, newVal - 1);
  return roomNo;
}

async function fbReleaseRoomNo(roomNo){
  if (!roomNo) return;
  await FB.db.ref(`RoomIndex/freeNos/${roomNo}`).set(true);
}

class FirebaseTransport extends NetTransport {
  constructor(roomId){
    super();
    this.roomId = roomId; // FIX: trước đây nhiều bạn viết this.roomId=this.roomId
    this.roomRef = FB.db.ref(`AllRoom/${this.roomId}`);
    this.intentsRef = this.roomRef.child("intents");
    this.stateRef = this.roomRef.child("state");
    this.presRef = this.roomRef.child(`presence/${FB.uid}`);

    this._stateCb = null;
    this._intentsCb = null;
    this._connectedRef = FB.db.ref(".info/connected");
    this._connectedCb = null;

    this.onStatus({connected:true, mode:"firebase"});
  }

  async attachPresence(){
    this._connectedCb = async (snap)=>{
      if (snap.val() === true){
        await this.presRef.set(true);
        this.presRef.onDisconnect().remove();
      }
    };
    this._connectedRef.on("value", this._connectedCb);
  }

  listenState(onState){
    this._stateCb = (snap)=> onState(snap.val());
    this.stateRef.on("value", this._stateCb);
  }

  listenIntentsAsHost(onIntent){
    this._intentsCb = (snap)=>{
      const v = snap.val();
      if (!v) return;
      onIntent(v, snap.key);
    };
    this.intentsRef.limitToLast(200).on("child_added", this._intentsCb);
  }

  async sendIntent(action){
    const payload = { fromUid: FB.uid, fromName: FB.username, at: Date.now(), action };
    await this.intentsRef.push(payload);
  }

  async writeState(state){
    await this.stateRef.set(state);
  }

  close(){
    try{
      if (this._stateCb) this.stateRef.off("value", this._stateCb);
      if (this._intentsCb) this.intentsRef.off("child_added", this._intentsCb);
      if (this._connectedCb) this._connectedRef.off("value", this._connectedCb);
      this.presRef.remove();
    }catch(e){}
    this.onStatus({connected:false, mode:"firebase"});
  }
}

/* =========================================================
   10) Client State + Transport wiring
========================================================= */
const client = {
  selfId: uid(),
  selfName: "",
  roomCode: "",
  roomId: "",
  roomMeta: { roomNo:null, roomId:null },

  isHost: false,
  transport: null,
  host: null,
  authoritative: null,
  lastVersion: 0,
  selected: null,
  dragging: null,
};

function setNetBadge(text, color=null){
  if (!UI.netBadge) return;
  UI.netBadge.textContent = text;
  UI.netBadge.style.borderColor = color ? color : "rgba(255,255,255,.12)";
}

function getState(){
  if (client.isHost && client.host){
    return client.authoritative || redactStateForViewer(client.host.state, client.selfId);
  }
  return client.authoritative;
}

function setStatusUI(){
  const s = client.authoritative;
  if (!s){
    UI.roomBadge && (UI.roomBadge.textContent = "—");
    UI.meLine && (UI.meLine.textContent = "—");
    UI.hostLine && (UI.hostLine.textContent = "—");
    UI.playersLine && (UI.playersLine.textContent = "—");
    UI.chatBadge && (UI.chatBadge.textContent = "—");
    updateInspector();
    return;
  }

  UI.roomBadge && (UI.roomBadge.textContent = "ROOM " + s.roomCode);
  UI.chatBadge && (UI.chatBadge.textContent = "v" + s.version);

  const me = s.players.find(p=>p.id===client.selfId);
  if (UI.meLine){
    if (me){
      UI.meLine.innerHTML = `<span style="display:inline-flex;align-items:center;gap:8px">
        <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[me.color]};box-shadow:0 0 0 3px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.18)"></span>
        <span>${escapeHtml(me.name)} (${me.color})</span>
      </span>`;
    }else{
      UI.meLine.textContent = "(chưa vào phòng)";
    }
  }

  const hostP = s.players.find(p=>p.id===s.hostId);
  if (UI.hostLine){
    UI.hostLine.innerHTML = hostP
      ? `<span style="display:inline-flex;align-items:center;gap:8px">
          <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[hostP.color]};border:1px solid rgba(255,255,255,.18)"></span>
          <span>${escapeHtml(hostP.name)}</span>
        </span>`
      : "—";
  }

  if (UI.playersLine){
    UI.playersLine.innerHTML = s.players.map(p=>{
      return `<div style="display:flex;align-items:center;gap:8px;margin:2px 0">
        <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[p.color]};border:1px solid rgba(255,255,255,.18)"></span>
        <span style="color:rgba(233,236,255,.92)">${escapeHtml(p.name)}</span>
        <span style="color:rgba(233,236,255,.55);font-size:12px">(${p.color})</span>
        ${p.id===s.hostId ? `<span style="margin-left:auto;color:var(--muted);font-size:11px;border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:999px">HOST</span>` : ""}
      </div>`;
    }).join("");
  }

  updateInspector();

  // nếu inspector đang mở mà target mất -> hide, còn thì reposition
  const ins = document.getElementById("inspector");
  if (ins && ins.style.display === "block"){
    const sel = client.selected;
    if (!sel) hideInspectorPopup();
    else {
      const wp = getWorldPosOfTarget(s, sel);
      if (!wp) hideInspectorPopup();
      else positionInspectorNearTarget();
    }
  }

  renderChat(s);
}

function sendToServer(msg){
  if (!client.transport) return;
  client.transport.send(msg);
}

async function sendIntentFirebase(action){
  if (!(client.transport instanceof FirebaseTransport)) return;
  await client.transport.sendIntent(action);
}

function sendIntent(action){
  if (UI.modeSelect?.value === "firebase"){
    sendIntentFirebase(action);
    return;
  }
  sendToServer({
    type: "intent",
    roomCode: client.roomCode,
    fromId: client.selfId,
    action,
    at: now(),
  });
}

function installTransport(t){
  if (client.transport) client.transport.close();
  client.transport = t;

  t.onStatus = (st) => {
    if (st.connected){
      if (st.mode === "firebase") setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
      else if (st.mode === "ws") setNetBadge("WS", "rgba(73,209,124,.55)");
      else setNetBadge("LOCAL", "rgba(73,209,124,.55)");
    } else {
      setNetBadge("OFFLINE", "rgba(255,255,255,.12)");
    }
  };

  t.onMessage = (msg) => {
    if (!msg) return;

    // Firebase transport không dùng protocol local/ws ở đây
    if (client.transport instanceof FirebaseTransport) return;

    // Local/WS
    if (msg.roomCode !== client.roomCode) return;

    if (msg.type === "hello" && client.isHost && client.host){
      const res = client.host.addOrUpdatePlayer({id: msg.fromId, name: msg.name});
      if (!res.ok){
        sendToServer({type:"deny", roomCode: client.roomCode, toId: msg.fromId, reason: res.reason});
        return;
      }
      client.host.applyIntent(client.host.hostId, {type:"chat", text:`${msg.name} joined.`});
      broadcastStateRaw();
      return;
    }

    if (msg.type === "bye" && client.isHost && client.host){
      client.host.removePlayer(msg.fromId);
      client.host.applyIntent(client.host.hostId, {type:"chat", text:`A player left.`});
      broadcastStateRaw();
      return;
    }

    if (msg.type === "deny"){
      if (msg.toId === client.selfId){
        toast("Không vào được phòng: " + (msg.reason || "Denied"));
        leaveRoom();
      }
      return;
    }

    if (msg.type === "intent"){
      if (client.isHost && client.host){
        const r = client.host.applyIntent(msg.fromId, msg.action);
        if (!r.ok && msg.fromId === client.selfId) toast("Action fail: " + r.reason);
        broadcastStateRaw();
      }
      return;
    }

    if (msg.type === "stateRaw"){
      if (client.isHost) return;
      const red = redactStateForViewer(msg.state, client.selfId);
      if (red && (red.version >= (client.lastVersion||0))){
        client.authoritative = red;
        client.lastVersion = red.version;
        setStatusUI();
      }
      return;
    }
  };
}

/* =========================================================
   11) Room: Local/WS create/join/leave
========================================================= */
function genRoomCode(){
  const a = Math.random().toString(36).slice(2, 6).toUpperCase();
  const b = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `${a}-${b}`;
}

function readInputs(){
  client.selfName = (UI.nameInput?.value || "").trim().slice(0,18) || "Player";
  client.roomCode = (UI.roomInput?.value || "").trim().toUpperCase();
  if (!client.roomCode) client.roomCode = genRoomCode();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;
}

function makeTransportForCurrentMode(){
  const mode = UI.modeSelect?.value || "local";

  if (mode === "ws"){
    const url = (UI.wsUrlInput?.value || "").trim() || "ws://localhost:8080";
    return new WebSocketTransport(url);
  }

  try{
    if (typeof BroadcastChannel !== "undefined"){
      return new LocalBroadcastTransport(client.roomCode, client.selfId);
    }
  }catch(e){}
  return new LocalStorageTransport(client.roomCode, client.selfId);
}

function broadcastStateRaw(){
  if (!client.isHost || !client.host) return;
  const st = client.host.state;

  sendToServer({type:"stateRaw", roomCode: client.roomCode, state: deepClone(st), at: now()});

  client.authoritative = redactStateForViewer(st, client.selfId);
  client.lastVersion = client.authoritative.version;
  setStatusUI();
}

function createRoomAsHost_LocalOrWS(){
  readInputs();

  client.isHost = true;
  client.host = new HostController(client.roomCode, client.selfId);

  const t = makeTransportForCurrentMode();
  installTransport(t);

  // host add itself
  client.host.addOrUpdatePlayer({ id: client.selfId, name: client.selfName });

  client.authoritative = redactStateForViewer(client.host.state, client.selfId);
  client.lastVersion = client.authoritative.version;

  setStatusUI();
  broadcastStateRaw();

  toast("Đã tạo phòng (Host)");
  goMatch();
}

function joinRoomAsClient_LocalOrWS(){
  readInputs();
  client.isHost = false;
  client.host = null;

  const t = makeTransportForCurrentMode();
  installTransport(t);

  sendToServer({type:"hello", roomCode: client.roomCode, fromId: client.selfId, name: client.selfName, at: now()});
  toast("Đang vào phòng...");
  goMatch();
}

function leaveRoom(){
  if (!client.roomCode) return;

  try{
    if (!client.isHost){
      sendToServer({type:"bye", roomCode: client.roomCode, fromId: client.selfId, at: now()});
    }
  }catch(e){}

  if (client.transport) client.transport.close();
  client.transport = null;
  client.isHost = false;
  client.host = null;
  client.authoritative = null;
  client.lastVersion = 0;
  client.selected = null;
  client.dragging = null;

  setStatusUI();
  setNetBadge("OFFLINE");
}

/* =========================================================
   12) Room: Firebase create/join
========================================================= */
async function createRoomAsHost_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  const roomNo = await fbAllocateRoomNo();
  const roomId = `room${roomNo}`;

  client.roomId = roomId.toLowerCase();
  client.roomCode = roomId.toUpperCase();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;

  client.isHost = true;
  client.host = new HostController(client.roomCode, FB.uid);
  client.host.addOrUpdatePlayer({ id: FB.uid, name: FB.username });

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.set({
    meta: {
      roomNo,
      roomId,
      hostUid: FB.uid,
      status: "active",
      createdAt: Date.now(),
      maxPlayers: 6,
      deckSource: null,
      deckBackUrl: "",
    },
    presence: {},
    users: {},
    intents: {},
    state: client.host.state,
  });

  await roomRef.child(`users/${FB.uid}`).set({ username: FB.username, seat: 0, atk: 0, def: 0, hp: 20 });

  client.authoritative = redactStateForViewer(client.host.state, FB.uid);
  client.lastVersion = client.authoritative.version;
  setStatusUI();

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);
  await t.attachPresence();

  t.listenIntentsAsHost(async (msg, intentKey)=>{
    const action = msg.action;
    const fromId = msg.fromUid;

    client.host.addOrUpdatePlayer({ id: fromId, name: msg.fromName });

    const r = client.host.applyIntent(fromId, action);
    if (!r.ok && fromId === FB.uid) toast("Action fail: " + r.reason);

    await t.writeState(client.host.state);

    try{ await FB.db.ref(`AllRoom/${client.roomId}/intents/${intentKey}`).remove(); }catch(e){}
  });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    if (client.isHost && client.host){
      client.host.state = st;
      client.authoritative = redactStateForViewer(st, FB.uid);
    } else {
      client.authoritative = redactStateForViewer(st, FB.uid);
    }
    client.lastVersion = st.version || client.lastVersion;
    setStatusUI();
  });

  toast(`Đã tạo room: ${roomId}`);
  client.roomMeta = { roomNo, roomId };

  installFirebaseRoomCleanupAsHost(client.roomId, roomNo);

  goMatch();
}

async function joinRoomAsClient_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  readInputs();
  client.roomId = client.roomCode.toLowerCase();
  if (!client.roomId.startsWith("room")) return toast("Nhập room dạng: room1 / ROOM1");

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  const metaSnap = await roomRef.child("meta").get();
  if (!metaSnap.exists()) return toast("Room không tồn tại / đã đóng");

  await roomRef.child(`users/${FB.uid}`).set({ username: FB.username, seat: -1, atk: 0, def: 0, hp: 20 });

  client.isHost = false;
  client.host = null;

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);
  await t.attachPresence();

  await t.sendIntent({ type: "join" });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    const red = redactStateForViewer(st, FB.uid);
    if (!red) return;
    client.authoritative = red;
    client.lastVersion = red.version || client.lastVersion;
    setStatusUI();
  });

  toast("Đã vào " + client.roomCode);
  goMatch();
}

function installFirebaseRoomCleanupAsHost(roomId, roomNo){
  const presRef = FB.db.ref(`AllRoom/${roomId}/presence`);
  presRef.on("value", async (snap)=>{
    if (!client.isHost) return;
    const v = snap.val() || {};
    const keys = Object.keys(v);
    if (keys.length === 0){
      try{ await FB.db.ref(`AllRoom/${roomId}`).remove(); }catch(e){}
      try{ await fbReleaseRoomNo(roomNo); }catch(e){}
    }
  });
}

/* =========================================================
   13) Deck/SetCard Modal (RTDB)
========================================================= */
const DECKUI = {
  modal: document.getElementById("deckModal"),
  openBtn: document.getElementById("openDeckBtn"),
  closeBtn: document.getElementById("closeDeckBtn"),
  userBadge: document.getElementById("deckUserBadge"),

  setSelect: document.getElementById("setSelect"),
  newSetBtn: document.getElementById("newSetBtn"),
  loadSetBtn: document.getElementById("loadSetBtn"),
  deleteSetBtn: document.getElementById("deleteSetBtn"),

  setNameInput: document.getElementById("setNameInput"),
  backUrlInput: document.getElementById("setBackUrlInput"),
  addCardBtn: document.getElementById("addCardUrlBtn"),
  list: document.getElementById("cardUrlList"),

  saveBtn: document.getElementById("saveSetBtn"),
  loadToRoomBtn: document.getElementById("loadSetToRoomBtn"),
};

let deckSetsCache = {};
let deckCurrentSetId = null;

function openDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "flex"; }
function closeDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "none"; }

function makeCardUrlRow(url=""){
  const row = document.createElement("div");
  row.className = "card-url-row";

  const inp = document.createElement("input");
  inp.className = "mono";
  inp.placeholder = "https://.../front.png";
  inp.value = url;

  const del = document.createElement("button");
  del.className = "danger";
  del.textContent = "X";
  del.onclick = ()=> row.remove();

  row.appendChild(inp);
  row.appendChild(del);
  return row;
}

function fillEditorFromSet(setId, data){
  deckCurrentSetId = setId;
  if (DECKUI.setNameInput) DECKUI.setNameInput.value = data?.name || "";
  if (DECKUI.backUrlInput) DECKUI.backUrlInput.value = data?.backUrl || "";
  if (!DECKUI.list) return;

  DECKUI.list.innerHTML = "";
  const cards = data?.cards ? Object.values(data.cards) : [];
  for (const c of cards){
    DECKUI.list.appendChild(makeCardUrlRow(c.frontUrl || ""));
  }
  if (cards.length === 0) DECKUI.list.appendChild(makeCardUrlRow(""));
}

function editorToSetData(){
  const name = (DECKUI.setNameInput?.value||"").trim() || "Untitled";
  const backUrl = (DECKUI.backUrlInput?.value||"").trim();
  const urls = [...(DECKUI.list?.querySelectorAll("input")||[])].map(i=>(i.value||"").trim()).filter(Boolean);

  const cards = {};
  urls.forEach((u, idx)=>{ cards["c"+(idx+1)] = { frontUrl: u }; });

  return { name, backUrl, cards, updatedAt: Date.now() };
}

async function refreshSetList(){
  await fbEnsureAuth();
  if (DECKUI.userBadge) DECKUI.userBadge.textContent = `UID: ${FB.uid.slice(0,6)}... | ${FB.username}`;

  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard`);
  const snap = await ref.get();
  deckSetsCache = snap.val() || {};

  if (!DECKUI.setSelect) return;

  DECKUI.setSelect.innerHTML = "";
  const ids = Object.keys(deckSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(chưa có set)";
    DECKUI.setSelect.appendChild(op);
    deckCurrentSetId = null;
    fillEditorFromSet(null, {name:"", backUrl:"", cards:{}});
    return;
  }

  for (const id of ids){
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${deckSetsCache[id]?.name || id} (${Object.keys(deckSetsCache[id]?.cards||{}).length})`;
    DECKUI.setSelect.appendChild(op);
  }

  const pick = (deckCurrentSetId && deckSetsCache[deckCurrentSetId]) ? deckCurrentSetId : ids[0];
  DECKUI.setSelect.value = pick;
  fillEditorFromSet(pick, deckSetsCache[pick]);
}

async function createNewSet(){
  await fbEnsureAuth();
  const newId = "set_" + uid().slice(0,8);
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${newId}`);
  await ref.set({ name:"New Set", backUrl:"", cards:{}, createdAt: Date.now(), updatedAt: Date.now() });
  await refreshSetList();
  if (DECKUI.setSelect) DECKUI.setSelect.value = newId;
  fillEditorFromSet(newId, deckSetsCache[newId]);
}

async function saveCurrentSet(){
  await fbEnsureAuth();
  if (!deckCurrentSetId) await createNewSet();
  const data = editorToSetData();
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${deckCurrentSetId}`);
  await ref.update(data);
  toast("Đã lưu set");
  await refreshSetList();
}

async function deleteCurrentSet(){
  await fbEnsureAuth();
  const id = DECKUI.setSelect?.value;
  if (!id) return;
  await FB.db.ref(`AllUser/${FB.uid}/setCard/${id}`).remove();
  toast("Đã xóa set");
  deckCurrentSetId = null;
  await refreshSetList();
}

async function loadSelectedSet(){
  const id = DECKUI.setSelect?.value;
  if (!id || !deckSetsCache[id]) return;
  fillEditorFromSet(id, deckSetsCache[id]);
  toast("Đã load set vào editor");
}

async function hostLoadSetToRoom(){
  if (!client.isHost) return toast("Chỉ host mới load set vào room");
  if (!(client.transport instanceof FirebaseTransport)) return toast("Chỉ dùng được trong Firebase mode");

  const id = deckCurrentSetId || DECKUI.setSelect?.value;
  if (!id) return toast("Chưa chọn set");

  // lấy từ editor là bản mới nhất
  const data = editorToSetData();

  // save set
  if (!deckCurrentSetId) await createNewSet();
  await saveCurrentSet();

  const urls = Object.values((data.cards||{})).map(x=>x.frontUrl).filter(Boolean);
  const backUrl = data.backUrl || "";

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.child("meta").update({ deckSource: { uid: FB.uid, setId: id }, deckBackUrl: backUrl });

  if (client.host && client.host.state){
    client.host.state.assets.backUrl = backUrl;
    client.host.state._deckPool = urls;
    client.host.bumpVersion();
    await client.transport.writeState(client.host.state);
  }

  toast(`Host loaded set (${urls.length} cards)`);
}

/* =========================================================
   14) Images cache
========================================================= */
const imgCache = new Map();
function loadImg(url){
  if (!url) return null;
  if (imgCache.has(url)) return imgCache.get(url);
  const im = new Image();
  im.src = url;
  imgCache.set(url, im);
  return im;
}

/* =========================================================
   15) Chat
========================================================= */
function renderChat(state){
  const items = state.chat || [];
  if (!UI.chatLog) return;

  UI.chatLog.innerHTML = items.map(m=>{
    const p = state.players.find(x=>x.id===m.fromId);
    const name = p ? p.name : "Unknown";
    const color = p ? COLORS[p.color] : "rgba(233,236,255,.35)";
    const time = new Date(m.at).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    return `
      <div class="msg">
        <div class="dot" style="background:${color}"></div>
        <div class="bubble">
          <div class="meta">
            <span style="font-weight:700;color:rgba(233,236,255,.86)">${escapeHtml(name)}</span>
            <span style="color:rgba(233,236,255,.45)">${time}</span>
          </div>
          <div class="text">${escapeHtml(m.text)}</div>
        </div>
      </div>
    `;
  }).join("");

  UI.chatLog.scrollTop = UI.chatLog.scrollHeight;
}

/* =========================================================
   16) Input / HitTest / Drag
========================================================= */
function mousePos(ev){
  const rect = canvas.getBoundingClientRect();
  return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
}

function cardZ(c){
  let z = 10;
  if (c.zone === ZONES.table) z = 50;
  if (c.zone === ZONES.hand) z = 80;
  if (c.zone === ZONES.deck) z = 40;
  if (c.zone === ZONES.discard) z = 45;
  return z + (c.order||0)*0.001;
}
function stackZ(s){
  let z = 12;
  if (s.zone === ZONES.table) z = 55;
  if (s.zone === ZONES.hand) z = 85;
  if (s.zone === ZONES.deck) z = 42;
  if (s.zone === ZONES.discard) z = 47;
  return z + (s.cardIds?.length||0)*0.01;
}

function listDrawableObjects(state){
  const out = [];
  if (!state) return out;

  for (const sid in state.stacks){
    const s = state.stacks[sid];
    if (!s) continue;
    out.push({type:"stack", id:sid, x:s.x, y:s.y, zone:s.zone, owner:s.owner, z: stackZ(s)});
  }
  for (const cid in state.cards){
    const c = state.cards[cid];
    if (!c || c.stackId) continue;
    out.push({type:"card", id:cid, x:c.x, y:c.y, zone:c.zone, owner:c.owner, z: cardZ(c)});
  }
  out.sort((a,b)=>a.z-b.z);
  return out;
}

function hitTest(worldX, worldY){
  const state = getState();
  if (!state) return null;

  const objs = listDrawableObjects(state);
  for (let i=objs.length-1; i>=0; i--){
    const o = objs[i];
    const w = CARD.w, h = CARD.h;
    const x0 = o.x - w/2, y0 = o.y - h/2;
    if (worldX >= x0 && worldX <= x0+w && worldY >= y0 && worldY <= y0+h){
      if (o.zone === ZONES.hand && o.owner && o.owner !== client.selfId) return null;
      return {type:o.type, id:o.id};
    }
  }
  return null;
}

function calcDragOffset(state, target, p){
  if (target.type === "card"){
    const c = state.cards[target.id];
    if (!c) return {dx:0,dy:0};
    return {dx: p.x - c.x, dy: p.y - c.y};
  } else {
    const s = state.stacks[target.id];
    if (!s) return {dx:0,dy:0};
    return {dx: p.x - s.x, dy: p.y - s.y};
  }
}

canvas.addEventListener("mousedown", (ev)=>{
  const st = getState();
  if (!st) return;

  const p = toWorld(mousePos(ev));
  const hit = hitTest(p.x, p.y);

  if (hit){
    client.selected = hit;
    updateInspector();
    client.dragging = { target: hit, start: p, offset: calcDragOffset(st, hit, p), moved:false };
  }else{
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
  }
});

addEventListener("mousemove", (ev)=>{
  if (!client.dragging) return;
  hideInspectorPopup();
  const st = getState();
  if (!st) return;
  const p = toWorld(mousePos(ev));
  client.dragging.moved = true;
  client.dragging.cur = p;
});

addEventListener("mouseup", (ev)=>{
  if (!client.dragging) return;

  const st = getState();
  const drag = client.dragging;
  client.dragging = null;
  if (!st) return;

  const p = toWorld(mousePos(ev));

  if (!drag.moved){
    showInspectorPopup();
    return;
  }

  const hit = hitTest(p.x, p.y);
  if (hit && !(hit.type===drag.target.type && hit.id===drag.target.id)){
    hideInspectorPopup();
    sendIntent({ type:"stack", dragTargetType: drag.target.type, dragId: drag.target.id, dropOnType: hit.type, dropOnId: hit.id });
    return;
  }

  hideInspectorPopup();
  sendIntent({
    type:"move",
    targetType: drag.target.type,
    id: drag.target.id,
    x: p.x - (drag.offset?.dx||0),
    y: p.y - (drag.offset?.dy||0),
  });
});

/* =========================================================
   17) Keyboard + Inspector buttons
========================================================= */
if (INS.btnFlip) INS.btnFlip.onclick = ()=>{
  if (!client.selected) return;
  sendIntent({type:"flip", targetType: client.selected.type, id: client.selected.id});
};
if (INS.btnDiscard) INS.btnDiscard.onclick = ()=>{
  if (!client.selected) return;
  sendIntent({type:"discard", targetType: client.selected.type, id: client.selected.id});
};
if (INS.btnUnstack) INS.btnUnstack.onclick = ()=>{
  const sel = client.selected;
  if (!sel || sel.type!=="stack") return;
  sendIntent({type:"unstack", stackId: sel.id});
};
if (INS.btnShuffle) INS.btnShuffle.onclick = ()=>{
  const sel = client.selected;
  if (sel?.type==="stack") sendIntent({type:"shuffle", stackId: sel.id});
  else sendIntent({type:"shuffle", stackId:"stack_deck"});
};

addEventListener("keydown", (ev)=>{
  if (ev.target && (ev.target.tagName==="INPUT" || ev.target.tagName==="TEXTAREA")) return;

  const st = getState();
  if (!st) return;

  const key = ev.key.toLowerCase();
  if (key === "escape"){
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
    return;
  }
  if (key === "d"){
    sendIntent({type:"draw"});
    toast("Draw 1");
    return;
  }
  if (key === "f"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"flip", targetType: sel.type, id: sel.id});
    return;
  }
  if (key === "s"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"shuffle", stackId: sel.id});
    else sendIntent({type:"shuffle", stackId:"stack_deck"});
    return;
  }
  if (key === "u"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"unstack", stackId: sel.id});
    return;
  }
  if (key === "x"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"discard", targetType: sel.type, id: sel.id});
    return;
  }
});

/* =========================================================
   18) Rendering helpers + main loop
========================================================= */
function rr(x,y,w,h,r){
  ctx.beginPath();
  const r2 = Math.min(r, w/2, h/2);
  ctx.moveTo(x+r2, y);
  ctx.arcTo(x+w, y, x+w, y+h, r2);
  ctx.arcTo(x+w, y+h, x, y+h, r2);
  ctx.arcTo(x, y+h, x, y, r2);
  ctx.arcTo(x, y, x+w, y, r2);
  ctx.closePath();
}

function drawZone(rect, label, subtitle="", highlight=false){
  const s0 = toScreen({x:rect.x, y:rect.y});
  const s1 = toScreen({x:rect.x+rect.w, y:rect.y+rect.h});
  const x = s0.x, y = s0.y, w = (s1.x-s0.x), h = (s1.y-s0.y);

  ctx.save();

  rr(x,y,w,h,18);
  ctx.globalAlpha = highlight ? 0.85 : 0.35;
  ctx.fillStyle = highlight ? "rgba(122,162,255,.22)" : "rgba(0,0,0,.10)";
  ctx.fill();

  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(233,236,255,.85)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText(label, x+12, y+18);

  if (subtitle){
    ctx.globalAlpha = 0.6;
    ctx.fillText(subtitle, x+12, y+34);
  }

  ctx.restore();
}

function drawCardAtScreen(
  cx, cy,
  faceUp,
  frontSeed,
  accent=null,
  isSelected=false,
  isStackTop=false,
  stackCount=0,
  frontUrl="",
  backUrl=""
){
  const w = CARD.w * camera.scale;
  const h = CARD.h * camera.scale;
  const x = cx - w/2, y = cy - h/2;
  const r = CARD.r * camera.scale;

  ctx.save();

  ctx.globalAlpha = 0.35;
  rr(x+4, y+6, w, h, r);
  ctx.fillStyle = "rgba(0,0,0,.65)";
  ctx.fill();
  ctx.globalAlpha = 1;

  rr(x, y, w, h, r);
  ctx.fillStyle = faceUp ? "rgba(255,255,255,.07)" : "rgba(0,0,0,.20)";
  ctx.fill();
  ctx.strokeStyle = isSelected ? "rgba(122,162,255,.85)" : "rgba(255,255,255,.14)";
  ctx.lineWidth = isSelected ? 2 : 1;
  ctx.stroke();

  if (accent){
    ctx.globalAlpha = 0.75;
    rr(x+8, y+8, w-16, 14*camera.scale, 9*camera.scale);
    ctx.fillStyle = accent;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  const url = faceUp ? (frontUrl || "") : (backUrl || "");
  const img = url ? loadImg(url) : null;

  if (img && img.complete && img.naturalWidth > 0){
    const padX = 6*camera.scale;
    const topPad = 28*camera.scale;
    const botPad = 10*camera.scale;
    rr(x+padX, y+topPad, w-2*padX, h-topPad-botPad, 10*camera.scale);
    ctx.clip();
    ctx.globalAlpha = 0.95;

    const iw = img.naturalWidth, ih = img.naturalHeight;
    const availW = w-2*padX;
    const availH = h-topPad-botPad;
    const scale = Math.min(availW/iw, availH/ih);
    const dw = iw*scale, dh = ih*scale;

    ctx.drawImage(img, x + (w-dw)/2, y + topPad + (availH-dh)/2, dw, dh);
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = "rgba(233,236,255,.9)";
    ctx.font = `${Math.max(10, 12*camera.scale)}px ui-monospace, monospace`;
    if (faceUp && frontSeed){
      const n = String(frontSeed).padStart(2,"0");
      ctx.fillText("CARD " + n, x + 12*camera.scale, y + 34*camera.scale);
    } else {
      ctx.fillText("BACK", x + 12*camera.scale, y + 34*camera.scale);
    }
  }

  if (isStackTop && stackCount>1){
    ctx.globalAlpha = 0.95;
    rr(x+w-34*camera.scale, y+10*camera.scale, 24*camera.scale, 18*camera.scale, 8*camera.scale);
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.stroke();
    ctx.fillStyle = "rgba(233,236,255,.86)";
    ctx.font = `${Math.max(10, 11*camera.scale)}px ui-monospace, monospace`;
    ctx.fillText(String(stackCount), x+w-28*camera.scale, y+24*camera.scale);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(0,0,0,.25)";
  ctx.fillRect(0,0,innerWidth,innerHeight);
  ctx.restore();

  const rects = zoneRects();
  const s = getState();
  if (!s){
    requestAnimationFrame(draw);
    return;
  }

  const seatName = (seat)=>{
    const p = s.players.find(pp=>pp.seat===seat);
    return p ? p.name : "(empty)";
  };

  drawZone(rects.table, "TABLE", "", false);

  const me = s.players.find(p=>p.id===client.selfId);
  const mySeat = me ? me.seat : -1;

  drawZone(rects.handTopLeft,     "Người chơi 1", seatName(0), mySeat===0);
  drawZone(rects.handTopRight,    "Người chơi 3", seatName(2), mySeat===2);
  drawZone(rects.handBottomLeft,  "Người chơi 2", seatName(1), mySeat===1);
  drawZone(rects.handBottomRight, "Người chơi 4", seatName(3), mySeat===3);
  drawZone(rects.handRightTop,    "Người chơi 5", seatName(4), mySeat===4);
  drawZone(rects.handRightBottom, "Người chơi 6", seatName(5), mySeat===5);

  drawZone(rects.deck, "DECK");
  drawZone(rects.discard, "DISCARD");

  const objs = listDrawableObjects(s);
  const backUrlDefault = s.assets?.backUrl || "";

  for (const o of objs){
    const isSelected = client.selected && client.selected.type === o.type && client.selected.id === o.id;

    let wx = o.x, wy = o.y;
    if (client.dragging &&
        client.dragging.target.type === o.type &&
        client.dragging.target.id === o.id &&
        client.dragging.cur){
      wx = client.dragging.cur.x - (client.dragging.offset?.dx||0);
      wy = client.dragging.cur.y - (client.dragging.offset?.dy||0);
    }

    const sp = toScreen({x: wx, y: wy});

    if (o.type === "card"){
      const c = s.cards[o.id];
      if (!c) continue;

      const owner = s.players.find(p=>p.id===c.owner);
      const accent = owner ? COLORS[owner.color] : null;

      const frontUrl = c.frontUrl || (s.assets?.frontBase ? (s.assets.frontBase + c.id + ".png") : "");
      drawCardAtScreen(sp.x, sp.y, !!c.faceUp, c.frontSeed, accent, isSelected, false, 0, frontUrl, backUrlDefault);
    } else {
      const stack = s.stacks[o.id];
      if (!stack) continue;

      const topId = stack.cardIds?.[0];
      const top = topId ? s.cards[topId] : null;

      const owner = s.players.find(p=>p.id===stack.owner);
      const accent = owner ? COLORS[owner.color] : null;

      if (top){
        const frontUrl = top.frontUrl || (s.assets?.frontBase ? (s.assets.frontBase + topId + ".png") : "");
        drawCardAtScreen(sp.x, sp.y, !!top.faceUp, top.frontSeed, accent, isSelected, true, stack.cardIds.length, frontUrl, backUrlDefault);

        if (stack.cardIds.length > 1){
          ctx.save();
          ctx.globalAlpha = 0.25;
          for (let i=1; i<Math.min(4, stack.cardIds.length); i++){
            const dx = i * 2 * camera.scale;
            const dy = i * 2 * camera.scale;
            drawCardAtScreen(sp.x+dx, sp.y+dy, false, 0, null, false, false, 0, "", backUrlDefault);
          }
          ctx.restore();
        }
      }
    }
  }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

/* =========================================================
   19) UI bindings (bind 1 lần)
========================================================= */
if (UI.modeSelect){
  UI.modeSelect.addEventListener("change", ()=>{
    if (UI.wsRow) UI.wsRow.style.display = (UI.modeSelect.value === "ws") ? "flex" : "none";
  });
}

if (UI.applyDeckBtn){
  UI.applyDeckBtn.addEventListener("click", ()=>{
    if (!client.isHost) return toast("Host mới set deck images");
    sendIntent({ type:"setAssets", frontBase: UI.frontBaseInput?.value, backUrl: UI.backUrlInput?.value });
    toast("Applied deck images");
  });
}

if (UI.createBtn){
  UI.createBtn.addEventListener("click", async ()=>{
    try{
      if (UI.modeSelect?.value === "firebase") await createRoomAsHost_Firebase();
      else createRoomAsHost_LocalOrWS();
    }catch(e){
      console.error(e);
      toast("Create error: " + (e.message || e));
    }
  });
}

if (UI.joinBtn){
  UI.joinBtn.addEventListener("click", async ()=>{
    try{
      if (UI.modeSelect?.value === "firebase") await joinRoomAsClient_Firebase();
      else joinRoomAsClient_LocalOrWS();
    }catch(e){
      console.error(e);
      toast("Join error: " + (e.message || e));
    }
  });
}

if (UI.resetBtn){
  UI.resetBtn.addEventListener("click", ()=>{
    if (!client.authoritative) return;
    if (!client.isHost) return toast("Chỉ Host mới reset.");
    sendIntent({type:"reset"});
  });
}

if (UI.copyLinkBtn){
  UI.copyLinkBtn.addEventListener("click", async ()=>{
    readInputs();
    const url = new URL(location.href);
    url.searchParams.set("room", client.roomCode);
    url.searchParams.set("mode", UI.modeSelect?.value || "local");
    if (UI.modeSelect?.value === "ws"){
      const ws = (UI.wsUrlInput?.value || "").trim();
      if (ws) url.searchParams.set("ws", ws);
    }
    try{
      await navigator.clipboard.writeText(url.toString());
      toast("Đã copy link phòng.");
    }catch(e){
      toast("Copy failed (trình duyệt chặn).");
    }
  });
}

document.querySelectorAll(".collapse-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const panelId = btn.dataset.target;
    const panel = document.getElementById(panelId);
    if (!panel) return;
    const collapsed = panel.classList.toggle("collapsed");
    btn.textContent = collapsed ? "+" : "−";
  });
});

/* =========================================================
   20) Auth UI buttons (login/register/anon/logout/leave)
   - bạn đã có các id: playAnonBtn, loginBtn, registerBtn, logoutBtn, leaveMatchBtn
========================================================= */
async function registerUser(){
  fbInitOnce();
  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";
  const username = (document.getElementById("authUsername")?.value || "").trim();

  if (!email || !password || !username){
    toast("Nhập đầy đủ email / mật khẩu / tên");
    return;
  }

  const cred = await FB.auth.createUserWithEmailAndPassword(email, password);
  const user = cred.user;

  await FB.db.ref(`AllUser/${user.uid}`).set({
    username,
    email,
    createdAt: Date.now(),
    setCard: {}
  });

  // sync runtime
  FB.user = user; FB.uid = user.uid; FB.username = username;
  if (UI.nameInput) UI.nameInput.value = username;

  toast("Đăng ký thành công");
  goLobby();
}

async function loginUser(){
  fbInitOnce();
  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";

  if (!email || !password){
    toast("Nhập email và mật khẩu");
    return;
  }

  await FB.auth.signInWithEmailAndPassword(email, password);

  // sau login, lấy username từ profile nếu có
  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  const snap = await FB.db.ref(`AllUser/${FB.uid}`).get();
  const prof = snap.val() || {};
  FB.username = (prof.username || "Player").slice(0,18);

  if (UI.nameInput) UI.nameInput.value = FB.username;

  toast("Đăng nhập thành công");
  goLobby();
}

const loginBtn = document.getElementById("loginBtn");
const registerBtn = document.getElementById("registerBtn");
const playAnonBtn = document.getElementById("playAnonBtn");
const logoutBtn = document.getElementById("logoutBtn");
const leaveMatchBtn = document.getElementById("leaveMatchBtn");

if (registerBtn){
  registerBtn.onclick = async ()=> {
    try{ await registerUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (loginBtn){
  loginBtn.onclick = async ()=> {
    try{ await loginUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (playAnonBtn){
  playAnonBtn.onclick = async ()=>{
    try{
      fbInitOnce();
      await FB.auth.signInAnonymously();
      FB.user = FB.auth.currentUser;
      FB.uid = FB.user.uid;

      const uname =
        ((document.getElementById("authUsername")?.value || "").trim().slice(0,18)) ||
        "Guest";
      FB.username = uname;

      const uref = FB.db.ref(`AllUser/${FB.uid}`);
      const snap = await uref.get();
      if (!snap.exists()){
        await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
      }else{
        await uref.update({ username: FB.username });
        const cur = snap.val() || {};
        if (!cur.setCard) await uref.update({ setCard:{} });
      }

      if (UI.nameInput) UI.nameInput.value = FB.username;

      goLobby();
      toast("Chơi thử: vào sảnh chờ");
    }catch(e){
      console.error(e);
      toast("Anonymous error: " + (e.message || e));
    }
  };
}
if (logoutBtn){
  logoutBtn.onclick = async ()=>{
    try{ if (FB?.auth?.currentUser) await FB.auth.signOut(); }catch(e){}
    try{ leaveRoom(); }catch(e){}
    goAuth();
    toast("Đã đăng xuất");
  };
}
if (leaveMatchBtn){
  leaveMatchBtn.onclick = ()=>{
    try{ leaveRoom(); }catch(e){}
    goLobby();
    toast("Đã rời phòng");
  };
}

/* =========================================================
   21) Deck modal binds
========================================================= */
if (DECKUI.openBtn){
  DECKUI.openBtn.onclick = async ()=>{
    try{
      await refreshSetList();
      openDeckModal();
    }catch(e){
      console.error(e);
      toast("Deck modal error: " + (e.message||e));
    }
  };
}
if (DECKUI.closeBtn) DECKUI.closeBtn.onclick = closeDeckModal;
if (DECKUI.newSetBtn) DECKUI.newSetBtn.onclick = createNewSet;
if (DECKUI.saveBtn) DECKUI.saveBtn.onclick = saveCurrentSet;
if (DECKUI.deleteSetBtn) DECKUI.deleteSetBtn.onclick = deleteCurrentSet;
if (DECKUI.loadSetBtn) DECKUI.loadSetBtn.onclick = loadSelectedSet;
if (DECKUI.addCardBtn) DECKUI.addCardBtn.onclick = ()=> DECKUI.list && DECKUI.list.appendChild(makeCardUrlRow(""));
if (DECKUI.loadToRoomBtn) DECKUI.loadToRoomBtn.onclick = hostLoadSetToRoom;

/* =========================================================
   22) Auto-fill URL params
========================================================= */
(function initFromQuery(){
  const u = new URL(location.href);
  const room = u.searchParams.get("room");
  const mode = u.searchParams.get("mode");
  const ws = u.searchParams.get("ws");
  if (room && UI.roomInput) UI.roomInput.value = room.toUpperCase();
  if (mode && UI.modeSelect && (mode==="local" || mode==="ws" || mode==="firebase")){
    UI.modeSelect.value = mode;
    if (UI.wsRow) UI.wsRow.style.display = mode === "ws" ? "flex" : "none";
  }
  if (ws && UI.wsUrlInput) UI.wsUrlInput.value = ws;
})();

addEventListener("beforeunload", ()=>{ try{ leaveRoom(); }catch(e){} });

window.addEventListener("error", (e) => {
  toast("JS error: " + (e.message || "unknown"));
});
window.addEventListener("unhandledrejection", (e) => {
  toast("Promise error: " + ((e.reason && e.reason.message) || e.reason || "unknown"));
});

/* =========================================================
   23) Boot
========================================================= */
goAuth();
setNetBadge("OFFLINE");

</script>
</body>
</html>
