<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Tabletop Card Sandbox (4P) ‚Äî Canvas + Realtime</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33cc;
      --panelSolid:#121a33;
      --border:#2a3566;
      --text:#e9ecff;
      --muted:#9aa6d6;
      --accent:#7aa2ff;
      --danger:#ff6b8b;
      --ok:#49d17c;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      background:
        radial-gradient(1200px 800px at 20% 10%, #18224b 0%, transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #1c2f66 0%, transparent 55%),
        radial-gradient(700px 600px at 50% 85%, #12214b 0%, transparent 50%),
        var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* Layout */
    #app{
      position:relative;
      width:100%;
      height:100%;
    }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      top:12px; left:12px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      z-index:10;
      pointer-events:auto; /* let canvas interactions through */
    }
    .panel{
      pointer-events:auto;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      min-width: 280px;
    }
    .panel header{
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .panel header .title{
      font-weight:700;
      letter-spacing:.2px;
      font-size:13px;
      color:var(--text);
    }
    .panel header .badge{
      font-size:11px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:4px 8px;
      background: rgba(0,0,0,.12);
    }
    .panel .content{
      padding:12px;
    }

    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .col{display:flex; flex-direction:column; gap:8px;}
    label{font-size:12px; color:var(--muted);}
    input,button,select{
      font-family:inherit;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:5px 10px;
      outline:none;
    }
    input::placeholder{color:rgba(233,236,255,.45)}
    button{
      cursor:pointer;
      border:1px solid rgba(122,162,255,.35);
      background: linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.08));
    }
    button:hover{border-color: rgba(122,162,255,.6)}
    button.secondary{
      border-color: rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
    }
    button.danger{
      border-color: rgba(255,107,139,.45);
      background: rgba(255,107,139,.12);
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    /* Chat */
    #chatPanel{
      position:absolute;
      right:14px;
      bottom:14px;
      width:min(420px, 42vw);
      height:min(320px, 42vh);
      z-index:20;
      display:flex;
      flex-direction:column;
      pointer-events:auto;
      border-radius:14px;
      overflow:hidden;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    
    #chatPanel.collapsed{
      height:44px !important;
    }
    
    #chatPanel header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px 8px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
    }
    
    #chatPanel .titleRow{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    
    #chatPanel .title{
      font-weight:800;
      letter-spacing:.08em;
      font-size:11px;
      opacity:.9;
    }
    
    #chatPanel .badge{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
    }
    
    #chatPanel .actions{
      display:flex;
      align-items:center;
      gap:6px;
    }
    
    .chatToggle{
      display:flex;
      gap:4px;
      padding:3px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .chatToggle button{
      border:0;
      background: transparent;
      color: rgba(233,236,255,.72);
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      cursor:pointer;
    }
    .chatToggle button.active{
      background: rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
    }
    
    #chatPanel .content{
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    
    #chatLog{
      flex:1;
      overflow:auto;
      padding:10px 10px 8px 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      scroll-behavior:smooth;
    }
    
    /* scrollbar subtle */
    #chatLog::-webkit-scrollbar{ width:10px; }
    #chatLog::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border:3px solid rgba(0,0,0,0);
      background-clip: padding-box;
      border-radius:999px;
    }

    
    #cardUrlList::-webkit-scrollbar{ width:10px; }
    #cardUrlList::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border:3px solid rgba(0,0,0,0);
      background-clip: padding-box;
      border-radius:999px;
    }
    
    /* Message row */
    .msg{
      display:flex;
      gap:8px;
      align-items:flex-start;
    }
    
    .msg .dot{
      width:10px; height:10px; border-radius:999px;
      margin-top:6px;
      flex:0 0 auto;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.18);
    }
    
    .msg .bubble{
      flex:1;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding:7px 9px;
      max-width:100%;
    }
    
    .msg .meta{
      display:flex;
      gap:8px;
      align-items:baseline;
      flex-wrap:wrap;
      margin-bottom:4px;
      font-size:11px;
      color: rgba(233,236,255,.62);
    }
    .msg .name{
      font-weight:700;
      color: rgba(255,255,255,.88);
    }
    .msg .time{
      opacity:.75;
      font-variant-numeric: tabular-nums;
    }
    
    .msg .text{
      font-size:13px;
      line-height:1.35;
      color: rgba(255,255,255,.92);
      white-space:pre-wrap;
      word-break:break-word;
    }
    
    /* Fade older messages a bit (LoL vibe) */
    .msg.age2 .bubble{ opacity:.92; }
    .msg.age3 .bubble{ opacity:.82; }
    .msg.age4 .bubble{ opacity:.70; }
    
    #chatForm{
      display:flex;
      gap:8px;
      padding:10px;
      border-top:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
    }
    
    #chatInput{
      flex:1;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:10px 12px;
      color: rgba(255,255,255,.92);
      outline:none;
    }
    #chatInput::placeholder{ color: rgba(233,236,255,.45); }
    
    #chatSend{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.9);
      padding:10px 14px;
      cursor:pointer;
    }
    #chatSend:hover{ background: rgba(255,255,255,.12); }
    
    /* Small */
    @media (max-width: 880px){
      #chatPanel{ width:min(360px, 60vw); height:min(280px, 40vh); }
    }


    /* Floating help */
    #help{
      position:absolute;
      left:12px;
      bottom:12px;
      z-index:10;
      width:min(520px, 56vw);
      pointer-events:auto;
    }
    #help .panel{pointer-events:auto}
    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      padding: 2px 6px;
      margin: 0 2px;
      border-radius: 7px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      font-size: 11px;
      color: rgba(233,236,255,.85);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,.22);
    }

    /* Toast */
    #toast{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      top:14px;
      z-index:20;
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(233,236,255,.92);
      box-shadow: var(--shadow);
      display:none;
      pointer-events:none;
      backdrop-filter: blur(8px);
      font-size: 12px;
    }

    /* Small */
    @media (max-width: 880px){
      #help{display:none;}
      #chatPanel{ width:min(360px, 60vw); height:min(280px, 40vh); }
      .hud{flex-direction:column;}
    }

     #inspector{
      position:absolute;
      z-index:30;
      display:none;
      pointer-events:auto;
      width: 280px;
      max-width: min(320px, 40vw);
    }
    
    #inspector .panel{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }


    .panel.collapsed .content {
      display: none;
    }
    
    .panel.collapsed {
      min-height: unset;
    }
    
    .collapse-btn {
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      color: #e9ecff;
      line-height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .collapse-btn:hover {
      background: rgba(122,162,255,.25);
    }

    .modal{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal-card{
      width: min(535px, 92vw);
      max-height: min(86vh, 780px);
      pointer-events: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      min-width: 280px;
      padding: 10px;
    }
    .card-url-row{
      display:flex; gap:5px; align-items:center;
    }


    /* Make HUD smaller + collapsible */
    .hud{ gap:10px; }
    .panel{ max-width: 360px; }
    
    /* Optional: minimize buttons row */
    .hud .panel header{ cursor:default; }
    
    .screen{ display:none; width:100%; height:100%; }
    .screen.active{ display:block; }
    #authScreen{align-items:flex-start; justify-content:center; }
    #matchScreen{ position:relative; width:100%; height:100%; }

    /* ===== Lobby Theme (LoL-like) ===== */
    /* ===== FULL SCREEN ROOT ===== */
    html, body{
      height: 100%;
      margin: 0;
    }
    #lobbyScreen.lobby{
      position: relative;
      width: 100vw;
      height: 100vh;              /* √©p ƒë√∫ng viewport */
      min-height: 100vh;
      overflow: hidden;
      color: #e7e2d8;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    
    /* ===== HUD = 3 PARTS (15% / 70% / 15%) FULL WIDTH ===== */
    #lobbyScreen .hud{
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 100vh;
    
      padding: 12px;
      box-sizing: border-box;
    
      display: grid;
      grid-template-rows: 15vh 1fr 15vh; /* TOP 15% | MID 70% | BOT 15% (an to√†n) */
      gap: 12px;
    }
    
    /* ===== Background layers (absolute, not affecting layout) ===== */
    #lobbyScreen .lobby-bg{
      position:absolute;
      inset:-40px;
      background:
        radial-gradient(1200px 600px at 20% 20%, rgba(199,166,101,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 30%, rgba(80,140,255,.10), transparent 55%),
        radial-gradient(900px 500px at 50% 90%, rgba(40,220,170,.08), transparent 60%),
        linear-gradient(180deg, #0b0f16, #070a10 60%, #05070c);
      filter: saturate(1.08);
      pointer-events:none;
    }
    #lobbyScreen .lobby-vignette{
      position:absolute; inset:0;
      background: radial-gradient(1200px 700px at 50% 10%, transparent 35%, rgba(0,0,0,.65) 80%);
      pointer-events:none;
    }
    #lobbyScreen .lobby-noise{
      position:absolute; inset:0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.25'/%3E%3C/svg%3E");
      mix-blend-mode: overlay;
      opacity: .08;
      pointer-events:none;
    }
    
    /* ===== TOPBAR: height 15% width 100% ===== */
    #lobbyScreen .lobby-topbar{
      width: 100%;
      height: 100%;        /* ƒë√∫ng h√†ng 15vh */
      max-width: none;     /* b·ªè gi·ªõi h·∫°n 1240 */
      margin: 0;
    
      padding: 0 6px;
    
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
    
      overflow: hidden;    /* tr√°nh ƒë·∫©y cao h√†ng */
    }
    
    /* brand */
    #lobbyScreen .brand{
      display:flex;
      align-items:center;
      gap: 12px;
    }
    #lobbyScreen .brand-logo{
      width: 42px; height: 42px;
      border-radius: 14px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,225,160,.9), rgba(199,166,101,.25) 45%, rgba(0,0,0,.0) 70%),
        linear-gradient(135deg, rgba(199,166,101,.35), rgba(120,170,255,.10));
      border: 1px solid rgba(199,166,101,.35);
      box-shadow: 0 10px 24px rgba(0,0,0,.45);
    }
    #lobbyScreen .brand-title{
      font-weight: 700;
      letter-spacing: .14em;
      font-size: 13px;
      color: #f3efe7;
    }
    #lobbyScreen .brand-sub{
      font-size: 12px;
      opacity: .75;
      margin-top: 2px;
    }
    
    /* top actions */
    #lobbyScreen .top-actions{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;   /* tr√°nh tr√†n */
    }
    
    #lobbyScreen .top-pill{
      display:flex; align-items:center; gap: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(10, 14, 22, .55);
      border: 1px solid rgba(199,166,101,.22);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    #lobbyScreen .top-pill .dot{
      width: 8px; height: 8px; border-radius: 999px;
      background: #a64b4b;
      box-shadow: 0 0 0 3px rgba(166,75,75,.15);
    }
    #lobbyScreen .top-pill.online .dot{
      background: #42d392;
      box-shadow: 0 0 0 3px rgba(66,211,146,.18);
    }
    #lobbyScreen .top-pill .txt{ font-size: 12px; letter-spacing:.04em; opacity:.9; }
    
    #lobbyScreen .icon-btn{
      position: relative;
      height: 38px; width: 38px;
      border-radius: 12px;
      border: 1px solid rgba(199,166,101,.22);
      background: rgba(10, 14, 22, .55);
      color: #f3efe7;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      cursor: pointer;
    }
    #lobbyScreen .icon-btn:hover{
      border-color: rgba(199,166,101,.45);
      transform: translateY(-1px);
    }
    #lobbyScreen .icon-btn .bubble{
      position:absolute; top:-6px; right:-6px;
      background: rgba(199,166,101,.95);
      color:#15110b;
      font-weight: 700;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: 11px;
      border: 1px solid rgba(255,255,255,.25);
    }
    #lobbyScreen .top-logout{ height: 38px; border-radius: 12px; }
    
    /* ===== MIDDLE: height 70% width 100% / columns 20% + 80% ===== */
    #lobbyScreen .lobby-shell{
      width: 100%;
      height: 100%;            /* ƒë√∫ng h√†ng gi·ªØa (1fr ~ 70vh) */
      max-width: none;         /* b·ªè 1240 */
      margin: 0;
    
      padding: 0 6px;
    
      display:grid;
      grid-template-columns: 20% 80%;
      gap: 14px;
      align-items: stretch;
    
      min-height: 0;           /* c·ª±c quan tr·ªçng cho scroll n·ªôi b·ªô */
    }
    
    /* sidebar */
    #lobbyScreen .lobby-sidebar{
      background: rgba(8, 11, 18, .55);
      border: 1px solid rgba(199,166,101,.20);
      border-radius: 18px;
      box-shadow: 0 18px 44px rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      padding: 10px;
      display:flex;
      flex-direction: column;
      gap: 8px;
    
      height: 100%;
      min-height: 0;
      overflow: auto;          /* scroll trong sidebar n·∫øu d√†i */
    }
    
    /* main */
    #lobbyScreen .lobby-main{
      display:flex;
      flex-direction: column;
      gap: 12px;
    
      height: 100%;
      min-height: 0;
      overflow: auto;          /* scroll trong main n·∫øu d√†i */
    }
    #lobbyScreen .tab{ display:none; }
    #lobbyScreen .tab.active{ display:block; }
    
    /* nav item */
    #lobbyScreen .nav-item{
      display:flex; align-items:center; gap: 10px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid transparent;
      background: transparent;
      color: rgba(231,226,216,.88);
      cursor: pointer;
      text-align:left;
    }
    #lobbyScreen .nav-item:hover{
      background: rgba(199,166,101,.10);
      border-color: rgba(199,166,101,.22);
    }
    #lobbyScreen .nav-item.active{
      background: rgba(199,166,101,.14);
      border-color: rgba(199,166,101,.40);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    #lobbyScreen .nav-ico{ width: 22px; text-align:center; opacity:.95; }
    #lobbyScreen .nav-txt{ font-size: 13px; letter-spacing:.02em; }
    
    #lobbyScreen .sidebar-divider{
      height: 1px;
      margin: 6px 6px;
      background: linear-gradient(90deg, transparent, rgba(199,166,101,.25), transparent);
    }
    #lobbyScreen .sidebar-footer{
      margin-top:auto;
      padding: 10px 10px 2px;
      opacity:.65;
      font-size: 12px;
    }
    
    /* ===== DOCK: height 15% width 100% ===== */
    #lobbyScreen .lobby-dock{
      width: 100%;
      height: 100%;            /* ƒë√∫ng h√†ng 15vh */
      max-width: none;
      margin: 0;
    
      padding: 10px 12px;
      box-sizing: border-box;
    
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
    
      border-radius: 18px;
      border: 1px solid rgba(199,166,101,.20);
      background: rgba(8, 11, 18, .55);
      box-shadow: 0 18px 44px rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
    
      overflow: hidden;        /* tr√°nh dock l√†m cao h∆°n 15vh */
    }
    
    #lobbyScreen .dock-left,
    #lobbyScreen .dock-right{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
    }
    #lobbyScreen .dock-mid{
      flex:1;
      display:flex;
      justify-content:center;
      min-width: 220px;
    }
    #lobbyScreen .dock-pill{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(199,166,101,.18);
      background: rgba(0,0,0,.18);
      max-width: 520px;
      width: 100%;
      overflow:hidden;
    }
    #lobbyScreen .dock-pill .dot{
      width: 8px; height: 8px; border-radius: 999px;
      background: rgba(199,166,101,.90);
      box-shadow: 0 0 0 3px rgba(199,166,101,.14);
      flex: 0 0 auto;
    }
    #lobbyScreen .dock-pill .txt{
      font-size: 12px;
      opacity:.85;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    
    /* ===== Panels / Inputs / Buttons (gi·ªØ style c≈©) ===== */
    #lobbyScreen .panel{
      background: rgba(8, 11, 18, .55) !important;
      border: 1px solid rgba(199,166,101,.20) !important;
      border-radius: 18px !important;
      box-shadow: 0 18px 44px rgba(0,0,0,.45) !important;
      backdrop-filter: blur(12px);
      overflow:hidden;
    }
    #lobbyScreen .panel header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(199,166,101,.14);
      background: linear-gradient(180deg, rgba(199,166,101,.10), rgba(0,0,0,0));
    }
    #lobbyScreen .panel header .title{
      font-weight: 800;
      letter-spacing: .12em;
      font-size: 12px;
      color: rgba(243,239,231,.95);
    }
    #lobbyScreen .panel .content{ padding: 12px 14px; }
    #lobbyScreen .panel .hint{ opacity:.75; font-size: 12px; }
    
    #lobbyScreen .panel.soft header.soft-header{ display:block; }
    #lobbyScreen .soft-header .title{ font-size: 12px; letter-spacing:.14em; }
    #lobbyScreen .soft-header .sub{ margin-top: 4px; font-size: 12px; opacity:.72; }
    
    #lobbyScreen input, #lobbyScreen select{
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(199,166,101,.18);
      border-radius: 12px;
      color: rgba(243,239,231,.92);
      padding: 10px 10px;
      outline: none;
    }
    #lobbyScreen input:focus, #lobbyScreen select:focus{
      border-color: rgba(199,166,101,.45);
      box-shadow: 0 0 0 3px rgba(199,166,101,.12);
    }
    
    #lobbyScreen button{
      border-radius: 12px;
      border: 1px solid rgba(199,166,101,.25);
      background: rgba(199,166,101,.18);
      color: rgba(243,239,231,.95);
      padding: 10px 12px;
      cursor:pointer;
    }
    #lobbyScreen button.secondary{
      background: rgba(10,14,22,.35);
      border-color: rgba(199,166,101,.20);
    }
    #lobbyScreen button.danger{
      background: rgba(166,75,75,.20);
      border-color: rgba(166,75,75,.35);
    }
    #lobbyScreen button:hover{
      border-color: rgba(199,166,101,.45);
      transform: translateY(-1px);
    }
    #lobbyScreen button:active{
      transform: translateY(0);
    }
    
    /* grids */
    #lobbyScreen .grid-2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    
    /* mini panels */
    #lobbyScreen .panel.mini{ border-radius: 16px !important; }
    #lobbyScreen .mini-header{ padding: 10px 12px !important; }
    #lobbyScreen .mini-header .title{
      font-weight: 800;
      letter-spacing:.08em;
      font-size: 12px;
    }
    #lobbyScreen .mini-header .sub{ font-size: 12px; opacity:.7; margin-top: 2px; }
    #lobbyScreen .mono-note{ opacity:.75; font-size: 12px; }
    
    /* shop */
    #lobbyScreen .shop-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    #lobbyScreen .shop-card{
      border-radius: 16px;
      border: 1px solid rgba(199,166,101,.18);
      background: rgba(0,0,0,.18);
      padding: 12px;
    }
    #lobbyScreen .shop-img{
      height: 90px;
      border-radius: 14px;
      border: 1px solid rgba(199,166,101,.20);
      background:
        radial-gradient(circle at 30% 30%, rgba(199,166,101,.35), transparent 55%),
        linear-gradient(135deg, rgba(70,120,255,.12), rgba(0,0,0,.0));
      margin-bottom: 10px;
    }
    #lobbyScreen .shop-img.alt{
      background:
        radial-gradient(circle at 30% 30%, rgba(120,220,190,.28), transparent 55%),
        linear-gradient(135deg, rgba(199,166,101,.10), rgba(0,0,0,.0));
    }
    #lobbyScreen .shop-img.alt2{
      background:
        radial-gradient(circle at 30% 30%, rgba(240,120,120,.25), transparent 55%),
        linear-gradient(135deg, rgba(199,166,101,.10), rgba(0,0,0,.0));
    }
    #lobbyScreen .shop-title{ font-weight: 800; letter-spacing:.04em; }
    #lobbyScreen .shop-sub{ opacity:.7; font-size: 12px; margin-top: 2px; }
    #lobbyScreen .shop-row{ display:flex; align-items:center; justify-content:space-between; gap: 8px; margin-top: 10px; }
    #lobbyScreen .price{ font-weight: 900; letter-spacing:.06em; color: rgba(199,166,101,.95); }
    
    /* notifications */
    #lobbyScreen .notif-item{
      display:flex; gap: 10px; align-items:flex-start;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(199,166,101,.18);
      background: rgba(0,0,0,.16);
    }
    #lobbyScreen .notif-dot{
      width: 10px; height: 10px; border-radius: 999px;
      margin-top: 4px;
      background: rgba(199,166,101,.85);
    }
    #lobbyScreen .notif-dot.warn{ background: rgba(240,120,120,.85); }
    #lobbyScreen .notif-title{ font-weight: 800; }
    #lobbyScreen .notif-sub{ opacity:.75; font-size: 12px; margin-top: 2px; }
    
    /* quick play */
    #lobbyScreen .quick-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    #lobbyScreen .quick-card{
      text-align:left;
      padding: 14px;
      border-radius: 16px;
      border: 1px solid rgba(199,166,101,.20);
      background: rgba(0,0,0,.16);
    }
    #lobbyScreen .q-title{ font-weight: 900; letter-spacing:.06em; }
    #lobbyScreen .q-sub{ opacity:.72; font-size: 12px; margin-top: 2px; }
    
    /* tutorial */
    #lobbyScreen .tutorial-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    #lobbyScreen .tut-card{
      border-radius: 16px;
      border: 1px solid rgba(199,166,101,.18);
      background: rgba(0,0,0,.14);
      padding: 12px;
    }
    #lobbyScreen .tut-title{ font-weight: 900; }
    #lobbyScreen .tut-sub{ opacity:.72; font-size: 12px; margin-top: 2px; }
    
    /* patch */
    #lobbyScreen .patch{ margin: 0; padding-left: 18px; }
    #lobbyScreen .patch li{ margin: 8px 0; opacity:.9; }
    #lobbyScreen .tag{
      display:inline-block;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      margin-right: 8px;
      border: 1px solid rgba(199,166,101,.25);
      background: rgba(199,166,101,.12);
    }
    #lobbyScreen .tag.new{ border-color: rgba(120,220,190,.35); background: rgba(120,220,190,.12); }
    #lobbyScreen .tag.imp{ border-color: rgba(199,166,101,.40); background: rgba(199,166,101,.16); }
    #lobbyScreen .tag.todo{ border-color: rgba(240,120,120,.35); background: rgba(240,120,120,.10); }
    
    /* hide duplicate logout in room panel (keep your choice) */
    #roomPanel #logoutBtn{ display:none; }
    
    /* roomPanel row nav-item override */
    #roomPanel .row .nav-item{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(199,166,101,.20);
      background: rgba(10,14,22,.35);
    }
    #roomPanel .row .nav-item .nav-txt{ font-size: 12px; }
    
    /* room browser list */
    #lobbyScreen .rb-list{
      display:flex;
      flex-direction:column;
      gap: 10px;
      margin-top: 6px;
    }
    #lobbyScreen .rb-card{
      display:flex;
      gap: 12px;
      align-items:stretch;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(199,166,101,.18);
      background: rgba(0,0,0,.14);
    }
    #lobbyScreen .rb-emblem{
      width: 54px;
      border-radius: 14px;
      border: 1px solid rgba(199,166,101,.22);
      background:
        radial-gradient(circle at 30% 30%, rgba(199,166,101,.28), transparent 55%),
        linear-gradient(135deg, rgba(70,120,255,.10), rgba(0,0,0,0));
      flex: 0 0 54px;
    }
    #lobbyScreen .rb-main{ flex:1; min-width: 240px; }
    #lobbyScreen .rb-top{ display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    #lobbyScreen .rb-name{ font-weight: 900; letter-spacing:.04em; }
    #lobbyScreen .rb-meta{ opacity:.72; font-size: 12px; margin-top: 2px; }
    #lobbyScreen .rb-tags{ display:flex; gap: 6px; flex-wrap:wrap; margin-top: 8px; }
    #lobbyScreen .rb-chip{
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(199,166,101,.20);
      background: rgba(199,166,101,.10);
      opacity: .92;
    }
    #lobbyScreen .rb-side{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      justify-content:space-between;
      gap: 8px;
      min-width: 160px;
    }
    #lobbyScreen .rb-stats{
      display:flex;
      gap: 10px;
      opacity:.8;
      font-size: 12px;
    }
    #lobbyScreen .rb-stat b{ opacity: 1; color: rgba(199,166,101,.95); }
    #lobbyScreen .rb-actions{ display:flex; gap: 8px; }
    #lobbyScreen .rb-join{ min-width: 86px; }
    
    /* ===== Responsive (mobile): still full width ===== */
    @media (max-width: 1100px){
      #lobbyScreen .shop-grid{ grid-template-columns: 1fr; }
    }
    @media (max-width: 980px){
      #lobbyScreen .quick-grid{ grid-template-columns: 1fr; }
      #lobbyScreen .tutorial-grid{ grid-template-columns: 1fr; }
    }
    @media (max-width: 920px){
      /* middle becomes 1 column */
      #lobbyScreen .lobby-shell{
        grid-template-columns: 1fr;
      }
    
      /* dock stack */
      #lobbyScreen .lobby-dock{
        flex-direction: column;
        align-items: stretch;
      }
      #lobbyScreen .dock-mid{
        width:100%;
      }
      /* grid-2 to single col */
      #lobbyScreen .grid-2{
        grid-template-columns: 1fr;
      }
    }

    
    /* Status board (LoL-ish compact) */
    #statusBoard{
      position:absolute;
      right:12px;
      top:12px;
      z-index:30;

      overflow:hidden;
      pointer-events:auto;
      
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,.92);
      font-family: system-ui, sans-serif;
      font-size: 12px;
    }
    
    #statusBoard.collapsed{
      height: 40px;
    }
    
    #statusBoard header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
    }
    
    #statusBoard .title{
      font-weight:800;
      letter-spacing:.06em;
      font-size:11px;
      opacity:.9;
      user-select:none;
      margin-right: 10px;
    }
    
    #statusBoard .right{
      display:flex;
      align-items:center;
      gap:8px;
    }
    
    #statusBoard .hint{
      font-size:11px;
      opacity:.65;
      user-select:none;
    }
    
    #statusBoard .body{
      padding: 8px;
    }
    
    #statusBoard.collapsed .body{
      display:none;
    }
    
    #statusBoard table{
      width:100%;
      border-collapse:collapse;
    }
    
    #statusBoard th, #statusBoard td{
      padding: 6px 4px;
      border-top: 1px solid rgba(255,255,255,.08);
      text-align:center;
    }
    
    #statusBoard th:first-child,
    #statusBoard td:first-child{
      text-align:left;
      padding-left: 6px;
    }
    
    #statusBoard thead th{
      border-top:none;
      padding-top: 2px;
    }
    
    .sbName{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .sbDot{
      width:10px; height:10px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.18);
      flex:0 0 auto;
    }
    .sbNameText{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:600;
      opacity:.92;
    }
    
    .sbInp{
      width: 64px;
      max-width: 64px;
      text-align:center;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 6px 6px;
      outline:none;
    }
    
    .sbHdr{
      font-weight:700;
      letter-spacing:.04em;
      font-size:11px;
    }
    
    .sbHdrInp{
      width: 64px;
      max-width: 64px;
      text-align:center;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      padding: 6px 6px;
      outline:none;
    }
    .sbHdrInp[readonly]{
      opacity:.75;
      cursor: default;
    }

  </style>
</head>
<body>
<!-- =========================
  SCREEN: AUTH (m·∫∑c ƒë·ªãnh hi·ªán)
========================= -->
<div id="authScreen" class="screen active" style="margin-top: 25vh;">
  <!-- ƒêƒÉng nh·∫≠p / ƒêƒÉng k√Ω -->
  <div class="panel" id="authPanel" style="width:380px; margin:40px auto;">
    <header>
      <div class="title">ƒêƒÇNG NH·∫¨P</div>
    </header>
    <div class="content col">
      <input id="authEmail" placeholder="Email" />
      <input id="authPassword" type="password" placeholder="M·∫≠t kh·∫©u" />
      <input id="authUsername" placeholder="T√™n hi·ªÉn th·ªã (khi ƒëƒÉng k√Ω)" />

      <div class="row" style="display: flex;justify-content: center;">
        <button id="loginBtn">ƒêƒÉng nh·∫≠p</button>
        <button id="registerBtn" class="secondary">ƒêƒÉng k√Ω</button>
        <button id="playAnonBtn" class="secondary" style="flex:1">Ch∆°i th·ª≠</button>
      </div>
      <div id="authStatus" style="font-size:12px;color:var(--muted)"></div>
    </div>
  </div>
</div>


<!-- =========================
  SCREEN: LOBBY (·∫©n ban ƒë·∫ßu)
  D√πng l·∫°i roomPanel l√†m "S·∫£nh ch·ªù"
  (Kh√¥ng ƒë·ªïi id roomPanel ƒë·ªÉ JS/CSS kh·ªèi v·ª°)
========================= -->
<div id="lobbyScreen" class="screen lobby">
  <!-- Background layers -->
  <div class="lobby-bg"></div>
  <div class="lobby-vignette"></div>
  <div class="lobby-noise"></div>

  <div class="hud">
    <!-- Top bar -->
    <div class="lobby-topbar">
      <div class="brand">
        <div class="brand-logo"></div>
        <div class="brand-text">
          <div class="brand-title">CARD ARENA</div>
          <div class="brand-sub">Sandbox Tabletop ‚Ä¢ 4 Players</div>
        </div>
      </div>

      <div class="top-actions">
        <div class="top-pill" id="netPill">
          <span class="dot" id="netDot"></span>
          <span class="txt" id="netTxt">OFFLINE</span>
          <!-- gi·ªØ nguy√™n badge g·ªëc -->
          <div class="badge" id="netBadge" style="display:none">OFFLINE</div>
        </div>

        <button class="icon-btn" data-tab="tabNotifications" title="Th√¥ng b√°o">
          <span class="ico">üîî</span>
          <span class="bubble" id="notifBubble" style="display:none">1</span>
        </button>
        <button class="icon-btn" data-tab="tabShop" title="C·ª≠a h√†ng">
          <span class="ico">üõí</span>
        </button>

        <!-- gi·ªØ nguy√™n n√∫t logout c·ªßa b·∫°n (id=logoutBtn) nh∆∞ng ‚Äúƒë·∫∑t l√™n top bar‚Äù -->
        <button id="logoutBtn" class="danger top-logout">ƒêƒÉng xu·∫•t</button>
      </div>
    </div>

    <div class="lobby-shell">
      <!-- Sidebar navigation -->
      <aside class="lobby-sidebar">
        <button class="nav-item active" data-tab="tabRoom">
          <span class="nav-ico">üè†</span><span class="nav-txt">T·∫°o / T√¨m ph√≤ng</span>
        </button>
        <button class="nav-item" data-tab="tabCustomize">
          <span class="nav-ico">üéõÔ∏è</span><span class="nav-txt">T√πy ch·ªânh</span>
        </button>
        <button class="nav-item" data-tab="tabInventory">
          <span class="nav-ico">üß∞</span><span class="nav-txt">T·ªß ƒë·ªì</span>
        </button>
        <button class="nav-item" data-tab="tabShop">
          <span class="nav-ico">üõí</span><span class="nav-txt">C·ª≠a h√†ng</span>
        </button>
        <button class="nav-item" data-tab="tabNotifications">
          <span class="nav-ico">üîî</span><span class="nav-txt">Th√¥ng b√°o</span>
        </button>

        <div class="sidebar-divider"></div>

        <!-- M·ª•c s√°ng t·∫°o th√™m -->
        <button class="nav-item" data-tab="tabQuickPlay">
          <span class="nav-ico">‚ö°</span><span class="nav-txt">Quick Play</span>
        </button>
        <button class="nav-item" data-tab="tabTutorial">
          <span class="nav-ico">üìò</span><span class="nav-txt">H∆∞·ªõng d·∫´n</span>
        </button>
        <button class="nav-item" data-tab="tabPatchNotes">
          <span class="nav-ico">üßæ</span><span class="nav-txt">Patch notes</span>
        </button>

        <div class="sidebar-footer">
          <div class="small">v0.1 ‚Ä¢ Host authoritative</div>
        </div>
      </aside>

      <!-- Main content -->
      <main class="lobby-main">
        <!-- TAB: Room -->
        <section class="tab active" id="tabRoom">
          <!-- GI·ªÆ NGUY√äN roomPanel c·ªßa b·∫°n -->
          <div class="panel collapsible" id="roomPanel">
            <header>
              <div class="title">PH√íNG CH∆†I</div>
              <div class="row" style="gap:8px">
                <!-- netBadge ƒë√£ ƒë∆∞·ª£c ƒë∆∞a l√™n topbar, ·ªü ƒë√¢y c√≥ th·ªÉ gi·ªØ l·∫°i/·∫©n ƒëi -->
                <div class="badge" id="netBadge">OFFLINE</div>
              </div>
              <button class="collapse-btn" data-target="roomPanel">‚àí</button>
            </header>

            <!-- N√∫t Deck / SetCard v·∫´n gi·ªØ nguy√™n id, nh∆∞ng ·ªü tab Inventory s·∫Ω d√πng l·∫°i UI -->
            <button id="openDeckBtn" class="secondary">Deck / SetCard</button>

            <div class="content col">
              <div class="col">
                <div class="row">
                  <div class="col" style="flex:1; min-width:150px">
                    <label>T√™n hi·ªÉn th·ªã</label>
                    <input id="nameInput" placeholder="VD: HIC / Player" maxlength="18" />
                  </div>
                  <div class="col" style="min-width:120px">
                    <label>Ch·∫ø ƒë·ªô</label>
                    <select id="modeSelect">
                      <option value="firebase">Firebase RTDB</option>
                      <option value="local">Local (4 tab)</option>
                      <option value="ws">WebSocket</option>
                    </select>
                  </div>
                </div>

                <div id="wsRow" class="row" style="display:none">
                  <div class="col" style="flex:1; min-width:200px">
                    <label>WebSocket URL</label>
                    <input id="wsUrlInput" class="mono" placeholder="ws://localhost:8080" />
                  </div>
                </div>

                <div class="row">
                  <div class="col" style="flex:1; min-width:160px">
                    <label>M√£ ph√≤ng</label>
                    <input id="roomInput" class="mono" placeholder="T·ª± t·∫°o / nh·∫≠p" />
                  </div>
                  <button id="createBtn">T·∫°o ph√≤ng (Host)</button>
                  <button id="joinBtn" class="secondary">V√†o ph√≤ng</button>
                  <button class="nav-item" data-tab="tabRoomBrowser">
                    <span class="nav-ico">üåê</span><span class="nav-txt">Room Browser</span>
                  </button>
                </div>

                <div class="row">
                  <button id="copyLinkBtn" class="secondary">Copy link</button>
                  <button id="resetBtn" class="danger">Reset b√†n (Host)</button>
                  <!-- logoutBtn ƒë√£ ƒë·∫∑t l√™n topbar, c√≥ th·ªÉ gi·ªØ ·ªü ƒë√¢y n·∫øu b·∫°n mu·ªën (ho·∫∑c ·∫©n b·∫±ng CSS) -->
                  <button id="logoutBtn" class="danger" style="margin-left:auto">ƒêƒÉng xu·∫•t</button>
                </div>

                <div class="hint">
                  - Local mode: m·ªü 4 tab, c√πng m√£ ph√≤ng ƒë·ªÉ test 4 ng∆∞·ªùi.<br/>
                  - Server authoritative: Host gi·ªØ state, client ch·ªâ g·ª≠i intent.
                </div>
              </div>
            </div>
          </div>

          <!-- ‚ÄúT√¨m ph√≤ng nhanh‚Äù (s√°ng t·∫°o) -->
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">T√åM PH√íNG NHANH</div>
              <div class="sub">G·ª£i √Ω cho ng∆∞·ªùi ch∆°i m·ªõi: join theo m√£ ho·∫∑c link</div>
            </header>
            <div class="content">
              <div class="row">
                <input class="mono" id="quickRoomSearch" placeholder="Nh·∫≠p m√£ ph√≤ng ƒë·ªÉ highlight + paste nhanh..." />
                <button class="secondary" id="pasteRoomBtn">Paste</button>
                <button id="focusRoomBtn">Focus</button>
              </div>
              <div class="hint">M·∫πo: ‚ÄúCopy link‚Äù s·∫Ω t·ª± k√®m m√£ ph√≤ng ƒë·ªÉ b·∫°n share cho b·∫°n b√®.</div>
            </div>
          </div>
        </section>
        <section class="tab" id="tabRoomBrowser">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">ROOM BROWSER</div>
              <div class="sub">T√¨m ph√≤ng c√¥ng khai theo tag / preset / mode</div>
            </header>
        
            <div class="content col">
              <div class="grid-2">
                <div class="field">
                  <label>T·ª´ kh√≥a</label>
                  <input id="rbQuery" placeholder="VD: draft, poker, hic..." />
                </div>
        
                <div class="field">
                  <label>Tag</label>
                  <input id="rbTag" placeholder="VD: casual, ranked, test..." />
                </div>
        
                <div class="field">
                  <label>Ch·∫ø ƒë·ªô</label>
                  <select id="rbMode">
                    <option value="">All</option>
                    <option value="firebase">Firebase RTDB</option>
                    <option value="ws">WebSocket</option>
                    <option value="local">Local</option>
                  </select>
                </div>
        
                <div class="field">
                  <label>Preset</label>
                  <input id="rbPreset" placeholder="VD: Draft 60 / Poker 52..." />
                </div>
        
                <div class="field">
                  <label>S·∫Øp x·∫øp</label>
                  <select id="rbSort">
                    <option value="pop">Ph·ªï bi·∫øn</option>
                    <option value="new">M·ªõi nh·∫•t</option>
                    <option value="players">Nhi·ªÅu ng∆∞·ªùi</option>
                    <option value="ping">Ping th·∫•p</option>
                  </select>
                </div>
        
                <div class="field">
                  <label>Ch·ªâ hi·ªÉn th·ªã ph√≤ng c√≤n ch·ªó</label>
                  <label class="chk" style="margin-top:8px">
                    <input type="checkbox" id="rbOnlyOpen" checked />
                    <span>Open slots</span>
                  </label>
                </div>
              </div>
        
              <div class="row" style="justify-content:space-between; gap:10px; flex-wrap:wrap">
                <div class="hint" id="rbStatus">‚Äî</div>
                <div class="row" style="gap:10px">
                  <button class="secondary" id="rbRefreshBtn">Refresh</button>
                  <button id="rbAutoBtn" class="secondary">Auto: ON</button>
                </div>
              </div>
        
              <div class="rb-list" id="rbList"></div>
            </div>
          </div>
        </section>


        <!-- TAB: Customize -->
        <section class="tab" id="tabCustomize">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">T√ôY CH·ªàNH</div>
              <div class="sub">C√° nh√¢n h√≥a tr·∫£i nghi·ªám s·∫£nh & b√†n ch∆°i</div>
            </header>

            <div class="content col">
              <div class="grid-2">
                <div class="field">
                  <label>Theme</label>
                  <select id="uiThemeSelect">
                    <option value="gold">Gold Noir (LoL-like)</option>
                    <option value="emerald">Emerald</option>
                    <option value="crimson">Crimson</option>
                    <option value="ice">Ice</option>
                  </select>
                </div>

                <div class="field">
                  <label>Lobby motion</label>
                  <select id="uiMotionSelect">
                    <option value="full">Full</option>
                    <option value="reduced">Reduced</option>
                    <option value="off">Off</option>
                  </select>
                </div>

                <div class="field">
                  <label>Sound</label>
                  <div class="row">
                    <input type="range" id="uiSfx" min="0" max="100" value="40" />
                    <span class="mono" id="uiSfxTxt">40%</span>
                  </div>
                </div>

                <div class="field">
                  <label>FPS cap</label>
                  <select id="uiFpsSelect">
                    <option value="60">60</option>
                    <option value="90">90</option>
                    <option value="120">120</option>
                    <option value="uncapped">Uncapped</option>
                  </select>
                </div>
              </div>

              <div class="panel mini">
                <header class="mini-header">
                  <div class="title">Profile</div>
                  <div class="sub">T√™n hi·ªÉn th·ªã & tag</div>
                </header>
                <div class="content">
                  <div class="row">
                    <!-- d√πng l·∫°i nameInput g·ªëc -->
                    <div style="flex:1">
                      <label>T√™n hi·ªÉn th·ªã (ƒë√£ c√≥)</label>
                      <div class="mono-note">B·∫°n ch·ªânh tr·ª±c ti·∫øp ·ªü tab T·∫°o/T√¨m ph√≤ng (nameInput).</div>
                    </div>
                    <div style="min-width:220px">
                      <label>Clan tag</label>
                      <input id="clanTagInput" class="mono" placeholder="VD: HIC" maxlength="6"/>
                    </div>
                  </div>
                </div>
              </div>

              <div class="row" style="justify-content:flex-end; gap:10px">
                <button class="secondary" id="customResetBtn">Reset settings</button>
                <button id="customSaveBtn">Save</button>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Inventory -->
        <section class="tab" id="tabInventory">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">T·ª¶ ƒê·ªí</div>
              <div class="sub">Deck / SetCard ‚Ä¢ Back card ‚Ä¢ Cosmetics</div>
            </header>

            <div class="content col">
              <div class="row" style="align-items:flex-end">
                <div class="col" style="flex:1">
                  <label>Deck / SetCard</label>
                  <div class="hint">M·ªü c·∫•u h√¨nh b·ªô b√†i v√† set s·ªë l∆∞·ª£ng t·ª´ng lo·∫°i</div>
                </div>
                <!-- d√πng ƒë√∫ng id openDeckBtn ƒë√£ c√≥: n·∫øu b·∫°n mu·ªën n√≥ ‚Äúch·ªâ n·∫±m ·ªü ƒë√¢y‚Äù
                     th√¨ d√πng CSS ·∫©n trong roomPanel v√† hi·ªán trong tab n√†y b·∫±ng c√°ch move DOM b·∫±ng JS (·ªü d∆∞·ªõi) -->
                <button class="secondary" id="invOpenDeckBtn">M·ªü Deck / SetCard</button>
              </div>

              <div class="grid-2">
                <div class="panel mini">
                  <header class="mini-header">
                    <div class="title">Deck images</div>
                    <div class="sub">Front folder + Back image</div>
                  </header>
                  <div class="content">
                    <div class="hint">B·∫°n ch·ªânh tr·ª±c ti·∫øp ·ªü tab T·∫°o/T√¨m ph√≤ng (frontBaseInput, backUrlInput) ƒë·ªÉ host apply.</div>
                    <div class="row" style="justify-content:flex-end">
                      <button class="secondary" id="invApplyDeckBtn">Apply deck images</button>
                    </div>
                  </div>
                </div>

                <div class="panel mini">
                  <header class="mini-header">
                    <div class="title">Cosmetics</div>
                    <div class="sub">Vi·ªÅn b√†i, hi·ªáu ·ª©ng k√©o th·∫£</div>
                  </header>
                  <div class="content">
                    <div class="row">
                      <label class="chk">
                        <input type="checkbox" id="cosGlow" checked />
                        <span>Card glow on hover</span>
                      </label>
                    </div>
                    <div class="row">
                      <label class="chk">
                        <input type="checkbox" id="cosTrail" />
                        <span>Drag trail</span>
                      </label>
                    </div>
                    <div class="row">
                      <label class="chk">
                        <input type="checkbox" id="cosRareFx" />
                        <span>Rare sparkle (host only)</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>

              <div class="panel mini">
                <header class="mini-header">
                  <div class="title">Presets</div>
                  <div class="sub">L∆∞u / t·∫£i nhanh deck preset</div>
                </header>
                <div class="content">
                  <div class="row">
                    <input id="presetName" placeholder="T√™n preset..." />
                    <button class="secondary" id="presetSave">Save preset</button>
                    <button class="secondary" id="presetLoad">Load preset</button>
                    <button class="danger" id="presetDelete">Delete</button>
                  </div>
                  <div class="hint">G·ª£i √Ω: preset gi√∫p host set s·∫µn b·ªô b√†i theo ‚Äúmode ch∆°i‚Äù (draft / poker / tcg...).</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Shop -->
        <section class="tab" id="tabShop">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">C·ª¨A H√ÄNG</div>
              <div class="sub">Mua cosmetics (client-side) ‚Ä¢ Kh√¥ng ·∫£nh h∆∞·ªüng gameplay</div>
            </header>

            <div class="content">
              <div class="shop-grid">
                <div class="shop-card">
                  <div class="shop-img"></div>
                  <div class="shop-title">Card Back: Obsidian</div>
                  <div class="shop-sub">Dark ‚Ä¢ Minimal ‚Ä¢ Premium</div>
                  <div class="shop-row">
                    <div class="price">1200</div>
                    <button class="secondary">Xem</button>
                    <button>Mua</button>
                  </div>
                </div>

                <div class="shop-card">
                  <div class="shop-img alt"></div>
                  <div class="shop-title">Border: Gold Line</div>
                  <div class="shop-sub">LoL-ish golden edge</div>
                  <div class="shop-row">
                    <div class="price">800</div>
                    <button class="secondary">Xem</button>
                    <button>Mua</button>
                  </div>
                </div>

                <div class="shop-card">
                  <div class="shop-img alt2"></div>
                  <div class="shop-title">Emote Pack</div>
                  <div class="shop-sub">Quick reactions</div>
                  <div class="shop-row">
                    <div class="price">500</div>
                    <button class="secondary">Xem</button>
                    <button>Mua</button>
                  </div>
                </div>
              </div>

              <div class="hint">B·∫°n c√≥ th·ªÉ n·ªëi c·ª≠a h√†ng v·ªõi inventory sau (localStorage / server profile).</div>
            </div>
          </div>
        </section>

        <!-- TAB: Notifications -->
        <section class="tab" id="tabNotifications">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">TH√îNG B√ÅO</div>
              <div class="sub">System ‚Ä¢ Room ‚Ä¢ Friends (future)</div>
            </header>

            <div class="content col">
              <div class="notif-item">
                <div class="notif-dot"></div>
                <div class="notif-body">
                  <div class="notif-title">Tip: Local mode</div>
                  <div class="notif-sub">M·ªü 4 tab, c√πng m√£ ph√≤ng ƒë·ªÉ test 4 ng∆∞·ªùi nhanh nh·∫•t.</div>
                </div>
                <button class="secondary">ƒê√£ hi·ªÉu</button>
              </div>

              <div class="notif-item">
                <div class="notif-dot warn"></div>
                <div class="notif-body">
                  <div class="notif-title">Host authoritative</div>
                  <div class="notif-sub">N·∫øu host r·ªùi ph√≤ng, game c√≥ th·ªÉ ‚Äúpause‚Äù (sau s·∫Ω th√™m host-migration).</div>
                </div>
                <button class="secondary">OK</button>
              </div>

              <div class="row" style="justify-content:flex-end">
                <button class="danger" id="clearNotifBtn">Clear all</button>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Quick Play (s√°ng t·∫°o) -->
        <section class="tab" id="tabQuickPlay">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">QUICK PLAY</div>
              <div class="sub">T·∫°o ph√≤ng nhanh v·ªõi c·∫•u h√¨nh ph·ªï bi·∫øn</div>
            </header>
            <div class="content">
              <div class="quick-grid">
                <button class="quick-card" data-quick="draft">
                  <div class="q-title">Draft</div>
                  <div class="q-sub">Deck preset: Draft 60</div>
                </button>
                <button class="quick-card" data-quick="poker">
                  <div class="q-title">Poker</div>
                  <div class="q-sub">Preset: 52 + Jokers</div>
                </button>
                <button class="quick-card" data-quick="tcg">
                  <div class="q-title">TCG</div>
                  <div class="q-sub">Preset: 40 ‚Ä¢ rarity fx</div>
                </button>
              </div>
              <div class="hint">Quick Play ch·ªâ ‚Äúƒëi·ªÅn s·∫µn‚Äù setCard/preset v√† t·∫°o ph√≤ng host.</div>
            </div>
          </div>
        </section>

        <!-- TAB: Tutorial (s√°ng t·∫°o) -->
        <section class="tab" id="tabTutorial">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">H∆Ø·ªöNG D·∫™N</div>
              <div class="sub">Ph√≠m t·∫Øt ‚Ä¢ thao t√°c ‚Ä¢ m·∫πo</div>
            </header>
            <div class="content">
              <div class="tutorial-grid">
                <div class="tut-card">
                  <div class="tut-title">K√©o th·∫£ b√†i</div>
                  <div class="tut-sub">Drag ƒë·ªÉ di chuy·ªÉn ‚Ä¢ Shift ƒë·ªÉ snap (n·∫øu c√≥)</div>
                </div>
                <div class="tut-card">
                  <div class="tut-title">Host tools</div>
                  <div class="tut-sub">Reset b√†n ‚Ä¢ Apply deck images ‚Ä¢ SetCard</div>
                </div>
                <div class="tut-card">
                  <div class="tut-title">Sync</div>
                  <div class="tut-sub">Client g·ª≠i intent ‚Ä¢ host quy·∫øt ƒë·ªãnh state</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Patch Notes (s√°ng t·∫°o) -->
        <section class="tab" id="tabPatchNotes">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">PATCH NOTES</div>
              <div class="sub">Ghi ch√∫ c·∫≠p nh·∫≠t ‚Ä¢ roadmap</div>
            </header>
            <div class="content">
              <ul class="patch">
                <li><span class="tag new">NEW</span> Lobby modular tabs</li>
                <li><span class="tag imp">IMP</span> Better visual hierarchy + LoL-like theme</li>
                <li><span class="tag todo">TODO</span> Host migration, friends list, room browser</li>
              </ul>
            </div>
          </div>
        </section>
      </main>

      <!-- Bottom dock: n√∫t li√™n quan / ti·ªán √≠ch nhanh -->
      <div class="lobby-dock">
        <div class="dock-left">
          <button class="secondary" id="dockRoomBtn">Ph√≤ng</button>
          <button class="secondary" id="dockBrowserBtn">Browser</button>
          <button class="secondary" id="dockDeckBtn">Deck</button>
        </div>
      
        <div class="dock-mid">
          <div class="dock-pill">
            <span class="dot"></span>
            <span class="txt" id="dockHint">Tip: Local mode m·ªü 4 tab</span>
          </div>
        </div>
      
        <div class="dock-right">
          <button class="secondary" id="dockCopyBtn">Copy link</button>
          <button class="danger" id="dockResetBtn">Reset</button>
          <button id="dockJoinBtn">Join</button>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- =========================
  SCREEN: MATCH (·∫©n ban ƒë·∫ßu)
  Gi·ªØ nguy√™n #app v√† m·ªçi id b√™n trong
========================= -->
<div id="matchScreen" class="screen">
  <div id="app">
    <canvas id="c"></canvas>
    <div id="toast"></div>

    <div class="hud">
      <!-- Tr·∫°ng th√°i -->
      <div class="panel collapsible" id="sttPanel">
        <header>
          <div class="title">TR·∫†NG TH√ÅI</div>
          <div class="badge" id="roomBadge">‚Äî</div>
          <button class="collapse-btn" data-target="sttPanel">‚àí</button>
        </header>
        <div class="content col">
          <div class="row" style="justify-content:space-between">
            <div class="col" style="gap:4px">
              <div style="font-size:12px; color:var(--muted)">B·∫°n l√†</div>
              <div id="meLine" style="font-weight:700">‚Äî</div>
            </div>
            <div class="col" style="gap:4px; align-items:flex-end">
              <div style="font-size:12px; color:var(--muted)">Host</div>
              <div id="hostLine" style="font-weight:700">‚Äî</div>
            </div>
          </div>

          <div class="row" style="justify-content:space-between">
            <div class="col" style="gap:6px">
              <div style="font-size:12px; color:var(--muted)">Ng∆∞·ªùi ch∆°i (t·ªëi ƒëa 6)</div>
              <div id="playersLine" style="font-size:13px; line-height:1.4">‚Äî</div>
            </div>
          </div>

          <!-- ===== SETUP / WAITING ROOM (NEW) ===== -->
          <div id="setupBox" class="col" style="gap:8px; margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,.08)">
            <div style="font-size:12px; color:var(--muted); font-weight:700;">PH√íNG CH·ªú / SETUP</div>
          
            <div id="setupPhaseLine" class="hint" style="opacity:.95">
              ƒêang ch·ªù host...
            </div>
          
            <!-- Host-only controls -->
            <div id="hostSetupControls" class="col" style="gap:8px; display:none">
              <label>Host: ch·ªçn setCard ƒë·ªÉ ch∆°i</label>
              <select id="hostSetSelect" style="width:100%"></select>
          
              <div class="row">
                <button id="hostRefreshSetsBtn" class="secondary" style="flex:1">Refresh set</button>
                <button id="hostLoadDeckBtn" class="secondary" style="flex:1">Load deck</button>
              </div>
          
              <button id="startGameBtn" style="width:100%">B·∫Øt ƒë·∫ßu ch∆°i</button>
            </div>
          </div>
          <!-- ===== /SETUP ===== -->
          
          <div class="row">
            <button id="leaveMatchBtn" class="danger" style="flex:1">R·ªùi ph√≤ng</button>
          </div>

          <div class="hint">
            Privacy: b√†i trong <b>hand</b> c·ªßa ng∆∞·ªùi kh√°c ch·ªâ hi·ªán m·∫∑t sau v·ªõi b·∫°n.
          </div>
        </div>
      </div>
    </div>

    <!-- B·∫£ng score -->
    <div id="statusBoard" class="collapsed">
      <header>
        <div class="right">
          <button class="collapse-btn" id="sbToggle" type="button">+</button>
          <div class="title">B·∫£ng ƒëi·ªÉm</div>
        </div>
        
      </header>
      <div class="body" id="sbBody"></div>
    </div>

    <!-- Chat -->
    <div id="chatPanel" class="collapsible">
      <header>
        <div class="actions">
          <button class="collapse-btn" data-target="chatPanel" type="button">‚àí</button>
          <div class="chatToggle" id="chatToggle">
            <button type="button" data-mode="all" class="active">ALL</button>
            <button type="button" data-mode="team">TEAM</button>
          </div>
        </div>
        <div class="titleRow">
          <div class="badge" id="chatBadge">0</div>
          <div class="title">CHAT</div>
        </div>
      </header>
    
      <div class="content">
        <div id="chatLog"></div>
        <form id="chatForm" autocomplete="off">
          <input id="chatInput" placeholder="Enter ƒë·ªÉ chat..." />
          <button id="chatSend" type="submit">Send</button>
        </form>
      </div>
    </div>


    <!-- Inspector -->
    <div id="inspector">
      <div class="panel" style="height:100%; display:flex; flex-direction:column;">
        <header>
          <div class="title">CARD INSPECTOR</div>
          <div class="badge" id="insBadge">‚Äî</div>
        </header>

        <div class="content" style="display:flex; flex-direction:column; gap:10px; height:100%;">
          <div id="insPreview" style="
            flex:1;
            border:1px solid rgba(255,255,255,.12);
            border-radius: 14px;
            background: rgba(0,0,0,.18);
            display:flex; align-items:center; justify-content:center;
            overflow:hidden;
          ">
            <div style="color:rgba(233,236,255,.55); font-size:12px">Ch·ªçn 1 l√° b√†i...</div>
          </div>

          <div class="row" style="justify-content:space-between">
            <button id="btnFlip" class="secondary" style="flex:1">Flip</button>
            <button id="btnDiscard" class="danger" style="flex:1">Discard</button>
          </div>
          <div class="row" style="justify-content:space-between">
            <button id="btnUnstack" class="secondary" style="flex:1">Unstack</button>
            <button id="btnShuffle" class="secondary" style="flex:1">Shuffle</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Help -->
    <div class="panel collapsible" id="help">
      <div class="panel">
        <header>
          <div class="title">H∆∞·ªõng d·∫´n</div>
          <button class="collapse-btn" data-target="help">‚àí</button>
        </header>
        <div class="content hint">
          <div>
            <span class="kbd">K√©o th·∫£</span> chu·ªôt ƒë·ªÉ di chuy·ªÉn b√†i (table / hand).<br/>
            <span class="kbd">Q</span> r√∫t 1 l√° t·ª´ Deck v·ªÅ Hand c·ªßa b·∫°n (ƒë·ª©ng g·∫ßn Deck ho·∫∑c ch·ªçn Deck).<br/>
            <span class="kbd">W</span> l·∫≠t l√° / ch·ªìng (stack).<br/>
            <span class="kbd">E</span> tr·ªôn ch·ªìng (deck/stack).<br/>
            <span class="kbd">R</span> t√°ch 1 l√° ra kh·ªèi ch·ªìng (l·∫•y top).<br/>
            <span class="kbd">T</span> b·ªè l√° b√†i<br/>
            <span class="kbd">Click</span> ch·ªçn l√°/ch·ªìng. 
            <span class="kbd">Esc</span>/<span class="kbd">Click ngo√†i</span> b·ªè ch·ªçn.
          </div>
        </div>
      </div>
    </div>

  </div>
</div>


<!-- =========================
  POPUP: Deck / SetCard (gi·ªØ nguy√™n)
========================= -->
<div id="deckModal" class="modal" style="display:none;">
  <div class="modal-card">
    <div style="
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-height: 85vh;
        max-height: 85vh;
    ">
      <header style="padding: 10px 12px;background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
            border-bottom: 1px solid rgba(255,255,255,.06);display: flex;align-items: center;justify-content: space-between;
            gap: 10px;border-radius: 15px;">
            <div class="title">T√πy ch·ªânh b·ªô b√†i c·ªßa b·∫°n</div>
            <button id="closeDeckBtn" class="collapse-btn">√ó</button>
        </header>
      
    <div class="content col" style="gap:10px;overflow: hidden; display: flex; justify-content: space-between;">
      <div class="col" style="gap:6px">
        <label>B·ªô ƒë√£ l∆∞u</label>
        <div class="row">
          <select id="setSelect" style="flex:1; min-width:220px"></select>
          <button id="loadSetBtn" class="secondary">Load</button>
          <button id="deleteSetBtn" class="danger">X√≥a</button>
          <button style="margin-left:15px;" id="newSetBtn" class="secondary">+ T·∫°o b·ªô m·ªõi</button>
        </div>
      </div>

      <div class="col" style="gap:6px">
        <label>T√™n b·ªô b√†i</label>
        <input id="setNameInput" placeholder="VD: Poker / Game A" />
      </div>

      <div class="col" style="gap:6px">
        <label>URL h√¨nh ·∫£nh m·∫∑t sau l√° b√†i (link ·∫£nh .png .jpg)</label>
        <input id="setBackUrlInput" class="mono" placeholder="https://.../img.png" />
      </div>

      <div class="row" style="justify-content:space-between">
        <div class="hint">URL h√¨nh ·∫£nh m·∫∑t tr∆∞·ªõc l√° b√†i</div>
        <div style="display: flex; gap:5px;">
          <button id="addCardUrlBtn" class="secondary">+ Th√™m b√†i</button>
          <button id="saveSetBtn">L∆∞u b·ªô b√†i</button>
        </div>
      </div>
      <div style="justify-content: space-between;display: flex;gap: 8px;padding: 6px;background: #cae6ff0d;
        border-radius: 8px;width: 100%;font-family: inherit;font-size: 13px;align-items: center;margin-bottom: -5px;">
        <div style=" width: 38%;">T√™n l√° b√†i</div>
        <div style="width: 35%; ">URL h√¨nh ·∫£nh</div>
        <div >S·ªë l∆∞·ª£ng</div>
        <div style="width: 5%;"></div>
      </div>
      <div id="cardUrlList" class="col" style="gap:8px; max-height:240px; overflow:auto; padding-right:6px"></div>
    </div>
  </div>
</div>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script> 
<script>
/* =========================================================
   0) Utils / Core helpers
========================================================= */
"use strict";

const clamp   = (v, a, b) => Math.max(a, Math.min(b, v));
const randInt = (a, b) => (Math.random() * (b - a + 1) + a) | 0;
const now     = () => Date.now();
const uid     = () => (crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + "_" + Date.now()));
const deepClone = (obj) => (typeof structuredClone === "function" ? structuredClone(obj) : JSON.parse(JSON.stringify(obj)));

function escapeHtml(str){
  return (str ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function toast(text, ms=1600){
  const el = document.getElementById("toast");
  if (!el) { console.log("[toast]", text); return; } // <-- ch·ªëng crash
  el.textContent = text;
  el.style.display = "block";
  clearTimeout(el._t);
  el._t = setTimeout(()=> el.style.display="none", ms);
}

/* =========================================================
   1) Constants / Layout
========================================================= */
const COLORS = {
  red:   "#ff5c7a",
  blue:  "#5aa7ff",
  green: "#4ad37d",
  yellow:"#ffd166",
};
const COLOR_ORDER = ["red","blue","green","yellow"];

const ZONES = {
  table: "table",
  hand: "hand",
  deck: "deck",
  discard: "discard",
};

const CARD = { w: 86, h: 122, r: 12 };

const TABLE = {
  w: 1700,
  h: 900,
  margin: 40,
  handH: 150,
  sideW: 220,
  rightW: 260,
};

function zoneRects(){
  const m = TABLE.margin;
  const { w, h, handH, sideW, rightW } = TABLE;

  const tableRect = {
    x: m + sideW,
    y: m + handH,
    w: w - 2*m - sideW - rightW,
    h: h - 2*m - 2*handH
  };

  return {
    table: tableRect,

    handTopLeft: {
      x: tableRect.x,
      y: m,
      w: tableRect.w / 2,
      h: handH
    },
    handTopRight: {
      x: tableRect.x + tableRect.w / 2,
      y: m,
      w: tableRect.w / 2,
      h: handH
    },

    handBottomLeft: {
      x: tableRect.x,
      y: tableRect.y + tableRect.h,
      w: tableRect.w / 2,
      h: handH
    },
    handBottomRight: {
      x: tableRect.x + tableRect.w / 2,
      y: tableRect.y + tableRect.h,
      w: tableRect.w / 2,
      h: handH
    },

    handRightTop: {
      x: w - m - rightW,
      y: tableRect.y,
      w: rightW,
      h: tableRect.h / 2
    },
    handRightBottom: {
      x: w - m - rightW,
      y: tableRect.y + tableRect.h / 2,
      w: rightW,
      h: tableRect.h / 2
    },

    deck: {
      x: m,
      y: tableRect.y,
      w: sideW,
      h: tableRect.h / 2
    },
    discard: {
      x: m,
      y: tableRect.y + tableRect.h / 2,
      w: sideW,
      h: tableRect.h / 2
    }
  };
}

/* =========================================================
   2) Canvas / Camera
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

const camera = { scale: 1, offsetX: 0, offsetY: 0 };

function updateCamera(){
  const pad = 18;
  const sx = (innerWidth - pad*2) / TABLE.w;
  const sy = (innerHeight - pad*2) / TABLE.h;
  camera.scale = Math.min(sx, sy);
  camera.offsetX = (innerWidth - TABLE.w * camera.scale) / 2;
  camera.offsetY = (innerHeight - TABLE.h * camera.scale) / 2;
}
updateCamera();
addEventListener("resize", updateCamera);

function toScreen(p){
  return { x: camera.offsetX + p.x * camera.scale, y: camera.offsetY + p.y * camera.scale };
}
function toWorld(p){
  return { x: (p.x - camera.offsetX) / camera.scale, y: (p.y - camera.offsetY) / camera.scale };
}

/* =========================================================
   3) UI refs (gi·ªØ nguy√™n id c·ªßa b·∫°n)
========================================================= */
const UI = {
  modeSelect: document.getElementById("modeSelect"),
  wsRow: document.getElementById("wsRow"),
  wsUrlInput: document.getElementById("wsUrlInput"),
  nameInput: document.getElementById("nameInput"),
  roomInput: document.getElementById("roomInput"),
  createBtn: document.getElementById("createBtn"),
  joinBtn: document.getElementById("joinBtn"),
  copyLinkBtn: document.getElementById("copyLinkBtn"),
  resetBtn: document.getElementById("resetBtn"),
  netBadge: document.getElementById("netBadge"),
  roomBadge: document.getElementById("roomBadge"),
  meLine: document.getElementById("meLine"),
  hostLine: document.getElementById("hostLine"),
  playersLine: document.getElementById("playersLine"),
  chatBadge: document.getElementById("chatBadge"),
  chatLog: document.getElementById("chatLog"),
  chatForm: document.getElementById("chatForm"),
  chatInput: document.getElementById("chatInput"),
  frontBaseInput: document.getElementById("frontBaseInput"),
  backUrlInput: document.getElementById("backUrlInput"),
  applyDeckBtn: document.getElementById("applyDeckBtn"),
  setupBox: document.getElementById("setupBox"),
  setupPhaseLine: document.getElementById("setupPhaseLine"),
  hostSetupControls: document.getElementById("hostSetupControls"),
  hostSetSelect: document.getElementById("hostSetSelect"),
  hostRefreshSetsBtn: document.getElementById("hostRefreshSetsBtn"),
  hostLoadDeckBtn: document.getElementById("hostLoadDeckBtn"),
  startGameBtn: document.getElementById("startGameBtn"),

};

  

/* =========================================================
   4) Screens Router
   - B·∫°n ƒëang d√πng l·∫´n: screenAuth/screenLobby/screenMatch v√† authScreen/lobbyScreen/matchScreen
   - FIX: T·ª± detect c√°i n√†o t·ªìn t·∫°i
========================================================= */
const SCREENS = {
  auth:  document.getElementById("authScreen"),
  lobby: document.getElementById("lobbyScreen"),
  match: document.getElementById("matchScreen"),
};

function setScreen(name){
  for (const k in SCREENS){
    const el = SCREENS[k];
    if (el) el.classList.remove("active");
  }
  if (SCREENS[name]) SCREENS[name].classList.add("active");
}

function goAuth(){ setScreen("auth"); }
function goLobby(){ setScreen("lobby"); }
function goMatch(){ setScreen("match"); try{ resize(); updateCamera(); }catch(e){} }

goAuth();


let _hostSetsCache = {}; // {setId: data}

async function refreshHostSetSelect(){
  await fbEnsureAuth();
  if (!UI.hostSetSelect) return;

  const snap = await FB.db.ref(`AllUser/${FB.uid}/setCard`).get();
  _hostSetsCache = snap.val() || {};

  UI.hostSetSelect.innerHTML = "";
  const ids = Object.keys(_hostSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(ch∆∞a c√≥ setCard)";
    UI.hostSetSelect.appendChild(op);
    return;
  }

  for (const id of ids){
    const set = _hostSetsCache[id] || {};
    const cnt = Object.keys(set.cards || {}).length;
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${set.name || id} (${cnt} lo·∫°i)`;
    UI.hostSetSelect.appendChild(op);
  }
}

async function hostLoadSelectedSetToRoom_FromSaved(){
  if (!client.isHost) return toast("Ch·ªâ host m·ªõi load deck");
  if (!(client.transport instanceof FirebaseTransport)) return toast("Ch·ªâ d√πng ƒë∆∞·ª£c trong Firebase mode");
  await fbEnsureAuth();

  const setId = UI.hostSetSelect?.value || "";
  if (!setId) return toast("Ch∆∞a ch·ªçn set");

  // n·∫øu cache tr·ªëng th√¨ refresh
  if (!_hostSetsCache[setId]) await refreshHostSetSelect();
  const data = _hostSetsCache[setId];
  if (!data) return toast("Set kh√¥ng t·ªìn t·∫°i");

  const types = Object.values(data.cards || {}).map(t=>({
    name: t?.name || "",
    frontUrl: (t?.frontUrl || "").trim(),
    count: Math.max(1, parseInt(t?.count, 10) || 1),
  })).filter(t => t.frontUrl && t.count > 0);

  const total = types.reduce((s,t)=>s + (t.count|0), 0);
  if (total <= 0) return toast("Set r·ªóng (ch∆∞a c√≥ URL)");

  const backUrl = (data.backUrl || "").trim();

  // update room meta ƒë·ªÉ ng∆∞·ªùi kh√°c / host refresh v·∫´n bi·∫øt deckSource
  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.child("meta").update({
    deckSource: { uid: FB.uid, setId },
    deckBackUrl: backUrl,
    deckTotal: total
  });

  // build deck v√†o host state + write state
  if (client.host && client.host.state){
    client.host.state.assets = client.host.state.assets || { frontBase:"", backUrl:"" };
    client.host.state.assets.backUrl = backUrl;

    buildPhysicalDeckFromTypes(client.host.state, types, "stack_deck");
    client.host.bumpVersion?.();
    await client.transport.writeState(client.host.state);
  }

  toast(`Loaded deck: ${types.length} lo·∫°i / ${total} l√°`);
}

if (UI.hostRefreshSetsBtn){
  UI.hostRefreshSetsBtn.onclick = async ()=>{
    try{ await refreshHostSetSelect(); toast("ƒê√£ refresh set"); }
    catch(e){ console.error(e); toast(e.message || e); }
  };
}

if (UI.hostLoadDeckBtn){
  UI.hostLoadDeckBtn.onclick = async ()=>{
    try{ await hostLoadSelectedSetToRoom_FromSaved(); }
    catch(e){ console.error(e); toast(e.message || e); }
  };
}

if (UI.startGameBtn){
  UI.startGameBtn.onclick = ()=>{
    if (!client.isHost) return toast("Ch·ªâ host m·ªõi b·∫Øt ƒë·∫ßu");
    sendIntent({ type:"startGame" });
    toast("B·∫Øt ƒë·∫ßu!");
  };
}

  
/* =========================================================
   5) Inspector (card inspector popup)
========================================================= */
const INS = {
  badge: document.getElementById("insBadge"),
  preview: document.getElementById("insPreview"),
  btnFlip: document.getElementById("btnFlip"),
  btnDiscard: document.getElementById("btnDiscard"),
  btnUnstack: document.getElementById("btnUnstack"),
  btnShuffle: document.getElementById("btnShuffle"),
};

function getWorldPosOfTarget(st, target){
  if (!st || !target) return null;
  if (target.type === "card"){
    const c = st.cards?.[target.id];
    if (!c) return null;
    return {x: c.x, y: c.y};
  } else {
    const s = st.stacks?.[target.id];
    if (!s) return null;
    return {x: s.x, y: s.y};
  }
}

function positionInspectorNearTarget(){
  const st = getState();
  const sel = client.selected;
  if (!st || !sel) return;

  const wp = getWorldPosOfTarget(st, sel);
  if (!wp) return;

  const sp = toScreen(wp);
  const ins = document.getElementById("inspector");
  if (!ins) return;

  const pad = 10;
  const offsetX = 20;
  const offsetY = -20;

  const rect = ins.getBoundingClientRect();
  let left = sp.x + offsetX;
  let top  = sp.y + offsetY;

  left = clamp(left, pad, innerWidth - rect.width - pad);
  top  = clamp(top,  pad, innerHeight - rect.height - pad);

  ins.style.left = left + "px";
  ins.style.top  = top + "px";
}

function showInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "block";
  updateInspector();
  requestAnimationFrame(positionInspectorNearTarget);
}
function hideInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "none";
}

function updateInspector(){
  const st = getState();
  const sel = client.selected;

  if (!INS.badge || !INS.preview) return;

  if (!st || !sel){
    INS.badge.textContent = "‚Äî";
    INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Ch·ªçn 1 l√° b√†i...</div>`;
    return;
  }

  // ===== DECK (SPECIAL CASE) =====
  if (sel.type === "stack" && sel.id === "stack_deck"){
    const count = st.stacks?.stack_deck?.cardIds?.length || 0;
    INS.badge.textContent = "DECK";
    INS.preview.innerHTML = `
      <div style="text-align:center;font-size:13px">
        <div>${count} cards</div>
        <div style="opacity:.6;margin-top:6px">Press D to draw</div>
        <div style="opacity:.4;margin-top:4px">Press S to shuffle</div>
      </div>
    `;
    return;
  }

  // ===== CARD =====
  if (sel.type === "card"){
    const c = st.cards?.[sel.id];
    INS.badge.textContent = sel.id + (c?.lockedBy ? " (LOCK)" : "");

    // FIX: ∆∞u ti√™n frontUrl (setCard), n·∫øu kh√¥ng c√≥ th√¨ m·ªõi d√πng frontBase+id.png
    const frontUrl = c?.frontUrl
      ? c.frontUrl
      : (st.assets?.frontBase ? (st.assets.frontBase + sel.id + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c?.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">
          No image set. Host h√£y set Back URL ho·∫∑c load setCard.
        </div>`;
    return;
  }

  // ===== STACK (NORMAL) =====
  if (sel.type === "stack"){
    const s = st.stacks?.[sel.id];
    const topId = s?.cardIds?.[0];
    INS.badge.textContent = `${sel.id} (${s?.cardIds?.length || 0})`;

    if (!topId){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Empty stack</div>`;
      return;
    }

    const c = st.cards?.[topId];
    const frontUrl = c?.frontUrl
      ? c.frontUrl
      : (st.assets?.frontBase ? (st.assets.frontBase + topId + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c?.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">No image set.</div>`;
  }
}

/* =========================================================
   6) Networking Abstraction (Local / WS / Firebase)
========================================================= */
class NetTransport {
  constructor(){ this.onMessage = ()=>{}; this.onStatus = ()=>{}; }
  send(_msg) {}
  close() {}
}

class LocalBroadcastTransport extends NetTransport {
  constructor(roomCode, selfId){
    super();
    this.roomCode = roomCode;
    this.selfId = selfId;
    this.bc = new BroadcastChannel("ttc_" + roomCode);
    this.bc.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg || msg._from === this.selfId) return;
      this.onMessage(msg);
    };
    this.onStatus({connected:true, mode:"local"});
  }
  send(msg){
    this.bc.postMessage({...msg, _from:this.selfId});
  }
  close(){
    this.onStatus({connected:false, mode:"local"});
    this.bc.close();
  }
}

class LocalStorageTransport extends NetTransport {
  constructor(roomCode, selfId){
    super();
    this.roomCode = roomCode;
    this.selfId = selfId;
    this.key = "ttc_ls_" + roomCode;

    this._onStorage = (ev) => {
      if (ev.key !== this.key || !ev.newValue) return;
      try{
        const msg = JSON.parse(ev.newValue);
        if (!msg || msg._from === this.selfId) return;
        this.onMessage(msg);
      }catch(e){}
    };
    window.addEventListener("storage", this._onStorage);
    this.onStatus({connected:true, mode:"local"});
  }

  send(msg){
    try{
      const payload = JSON.stringify({...msg, _from:this.selfId, _t: Date.now()});
      localStorage.setItem(this.key, payload);
    }catch(e){}
  }

  close(){
    window.removeEventListener("storage", this._onStorage);
    this.onStatus({connected:false, mode:"local"});
  }
}

class WebSocketTransport extends NetTransport {
  constructor(url){
    super();
    this.ws = new WebSocket(url);
    this.ws.onopen = () => this.onStatus({connected:true, mode:"ws"});
    this.ws.onclose = () => this.onStatus({connected:false, mode:"ws"});
    this.ws.onerror = () => this.onStatus({connected:false, mode:"ws"});
    this.ws.onmessage = (ev) => {
      try{
        const msg = JSON.parse(ev.data);
        this.onMessage(msg);
      }catch(e){}
    };
  }
  send(msg){
    if (this.ws.readyState === 1) this.ws.send(JSON.stringify(msg));
  }
  close(){ try{ this.ws.close(); }catch(e){} }
}

/* =========================================================
   7) Game State / Redaction (Authoritative on Host)
========================================================= */
function makeFreshTableState(roomCode, hostId){
  const st = {
    roomCode,
    hostId,
    players: [],
    cards: {},
    stacks: {},
    chat: [],
    version: 1,
    assets: { frontBase:"", backUrl:"" },
    _deckPool: [], // FIX: b·∫°n d√πng _deckPool trong draw => ph·∫£i c√≥ s·∫µn
    game: { phase: "setup" },
  };

  const rects = zoneRects();
  const deckX = rects.deck.x + rects.deck.w/2;
  const deckY = rects.deck.y + rects.deck.h/2;

  const deckStackId = "stack_deck";
  st.stacks[deckStackId] = { id: deckStackId, zone: ZONES.deck, owner: null, x: deckX, y: deckY, cardIds: [] };

  for(let i=1;i<=40;i++){
    const id = "C" + String(i).padStart(2,"0");
    st.cards[id] = {
      id,
      frontSeed: i,
      faceUp: false,
      x: deckX,
      y: deckY,
      zone: ZONES.deck,
      owner: null,
      ownerId: null,
      stackId: deckStackId,
      order: i,
    };
    st.stacks[deckStackId].cardIds.push(id);
  }
  return st;
}

function buildPhysicalDeckFromTypes(st, types, deckStackId="stack_deck"){
  // types: [{name, frontUrl, count}]
  const deck = st.stacks[deckStackId];
  if (!deck) throw new Error("Missing stack_deck");

  // X√≥a c√°c card c≈© thu·ªôc deckStack (t√πy b·∫°n: ho·∫∑c gi·ªØ cards kh√°c)
  // ·ªû ƒë√¢y m√¨nh l√†m "rebuild s·∫°ch": x√≥a to√†n b·ªô cards v√† stacks th∆∞·ªùng,
  // gi·ªØ discard stack + players + assets.
  const rects = zoneRects();
  const deckX = rects.deck.x + rects.deck.w/2;
  const deckY = rects.deck.y + rects.deck.h/2;

  // reset cards + reset stacks (gi·ªØ discard + deck)
  const keepDeck = st.stacks["stack_deck"];

  st.cards = {};
  st.stacks = {
    stack_deck: {...keepDeck, x:deckX, y:deckY, zone:ZONES.deck, owner:null, cardIds:[]},
  };

  // build deck cards
  let running = 1;
  for (const t of types){
    const frontUrl = (t.frontUrl||"").trim();
    const count = Math.max(1, parseInt(t.count,10)||1);
    const name = (t.name||"").trim();

    if (!frontUrl) continue;

    for (let k=0; k<count; k++){
      const id = "D" + String(running).padStart(4,"0") + "_" + uid().slice(0,6);
      st.cards[id] = {
        id,
        faceUp: false,
        x: deckX, y: deckY,
        zone: ZONES.deck,
        owner: null,
        stackId: "stack_deck",
        order: running,
        frontSeed: running,       // fallback text
        frontUrl: frontUrl,       // << IMPORTANT
        typeName: name            // optional
      };
      st.stacks.stack_deck.cardIds.push(id);
      running++;
    }
  }

  // N·∫øu mu·ªën: auto shuffle ngay khi build
  for(let i=st.stacks.stack_deck.cardIds.length-1;i>0;i--){
    const j = randInt(0,i);
    const a = st.stacks.stack_deck.cardIds;
    [a[i], a[j]] = [a[j], a[i]];
  }

  // bump
  st.version = (st.version||0) + 1;
}

function ensureStateShape(state){
  if (!state || typeof state !== "object") return null;

  const s = deepClone(state);

  if (!Array.isArray(s.players)) s.players = [];
  if (!s.cards || typeof s.cards !== "object") s.cards = {};
  if (!s.stacks || typeof s.stacks !== "object") s.stacks = {};
  if (!Array.isArray(s.chat)) s.chat = [];
  if (!s.assets || typeof s.assets !== "object") s.assets = { frontBase:"", backUrl:"" };
  if (!Array.isArray(s._deckPool)) s._deckPool = [];
  if (typeof s.version !== "number") s.version = 1;

  // ‚úÖ th√™m game.phase (setup/playing)
  if (!s.game || typeof s.game !== "object") s.game = { phase: "setup" };
  if (!s.game.phase) s.game.phase = "setup";

  return s;
}

function redactStateForViewer(state, viewerId){
  const s = ensureStateShape(state);
  if (!s) return null;

  const viewer = s.players.find(p => p && p.id === viewerId) || null;

  for (const cardId in s.cards){
    const c = s.cards[cardId];
    if (!c) continue;

    if (c.zone === ZONES.hand && c.owner && c.owner !== viewerId){
      c.faceUp = false;
      c.frontSeed = 0;
      if (c.frontUrl) c.frontUrl = "";
    }
  }

  s._viewer = viewer ? {id: viewer.id, name: viewer.name, color: viewer.color} : null;
  return s;
}

/* =========================================================
   8) Host Controller (Authoritative)
========================================================= */
function canInteract(card, actorId){
  if (!card) return false;
  if (card.zone === ZONES.hand) return card.owner === actorId;
  return true; // table/deck/discard allow (deck dragging is blocked separately)
}
function canInteractStack(stack, actorId){
  if (!stack) return false;
  if (stack.zone === ZONES.hand) return stack.owner === actorId;
  return true;
}
const ensureUIState = (st) => {
  st.ui = st.ui || {};
  st.ui.statHeaders = st.ui.statHeaders || ["ATK","DEF","HP","COIN"];
  st.ui.statsByPlayer = st.ui.statsByPlayer || {};
};
  
class HostController {
  constructor(roomCode, hostId){
    this.roomCode = roomCode;
    this.hostId = hostId;
    this.state = makeFreshTableState(roomCode, hostId);
  }
  
  bumpVersion(){ this.state.version = (this.state.version||0) + 1; }

  addOrUpdatePlayer({id,name}){
    // FIX: ch·ªëng players undefined
    if (!Array.isArray(this.state.players)) this.state.players = [];

    let p = this.state.players.find(x=>x && x.id===id);
    if (!p){
      if (this.state.players.length >= 6) return {ok:false, reason:"Room full"};

      const used = new Set(this.state.players.map(x=>x.color).filter(Boolean));
      const color = COLOR_ORDER.find(c=>!used.has(c)) || COLOR_ORDER[this.state.players.length % COLOR_ORDER.length];
      const seat = this.state.players.length;
      p = {id, name: name || "Player", color, seat, connectedAt: now()};
      this.state.players.push(p);
      ensureUIState(this.state);
      if (!this.state.ui.statsByPlayer[p.id]) this.state.ui.statsByPlayer[p.id] = ["","","",""];
    }else{
      p.name = name || p.name;
    }
    this.bumpVersion();
    return {ok:true, player:p};
  }

  removePlayer(id){
    this.state.players = (this.state.players||[]).filter(p=>p && p.id!==id);
    this.bumpVersion();
  }

  applyIntent(fromId, action){
    const st = this.state = ensureStateShape(this.state) || makeFreshTableState(this.roomCode, this.hostId);
    ensureUIState(st);
    const player = st.players.find(p=>p.id===fromId);
    if (!player) return {ok:false, reason:"Not in room"};

    const rects = zoneRects();
    const ensureCard = (id) => st.cards[id];
    const ensureStack = (id) => st.stacks[id];

    const detachFromStack = (cardId) => {
      const c = ensureCard(cardId);
      if (!c || !c.stackId) return;
      const stack = ensureStack(c.stackId);
      if (!stack) { c.stackId = null; return; }
      stack.cardIds = (stack.cardIds||[]).filter(id=>id!==cardId);
      c.stackId = null;
      if ((stack.cardIds?.length||0) === 0 && stack.id !== "stack_deck"){
        delete st.stacks[stack.id];
      }
    };

    const attachToStackTop = (cardId, stackId) => {
      const c = ensureCard(cardId);
      const stack = ensureStack(stackId);
      if (!c || !stack) return;
      detachFromStack(cardId);
      c.stackId = stackId;
      c.zone = stack.zone;
      c.owner = (stack.zone === ZONES.hand) ? stack.owner : null; // ch·ªâ hand m·ªõi c√≥ owner
      c.x = stack.x; c.y = stack.y;
      stack.cardIds = stack.cardIds || [];
      stack.cardIds.unshift(cardId);
    };

    const createStackFromCard = (cardId) => {
      const c = ensureCard(cardId);
      if (!c) return null;
    
      const sid = "stack_" + uid().slice(0,8);
    
      const zone = c.zone ?? ZONES.table;
      const owner = (zone === ZONES.hand) ? (c.ownerId ?? c.owner ?? null) : null;
    
      st.stacks[sid] = {
        id: sid,
        zone,
        owner,      // lu√¥n string ho·∫∑c null
        x: c.x,
        y: c.y,
        cardIds: [cardId],
      };
    
      c.stackId = sid;
      return sid;
    };


    const HAND_ZONES = [
      { key: "handTopLeft", seat: 0 },
      { key: "handBottomLeft", seat: 1 },
      { key: "handTopRight", seat: 2 },
      { key: "handBottomRight", seat: 3 },
      { key: "handRightTop", seat: 4 },
      { key: "handRightBottom", seat: 5 },
    ];

    function normalizeCardZoneFromPos(x, y){
      for (const hz of HAND_ZONES){
        const r = rects[hz.key];
        if (!r) continue;

        const inRect = (x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h);
        if (!inRect) continue;

        const ownerPlayer = st.players.find(pp => pp.seat === hz.seat);
        if (!ownerPlayer){
          return { zone: ZONES.table, owner: null };
        }
        return { zone: ZONES.hand, owner: ownerPlayer.id };
      }
      return { zone: ZONES.table, owner: null };
    }

    const seatToHandKey = (seat) => {
      switch (seat){
        case 0: return "handTopLeft";
        case 1: return "handBottomLeft";
        case 2: return "handTopRight";
        case 3: return "handBottomRight";
        case 4: return "handRightTop";
        case 5: return "handRightBottom";
        default: return null;
      }
    };

    switch(action.type){
      case "move": {
        const {targetType, id, x, y} = action;

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};

          // ch·∫∑n k√©o card tr·ª±c ti·∫øp t·ª´ deck
          if (c.stackId === "stack_deck") return {ok:false, reason:"Use draw (D) to take from deck"};

          detachFromStack(id);

          const z = normalizeCardZoneFromPos(x, y);
          c.x = x; c.y = y;
          c.zone = z.zone;
          
          if (z.zone === ZONES.hand){
            const handOwner = z.owner ?? null;
            if (!handOwner) {
              c.zone = ZONES.table;
              c.owner = null;
            } else {
              c.owner = handOwner;
              c.ownerId = handOwner;
            }
          } else {
            c.owner = null;
          }
          c.stackId = null;
        }

        if (targetType === "stack") {
          const s = ensureStack(id);
          if (!s) return {ok:false, reason:"Missing stack"};
          if (s.id === "stack_deck") return {ok:false, reason:"Deck fixed"};
          if (!canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
        
          const z = normalizeCardZoneFromPos(x, y);
        
          s.x = x; 
          s.y = y;
        
          const handOwner = (z.zone === ZONES.hand) ? (z.owner ?? null) : null;
          if (z.zone === ZONES.hand && !handOwner) {
            s.zone = ZONES.table;
            s.owner = null;
          } else {
            s.zone = z.zone;
            s.owner = handOwner;
          }
        
          for (const cid of (s.cardIds || [])) {
            const c = ensureCard(cid);
            if (!c) continue;
        
            c.x = s.x;
            c.y = s.y;
            c.zone = s.zone;
            c.owner = (s.zone === ZONES.hand) ? s.owner : null;
        
            if (s.zone === ZONES.hand && s.owner) c.ownerId = s.owner;
          }
        }


        this.bumpVersion();
        return {ok:true};
      }

      case "flip": {
        const {targetType, id} = action;

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};
          c.faceUp = !c.faceUp;
        } else {
          const s = ensureStack(id);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
          const topId = s.cardIds?.[0];
          if (topId){
            const c = ensureCard(topId);
            if (c) c.faceUp = !c.faceUp;
          }
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "shuffle": {
        const {stackId} = action;
        const s = ensureStack(stackId);
        if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};

        for(let i=(s.cardIds?.length||0)-1;i>0;i--){
          const j = randInt(0,i);
          [s.cardIds[i], s.cardIds[j]] = [s.cardIds[j], s.cardIds[i]];
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "draw": {
        const player = st.players.find(p=>p.id===fromId);
        if (!player) return { ok:false, reason:"No player" };
      
        const handKey = seatToHandKey(player.seat);
        const handRect = rects[handKey];
        if (!handRect) return { ok:false, reason:"No hand zone" };
      
        const deck = st.stacks["stack_deck"];
        if (!deck || deck.cardIds.length === 0)
          return { ok:false, reason:"Deck empty" };
      
        const cid = deck.cardIds.shift();     // r√∫t 1 l√° kh·ªèi b·ªô b√†i
        const c = ensureCard(cid);
        if (!c) return { ok:false, reason:"Card missing" };
      
        c.zone = ZONES.hand;
        c.owner = fromId;
        c.ownerId = fromId;
        c.faceUp = true;
        c.x = handRect.x + handRect.w/2 + randInt(-60,60);
        c.y = handRect.y + handRect.h/2 + randInt(-20,20);
        c.stackId = null;
        c.tintOwner = fromId;
      
        this.bumpVersion();
        return { ok:true };
      }


      case "discard": {
        const {targetType, id} = action;
        const rects = zoneRects();
        const r = rects.discard;
      
        const placeInDiscard = (c) => {
          if (!c) return;
          // n·∫øu card ƒëang n·∫±m trong stack n√†o ƒë√≥ th√¨ t√°ch ra
          if (c.stackId) detachFromStack(c.id);
      
          c.zone = ZONES.discard;
          c.owner = null;          // ai c≈©ng thao t√°c
          c.faceUp = true;
          c.stackId = null;
      
          // ‚úÖ bay v√†o v√πng discard (r·∫£i tho·∫£i m√°i)
          c.x = r.x + randInt(30, Math.max(30, r.w - 30));
          c.y = r.y + randInt(30, Math.max(30, r.h - 30));
          // ‚úÖ gi·ªØ ownerId ƒë·ªÉ c√≤n m√†u
          // c.ownerId gi·ªØ nguy√™n, kh√¥ng ƒë·ª•ng
        };
      
        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};
          placeInDiscard(c);
        } else {
          const s = ensureStack(id);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
      
          const ids = [...(s.cardIds||[])];
          for (const cid of ids){
            const c = ensureCard(cid);
            if (!c) continue;
            placeInDiscard(c);
          }
      
          // x√≥a stack sau khi bung ra
          if (s.id !== "stack_deck") delete st.stacks[s.id];
        }
      
        this.bumpVersion();
        return {ok:true};
      }


      case "stack": {
        const { dragTargetType, dragId, dropOnType, dropOnId } = action;
      
        let dragCardIds = [];
        let dragStackId = null;
      
        // 1) X√°c ƒë·ªãnh c√°c card ƒëang k√©o
        if (dragTargetType === "card") {
          const c = ensureCard(dragId);
          if (!c || !canInteract(c, fromId)) return { ok: false, reason: "No access" };
          dragCardIds = [dragId];
          dragStackId = c.stackId; // c√≥ th·ªÉ null n·∫øu card ƒëang r·ªùi stack
        } else {
          const s = ensureStack(dragId);
          if (!s || !canInteractStack(s, fromId)) return { ok: false, reason: "No access" };
          dragCardIds = [...(s.cardIds || [])];
          dragStackId = s.id;
        }
      
        // 2) X√°c ƒë·ªãnh dropStackId (stack nh·∫≠n)
        let dropStackId = null;
      
        if (dropOnType === "card") {
          const c2 = ensureCard(dropOnId);
          if (!c2) return { ok: false, reason: "Missing drop card" };
      
          // ch·∫∑n gom l√™n card thu·ªôc DECK c·ªë ƒë·ªãnh
          if (c2.stackId === "stack_deck") {
            return { ok: false, reason: "Cannot stack onto deck" };
          }
      
          // n·∫øu card ƒëang r·ªùi stack -> t·∫°o stack m·ªõi t·ª´ card ƒë√≥
          dropStackId = c2.stackId || createStackFromCard(c2.id);
        } else {
          const s2 = ensureStack(dropOnId);
          if (!s2) return { ok: false, reason: "Missing drop stack" };
      
          // ch·∫∑n gom l√™n DECK c·ªë ƒë·ªãnh
          if (s2.id === "stack_deck") {
            return { ok: false, reason: "Cannot stack onto deck" };
          }
      
          dropStackId = s2.id;
        }
      
        if (!dropStackId) return { ok: false, reason: "No drop stack" };
        if (dragStackId && dragStackId === dropStackId) return { ok: true };
      
        const dropStack = ensureStack(dropStackId);
        if (!dropStack) return { ok: false, reason: "Drop stack missing (race)" };
        if (!canInteractStack(dropStack, fromId)) return { ok: false, reason: "No access" };
      
        // 3) Chu·∫©n b·ªã danh s√°ch card s·∫Ω attach l√™n top c·ªßa dropStack
        const moving = [...dragCardIds];
      
        // 4) B√≥c ngu·ªìn (x√≥a stack ngu·ªìn ho·∫∑c detach card kh·ªèi stack)
        if (dragTargetType === "stack") {
          const s = ensureStack(dragId);
          if (s && s.id !== "stack_deck") delete st.stacks[s.id];
        } else {
          detachFromStack(dragId);
        }
      
        // 5) Attach c√°c card l√™n top dropStack (gi·ªØ th·ª© t·ª±)
        for (let i = moving.length - 1; i >= 0; i--) {
          attachToStackTop(moving[i], dropStackId);
        }
      
        // 6) CH·ªêT owner/zone c·ªßa dropStack: kh√¥ng bao gi·ªù undefined
        if (dropStack.zone === ZONES.hand) {
          dropStack.owner = dropStack.owner ?? null;
      
          // n·∫øu ƒëang ·ªü hand m√† kh√¥ng c√≥ owner -> tr·∫£ v·ªÅ table
          if (!dropStack.owner) {
            dropStack.zone = ZONES.table;
            dropStack.owner = null;
          }
        } else {
          dropStack.owner = null;
        }
      
        // 7) Update to√†n b·ªô card trong dropStack theo stack m·ªõi
        for (const cid of (dropStack.cardIds || [])) {
          const c = ensureCard(cid);
          if (!c) continue;
      
          c.x = dropStack.x;
          c.y = dropStack.y;
          c.zone = dropStack.zone;
      
          // hand privacy: card trong hand c√≥ owner (string|null), kh√¥ng bao gi·ªù undefined
          c.owner = (dropStack.zone === ZONES.hand) ? dropStack.owner : null;
      
          // n·∫øu mu·ªën ƒë·ªïi CH·ª¶ TH·∫¨T khi ƒë∆∞a stack v√†o hand ng∆∞·ªùi kh√°c
          if (dropStack.zone === ZONES.hand && dropStack.owner) {
            c.ownerId = dropStack.owner;
          }
        }
      
        this.bumpVersion();
        return { ok: true };
      }


      case "unstack": {
        const {stackId} = action;
        const s = ensureStack(stackId);
        if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
        if ((s.cardIds?.length||0) <= 1) return {ok:true};

        const top = s.cardIds.shift();
        const c = ensureCard(top);
        if (!c) return {ok:false, reason:"Missing card"};

        c.stackId = null;
        c.x = s.x + randInt(-90,90);
        c.y = s.y + randInt(-60,60);
        c.zone = s.zone;
        
        // ‚úÖ ch·ªâ HAND m·ªõi c√≥ owner; c√≤n l·∫°i null ƒë·ªÉ ai c≈©ng thao t√°c
        c.owner = (s.zone === ZONES.hand) ? s.owner : null;

        this.bumpVersion();
        return {ok:true};
      }

      case "chat": {
        const text = (action.text || "").toString().slice(0, 300);
        if (!text.trim()) return {ok:true};
        st.chat.push({id: uid(), at: now(), fromId, text});
        if (st.chat.length > 120) st.chat.splice(0, st.chat.length - 120);
        this.bumpVersion();
        return {ok:true};
      }

      case "reset": {
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        const keepPlayers = deepClone(st.players);
        this.state = makeFreshTableState(st.roomCode, st.hostId);
        this.state.players = keepPlayers;
        this.bumpVersion();
        return {ok:true};
      }

      case "setAssets": {
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        st.assets.frontBase = (action.frontBase||"").trim();
        st.assets.backUrl = (action.backUrl||"").trim();
        this.bumpVersion();
        return {ok:true};
      }

      case "join": {
        // no-op; host side already addOrUpdatePlayer
        this.bumpVersion();
        return {ok:true};
      }

      case "startGame": {
        // host only
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        st.game = st.game || {};
        st.game.phase = "playing";
        st.game.startedAt = now();
        this.bumpVersion();
        return {ok:true};
      }

      case "set_stat_header": {
        if (st.hostId && fromId !== st.hostId) return { ok:false, reason:"Host only" };
      
        ensureUIState(st);
      
        const idx = (action.idx | 0);
        const value = (action.value ?? "").toString().slice(0, 12);
      
        if (idx < 0 || idx > 3) return { ok:false, reason:"Bad index" };
      
        while (st.ui.statHeaders.length < 4) st.ui.statHeaders.push("");
        st.ui.statHeaders[idx] = value;
      
        this.bumpVersion();
        return { ok:true };
      }
      
      case "set_stat": {
        ensureUIState(st);
      
        const playerId = action.playerId;
        const idx = (action.idx | 0);
        const value = (action.value ?? "").toString().slice(0, 12);
      
        if (idx < 0 || idx > 3) return { ok:false, reason:"Bad index" };
      
        // ‚úÖ ai c≈©ng s·ª≠a ƒë∆∞·ª£c ch·ªâ s·ªë c·ªßa b·∫•t k·ª≥ ai
        const p = (st.players || []).find(pp => pp.id === playerId);
        if (!p) return { ok:false, reason:"Player not found" };
      
        if (!st.ui.statsByPlayer[playerId]) st.ui.statsByPlayer[playerId] = ["", "", "", ""];
        while (st.ui.statsByPlayer[playerId].length < 4) st.ui.statsByPlayer[playerId].push("");
      
        st.ui.statsByPlayer[playerId][idx] = value;
      
        this.bumpVersion();
        return { ok:true };
      }

      default:
        return {ok:false, reason:"Unknown action"};
    }
  }
}

/* =========================================================
   9) Firebase (Auth + RTDB)
========================================================= */
const firebaseConfig = {
  apiKey: "AIzaSyBze3rgBuJ8Ex7c_yWnEVu76huNAuSFll8",
  authDomain: "tablegame-dc4a8.firebaseapp.com",
  databaseURL: "https://tablegame-dc4a8-default-rtdb.firebaseio.com",
  projectId: "tablegame-dc4a8",
  storageBucket: "tablegame-dc4a8.firebasestorage.app",
  messagingSenderId: "715606656270",
  appId: "1:715606656270:web:a1c4055c2d307201f1035f",
  measurementId: "G-KHWGKGT3GE"
};

let FB = { app:null, auth:null, db:null, user:null, uid:null, username:null };

function fbInitOnce(){
  if (FB.app) return;
  FB.app = firebase.initializeApp(firebaseConfig);
  FB.auth = firebase.auth();
  FB.db = firebase.database();
}

async function fbEnsureAuth(){
  fbInitOnce();
  if (!FB.auth.currentUser) await FB.auth.signInAnonymously();

  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  // ∆∞u ti√™n nameInput (lobby), n·∫øu r·ªóng th√¨ fallback "Player"
  FB.username = ((UI.nameInput?.value || "").trim().slice(0,18)) || "Player";

  const uref = FB.db.ref(`AllUser/${FB.uid}`);
  const snap = await uref.get();

  if (!snap.exists()){
    await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
  }else{
    const cur = snap.val() || {};
    if ((cur.username||"") !== FB.username){
      await uref.update({ username: FB.username });
    }
    if (!cur.setCard) await uref.update({ setCard:{} });
  }
}

async function fbAllocateRoomNo(){
  const db = FB.db;

  const freeRef = db.ref("RoomIndex/freeNos");
  const freeSnap = await freeRef.get();
  if (freeSnap.exists()){
    const obj = freeSnap.val() || {};
    const nums = Object.keys(obj).map(x=>parseInt(x,10)).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
    for (const n of nums){
      const oneRef = db.ref(`RoomIndex/freeNos/${n}`);
      const r = await oneRef.transaction((cur)=>{ if (cur === true) return null; return; });
      if (r.committed) return n;
    }
  }

  const nextRef = db.ref("RoomIndex/nextNo");
  const res = await nextRef.transaction((cur)=> (typeof cur !== "number" ? 1 : cur + 1));
  const newVal = res.snapshot.val();
  const roomNo = Math.max(1, newVal - 1);
  return roomNo;
}

async function fbReleaseRoomNo(roomNo){
  if (!roomNo) return;
  await FB.db.ref(`RoomIndex/freeNos/${roomNo}`).set(true);
}

class FirebaseTransport extends NetTransport {
  constructor(roomId){
    super();
    this.roomId = roomId; // FIX: tr∆∞·ªõc ƒë√¢y nhi·ªÅu b·∫°n vi·∫øt this.roomId=this.roomId
    this.roomRef = FB.db.ref(`AllRoom/${this.roomId}`);
    this.intentsRef = this.roomRef.child("intents");
    this.stateRef = this.roomRef.child("state");
    this.presRef = this.roomRef.child(`presence/${FB.uid}`);

    this._stateCb = null;
    this._intentsCb = null;
    this._connectedRef = FB.db.ref(".info/connected");
    this._connectedCb = null;
    this.onStatus({connected:true, mode:"firebase"});

    this.usersRef = this.roomRef.child("users");
    this._usersCb = null;
  }
  
  listenUsers(onUsers){
    this._usersCb = (snap)=> onUsers(snap.val() || {});
    this.usersRef.on("value", this._usersCb);
  }
  
  async attachPresence(){
    this._connectedCb = async (snap)=>{
      if (snap.val() === true){
        await this.presRef.set(true);
        this.presRef.onDisconnect().remove();
      }
    };
    this._connectedRef.on("value", this._connectedCb);
  }

  listenState(onState){
    this._stateCb = (snap)=> onState(snap.val());
    this.stateRef.on("value", this._stateCb);
  }

  listenIntentsAsHost(onIntent){
    this._intentsCb = (snap)=>{
      const v = snap.val();
      if (!v) return;
      onIntent(v, snap.key);
    };
    this.intentsRef.limitToLast(200).on("child_added", this._intentsCb);
  }

  async sendIntent(action){
    const payload = { fromUid: FB.uid, fromName: FB.username, at: Date.now(), action };
    await this.intentsRef.push(payload);
  }

  async writeState(state){
    await this.stateRef.set(state);
  }

  close(){
    try{
      if (this._stateCb) this.stateRef.off("value", this._stateCb);
      if (this._intentsCb) this.intentsRef.off("child_added", this._intentsCb);
      if (this._connectedCb) this._connectedRef.off("value", this._connectedCb);
      if (this._usersCb) this.usersRef.off("value", this._usersCb);
      this.presRef.remove();
    }catch(e){}
    this.onStatus({connected:false, mode:"firebase"});
  }
}

/* =========================================================
   10) Client State + Transport wiring
========================================================= */
const client = {
  selfId: uid(),
  selfName: "",
  roomCode: "",
  roomId: "",
  roomMeta: { roomNo:null, roomId:null },

  isHost: false,
  transport: null,
  host: null,
  authoritative: null,
  lastVersion: 0,
  selected: null,
  dragging: null,
};

function setNetBadge(text, color=null){
  if (!UI.netBadge) return;
  UI.netBadge.textContent = text;
  UI.netBadge.style.borderColor = color ? color : "rgba(255,255,255,.12)";
}

function getState(){
  if (client.isHost && client.host){
    return client.authoritative || redactStateForViewer(client.host.state, client.selfId);
  }
  return client.authoritative;
}

function setStatusUI(){
  const s = client.authoritative;
  if (!s){
    UI.roomBadge && (UI.roomBadge.textContent = "‚Äî");
    UI.meLine && (UI.meLine.textContent = "‚Äî");
    UI.hostLine && (UI.hostLine.textContent = "‚Äî");
    UI.playersLine && (UI.playersLine.textContent = "‚Äî");
    UI.chatBadge && (UI.chatBadge.textContent = "‚Äî");
    updateInspector();
    return;
  }

  UI.roomBadge && (UI.roomBadge.textContent = "ROOM " + s.roomCode);
  UI.chatBadge && (UI.chatBadge.textContent = "v" + s.version);

  const me = s.players.find(p=>p.id===client.selfId);
  if (UI.meLine){
    if (me){
      UI.meLine.innerHTML = `<span style="display:inline-flex;align-items:center;gap:8px">
        <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[me.color]};box-shadow:0 0 0 3px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.18)"></span>
        <span>${escapeHtml(me.name)} (${me.color})</span>
      </span>`;
    }else{
      UI.meLine.textContent = "(ch∆∞a v√†o ph√≤ng)";
    }
  }

  const hostP = s.players.find(p=>p.id===s.hostId);
  if (UI.hostLine){
    UI.hostLine.innerHTML = hostP
      ? `<span style="display:inline-flex;align-items:center;gap:8px">
          <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[hostP.color]};border:1px solid rgba(255,255,255,.18)"></span>
          <span>${escapeHtml(hostP.name)}</span>
        </span>`
      : "‚Äî";
  }

  if (UI.playersLine){
    UI.playersLine.innerHTML = s.players.map(p=>{
      return `<div style="display:flex;align-items:center;gap:8px;margin:2px 0">
        <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[p.color]};border:1px solid rgba(255,255,255,.18)"></span>
        <span style="color:rgba(233,236,255,.92)">${escapeHtml(p.name)}</span>
        <span style="color:rgba(233,236,255,.55);font-size:12px">(${p.color})</span>
        ${p.id===s.hostId ? `<span style="margin-left:auto;color:var(--muted);font-size:11px;border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:999px">HOST</span>` : ""}
      </div>`;
    }).join("");
  }

  updateInspector();

  // n·∫øu inspector ƒëang m·ªü m√† target m·∫•t -> hide, c√≤n th√¨ reposition
  const ins = document.getElementById("inspector");
  if (ins && ins.style.display === "block"){
    const sel = client.selected;
    if (!sel) hideInspectorPopup();
    else {
      const wp = getWorldPosOfTarget(s, sel);
      if (!wp) hideInspectorPopup();
      else positionInspectorNearTarget();
    }
  }

  // ===== Setup box UI =====
  const phase = s.game?.phase || "setup";
  if (UI.setupBox){
    UI.setupBox.style.display = (phase === "setup") ? "" : "none";
  }
  if (UI.setupPhaseLine){
    UI.setupPhaseLine.textContent = (phase === "setup")
      ? "ƒêang ·ªü ph√≤ng ch·ªù. Host ch·ªçn deck v√† b·∫•m B·∫Øt ƒë·∫ßu."
      : "ƒêang ch∆°i...";
  }
  
  // host controls: ch·ªâ host + firebase
  const hostCanSetup = client.isHost && (client.transport instanceof FirebaseTransport);
  if (UI.hostSetupControls){
    UI.hostSetupControls.style.display = hostCanSetup && phase === "setup" ? "" : "none";
    if (hostCanSetup && phase === "setup"){
      // auto load list 1 l·∫ßn n·∫øu dropdown r·ªóng
      if (UI.hostSetSelect && UI.hostSetSelect.options.length === 0){
        refreshHostSetSelect().catch(()=>{});
      }
    }
  }
  renderChat();
}

function sendToServer(msg){
  if (!client.transport) return;
  client.transport.send(msg);
}

async function sendIntentFirebase(action){
  if (!(client.transport instanceof FirebaseTransport)) return;
  await client.transport.sendIntent(action);
}

function sendIntent(action){
  if (UI.modeSelect?.value === "firebase"){
    sendIntentFirebase(action);
    return;
  }
  sendToServer({
    type: "intent",
    roomCode: client.roomCode,
    fromId: client.selfId,
    action,
    at: now(),
  });
}

function installTransport(t){
  if (client.transport) client.transport.close();
  client.transport = t;

  t.onStatus = (st) => {
    if (st.connected){
      if (st.mode === "firebase") setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
      else if (st.mode === "ws") setNetBadge("WS", "rgba(73,209,124,.55)");
      else setNetBadge("LOCAL", "rgba(73,209,124,.55)");
    } else {
      setNetBadge("OFFLINE", "rgba(255,255,255,.12)");
    }
  };

  t.onMessage = (msg) => {
    if (!msg) return;

    // Firebase transport kh√¥ng d√πng protocol local/ws ·ªü ƒë√¢y
    if (client.transport instanceof FirebaseTransport) return;

    // Local/WS
    if (msg.roomCode !== client.roomCode) return;

    if (msg.type === "hello" && client.isHost && client.host){
      const res = client.host.addOrUpdatePlayer({id: msg.fromId, name: msg.name});
      if (!res.ok){
        sendToServer({type:"deny", roomCode: client.roomCode, toId: msg.fromId, reason: res.reason});
        return;
      }
      client.host.applyIntent(client.host.hostId, {type:"chat", text:`${msg.name} joined.`});
      broadcastStateRaw();
      return;
    }

    if (msg.type === "bye" && client.isHost && client.host){
      client.host.removePlayer(msg.fromId);
      client.host.applyIntent(client.host.hostId, {type:"chat", text:`A player left.`});
      broadcastStateRaw();
      return;
    }

    if (msg.type === "deny"){
      if (msg.toId === client.selfId){
        toast("Kh√¥ng v√†o ƒë∆∞·ª£c ph√≤ng: " + (msg.reason || "Denied"));
        leaveRoom();
      }
      return;
    }

    if (msg.type === "intent"){
      if (client.isHost && client.host){
        const r = client.host.applyIntent(msg.fromId, msg.action);
        if (!r.ok && msg.fromId === client.selfId) toast("Action fail: " + r.reason);
        broadcastStateRaw();
      }
      return;
    }

    if (msg.type === "stateRaw"){
      if (client.isHost) return;
      const red = redactStateForViewer(msg.state, client.selfId);
      if (red && (red.version >= (client.lastVersion||0))){
        client.authoritative = red;
        client.lastVersion = red.version;
        setStatusUI();
      }
      return;
    }
  };
}

/* =========================================================
   11) Room: Local/WS create/join/leave
========================================================= */
function genRoomCode(){
  const a = Math.random().toString(36).slice(2, 6).toUpperCase();
  const b = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `${a}-${b}`;
}

function readInputs(){
  client.selfName = (UI.nameInput?.value || "").trim().slice(0,18) || "Player";
  client.roomCode = (UI.roomInput?.value || "").trim().toUpperCase();
  if (!client.roomCode) client.roomCode = genRoomCode();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;
}

function makeTransportForCurrentMode(){
  const mode = UI.modeSelect?.value || "local";

  if (mode === "ws"){
    const url = (UI.wsUrlInput?.value || "").trim() || "ws://localhost:8080";
    return new WebSocketTransport(url);
  }

  try{
    if (typeof BroadcastChannel !== "undefined"){
      return new LocalBroadcastTransport(client.roomCode, client.selfId);
    }
  }catch(e){}
  return new LocalStorageTransport(client.roomCode, client.selfId);
}

function broadcastStateRaw(){
  if (!client.isHost || !client.host) return;
  const st = client.host.state;

  sendToServer({type:"stateRaw", roomCode: client.roomCode, state: deepClone(st), at: now()});

  client.authoritative = redactStateForViewer(st, client.selfId);
  client.lastVersion = client.authoritative.version;
  setStatusUI();
}

function createRoomAsHost_LocalOrWS(){
  readInputs();

  client.isHost = true;
  client.host = new HostController(client.roomCode, client.selfId);

  const t = makeTransportForCurrentMode();
  installTransport(t);

  // host add itself
  client.host.addOrUpdatePlayer({ id: client.selfId, name: client.selfName });

  client.authoritative = redactStateForViewer(client.host.state, client.selfId);
  client.lastVersion = client.authoritative.version;

  setStatusUI();
  broadcastStateRaw();

  toast("ƒê√£ t·∫°o ph√≤ng (Host)");
  goMatch();
}

function joinRoomAsClient_LocalOrWS(){
  readInputs();
  client.isHost = false;
  client.host = null;

  const t = makeTransportForCurrentMode();
  installTransport(t);

  sendToServer({type:"hello", roomCode: client.roomCode, fromId: client.selfId, name: client.selfName, at: now()});
  toast("ƒêang v√†o ph√≤ng...");
  goMatch();
}

function leaveRoom(){
  if (!client.roomCode) return;

  try{
    if (!client.isHost){
      sendToServer({type:"bye", roomCode: client.roomCode, fromId: client.selfId, at: now()});
    }
  }catch(e){}

  if (client.transport) client.transport.close();
  client.transport = null;
  client.isHost = false;
  client.host = null;
  client.authoritative = null;
  client.lastVersion = 0;
  client.selected = null;
  client.dragging = null;

  setStatusUI();
  setNetBadge("OFFLINE");
}

/* =========================================================
   12) Room: Firebase create/join
========================================================= */
async function createRoomAsHost_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  const roomNo = await fbAllocateRoomNo();
  const roomId = `room${roomNo}`;

  client.roomId = roomId.toLowerCase();
  client.roomCode = roomId.toUpperCase();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;

  client.isHost = true;
  client.host = new HostController(client.roomCode, FB.uid);
  client.host.addOrUpdatePlayer({ id: FB.uid, name: FB.username });

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.set({
    meta: {
      roomNo,
      roomId,
      hostUid: FB.uid,
      status: "active",
      createdAt: Date.now(),
      maxPlayers: 6,
      deckSource: null,
      deckBackUrl: "",
    },
    presence: {},
    users: {},
    intents: {},
    state: client.host.state,
  });

  await roomRef.child(`users/${FB.uid}`).set({ username: FB.username, seat: 0, atk: 0, def: 0, hp: 20 });

  client.authoritative = redactStateForViewer(client.host.state, FB.uid);
  client.lastVersion = client.authoritative.version;
  setStatusUI();

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);
  t.listenUsers((users)=>{
    // nh√©t v√†o authoritative ƒë·ªÉ overlay ƒë·ªçc ƒë∆∞·ª£c
    if (!client.authoritative) client.authoritative = {};
    client.authoritative._users = users;
  });
  await t.attachPresence();

  t.listenIntentsAsHost(async (msg, intentKey)=>{
    const action = msg.action;
    const fromId = msg.fromUid;

    client.host.addOrUpdatePlayer({ id: fromId, name: msg.fromName });

    const r = client.host.applyIntent(fromId, action);
    if (!r.ok && fromId === FB.uid) toast("Action fail: " + r.reason);

    await t.writeState(client.host.state);

    try{ await FB.db.ref(`AllRoom/${client.roomId}/intents/${intentKey}`).remove(); }catch(e){}
  });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    if (client.isHost && client.host){
      client.host.state = st;
      client.authoritative = redactStateForViewer(st, FB.uid);
    } else {
      client.authoritative = redactStateForViewer(st, FB.uid);
    }
    client.lastVersion = st.version || client.lastVersion;
    setStatusUI();
  });

  toast(`ƒê√£ t·∫°o room: ${roomId}`);
  client.roomMeta = { roomNo, roomId };

  installFirebaseRoomCleanupAsHost(client.roomId, roomNo);

  goMatch();
}

async function joinRoomAsClient_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  readInputs();
  client.roomId = client.roomCode.toLowerCase();
  if (!client.roomId.startsWith("room")) return toast("Nh·∫≠p room d·∫°ng: room1 / ROOM1");

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  const metaSnap = await roomRef.child("meta").get();
  if (!metaSnap.exists()) return toast("Room kh√¥ng t·ªìn t·∫°i / ƒë√£ ƒë√≥ng");

  await roomRef.child(`users/${FB.uid}`).set({ username: FB.username, seat: -1, atk: 0, def: 0, hp: 20 });

  client.isHost = false;
  client.host = null;

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);

  t.listenUsers((users)=>{
    // nh√©t v√†o authoritative ƒë·ªÉ overlay ƒë·ªçc ƒë∆∞·ª£c
    if (!client.authoritative) client.authoritative = {};
    client.authoritative._users = users;
  });
  
  await t.attachPresence();

  await t.sendIntent({ type: "join" });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    const red = redactStateForViewer(st, FB.uid);
    if (!red) return;
    client.authoritative = red;
    client.lastVersion = red.version || client.lastVersion;
    setStatusUI();
  });

  toast("ƒê√£ v√†o " + client.roomCode);
  goMatch();
}

function installFirebaseRoomCleanupAsHost(roomId, roomNo){
  const presRef = FB.db.ref(`AllRoom/${roomId}/presence`);
  presRef.on("value", async (snap)=>{
    if (!client.isHost) return;
    const v = snap.val() || {};
    const keys = Object.keys(v);
    if (keys.length === 0){
      try{ await FB.db.ref(`AllRoom/${roomId}`).remove(); }catch(e){}
      try{ await fbReleaseRoomNo(roomNo); }catch(e){}
    }
  });
}

/* =========================================================
   13) Deck/SetCard Modal (RTDB)
========================================================= */
const DECKUI = {
  modal: document.getElementById("deckModal"),
  openBtn: document.getElementById("openDeckBtn"),
  closeBtn: document.getElementById("closeDeckBtn"),
  userBadge: document.getElementById("deckUserBadge"),

  setSelect: document.getElementById("setSelect"),
  newSetBtn: document.getElementById("newSetBtn"),
  loadSetBtn: document.getElementById("loadSetBtn"),
  deleteSetBtn: document.getElementById("deleteSetBtn"),

  setNameInput: document.getElementById("setNameInput"),
  backUrlInput: document.getElementById("setBackUrlInput"),
  addCardBtn: document.getElementById("addCardUrlBtn"),
  list: document.getElementById("cardUrlList"),

  saveBtn: document.getElementById("saveSetBtn"),
};

let deckSetsCache = {};
let deckCurrentSetId = null;

function openDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "flex"; }
function closeDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "none"; }

function makeCardTypeRow({frontUrl="", count=1, name=""} = {}){
  const row = document.createElement("div");
  row.className = "card-url-row";

  const inpName = document.createElement("input");
  inpName.className = "mono";
  inpName.placeholder = "T√™n l√° b√†i";
  inpName.value = name;
  inpName.style.width = "40%";

  const inpUrl = document.createElement("input");
  inpUrl.className = "mono";
  inpUrl.placeholder = "https://.../front.png";
  inpUrl.value = frontUrl;
  inpUrl.style.width = "40%";

  const inpCount = document.createElement("input");
  inpCount.type = "number";
  inpCount.min = "1";
  inpCount.step = "1";
  inpCount.value = String(Math.max(1, parseInt(count,10)||1));
  inpCount.style.width = "8%";

  const del = document.createElement("button");
  del.className = "danger";
  del.textContent = "X";
  del.onclick = ()=> row.remove();

  row.appendChild(inpName);
  row.appendChild(inpUrl);
  row.appendChild(inpCount);
  row.appendChild(del);
  return row;
}


function fillEditorFromSet(setId, data){
  deckCurrentSetId = setId;
  DECKUI.setNameInput.value = data?.name || "";
  DECKUI.backUrlInput.value = data?.backUrl || "";
  DECKUI.list.innerHTML = "";

  const cardsObj = data?.cards || {};
  const types = Object.values(cardsObj);

  for (const t of types){
    DECKUI.list.appendChild(makeCardTypeRow({
      name: t.name || "",
      frontUrl: t.frontUrl || "",
      count: t.count || 1
    }));
  }
  if (types.length === 0){
    DECKUI.list.appendChild(makeCardTypeRow());
  }
}
function editorToSetData(){
  const name = (DECKUI.setNameInput.value||"").trim() || "Untitled";
  const backUrl = (DECKUI.backUrlInput.value||"").trim();

  const rows = [...DECKUI.list.querySelectorAll(".card-url-row")];

  const cards = {};
  let idx = 1;
  for (const row of rows){
    const inputs = row.querySelectorAll("input");
    const rowName  = (inputs[0]?.value || "").trim();
    const frontUrl = (inputs[1]?.value || "").trim();
    const count    = Math.max(1, parseInt(inputs[2]?.value || "1", 10) || 1);

    if (!frontUrl) continue;

    cards["t"+idx] = { name: rowName, frontUrl, count };
    idx++;
  }

  return { name, backUrl, cards, updatedAt: Date.now() };
}


async function refreshSetList(){
  await fbEnsureAuth();
  if (DECKUI.userBadge) DECKUI.userBadge.textContent = `UID: ${FB.uid.slice(0,6)}... | ${FB.username}`;

  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard`);
  const snap = await ref.get();
  deckSetsCache = snap.val() || {};

  if (!DECKUI.setSelect) return;

  DECKUI.setSelect.innerHTML = "";
  const ids = Object.keys(deckSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(ch∆∞a c√≥ set)";
    DECKUI.setSelect.appendChild(op);
    deckCurrentSetId = null;
    fillEditorFromSet(null, {name:"", backUrl:"", cards:{}});
    return;
  }

  for (const id of ids){
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${deckSetsCache[id]?.name || id} (${Object.keys(deckSetsCache[id]?.cards||{}).length})`;
    DECKUI.setSelect.appendChild(op);
  }

  const pick = (deckCurrentSetId && deckSetsCache[deckCurrentSetId]) ? deckCurrentSetId : ids[0];
  DECKUI.setSelect.value = pick;
  fillEditorFromSet(pick, deckSetsCache[pick]);
}

async function createNewSet(){
  await fbEnsureAuth();
  const newId = "set_" + uid().slice(0,8);
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${newId}`);
  await ref.set({ name:"New Set", backUrl:"", cards:{}, createdAt: Date.now(), updatedAt: Date.now() });
  await refreshSetList();
  if (DECKUI.setSelect) DECKUI.setSelect.value = newId;
  fillEditorFromSet(newId, deckSetsCache[newId]);
}

async function saveCurrentSet(){
  await fbEnsureAuth();
  if (!deckCurrentSetId) await createNewSet();
  const data = editorToSetData();
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${deckCurrentSetId}`);
  await ref.update(data);
  toast("ƒê√£ l∆∞u set");
  await refreshSetList();
}

async function deleteCurrentSet(){
  await fbEnsureAuth();
  const id = DECKUI.setSelect?.value;
  if (!id) return;
  await FB.db.ref(`AllUser/${FB.uid}/setCard/${id}`).remove();
  toast("ƒê√£ x√≥a set");
  deckCurrentSetId = null;
  await refreshSetList();
}

async function loadSelectedSet(){
  const id = DECKUI.setSelect?.value;
  if (!id || !deckSetsCache[id]) return;
  fillEditorFromSet(id, deckSetsCache[id]);
  toast("ƒê√£ load set v√†o editor");
}

/* =========================================================
   14) Images cache
========================================================= */
const imgCache = new Map();
function loadImg(url){
  if (!url) return null;
  if (imgCache.has(url)) return imgCache.get(url);
  const im = new Image();
  im.src = url;
  imgCache.set(url, im);
  return im;
}

/* =========================================================
   15) Chat
========================================================= */
const CHATUI = {
  mode: "all", // "all" | "team"
  lastCount: 0,
};

function fmtTime(ts){
  try{
    const d = new Date(ts);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }catch(e){
    return "";
  }
}

function getPlayerById(s, id){
  return (s.players || []).find(p => p && p.id === id) || null;
}

function renderChat(){
  const s = getState();
  if (!s) return;

  const log = document.getElementById("chatLog");
  const badge = document.getElementById("chatBadge");
  if (!log || !badge) return;

  const msgs = (s.chat || []);
  badge.textContent = String(msgs.length);

  // N·∫øu b·∫°n mu·ªën TEAM filter th·∫≠t th√¨ filter ·ªü ƒë√¢y.
  const visible = msgs; // CHATUI.mode === "team" ? msgs.filter(...) : msgs;

  // Re-render ƒë∆°n gi·∫£n (v√¨ max 120 msg v·∫´n nh·∫π)
  log.innerHTML = "";

  // class age: l√†m m·ªù tin nh·∫Øn c≈©
  const n = visible.length;

  for (let i = 0; i < n; i++){
    const m = visible[i];
    const p = getPlayerById(s, m.fromId);
    const name = p?.name || "Player";
    const dot = p ? (COLORS?.[p.color] || "rgba(255,255,255,.55)") : "rgba(255,255,255,.35)";
    const time = m.at ? fmtTime(m.at) : "";

    let ageCls = "";
    const age = n - i;
    if (age > 18) ageCls = "age4";
    else if (age > 12) ageCls = "age3";
    else if (age > 7) ageCls = "age2";

    const row = document.createElement("div");
    row.className = `msg ${ageCls}`;
    row.innerHTML = `
      <div class="dot" style="background:${dot}"></div>
      <div class="bubble">
        <div class="meta">
          <span class="name">${escapeHtml(name)}</span>
          <span class="time">${escapeHtml(time)}</span>
        </div>
        <div class="text">${escapeHtml(m.text || "")}</div>
      </div>
    `;
    log.appendChild(row);
  }

  // auto scroll khi c√≥ tin m·ªõi (nh∆∞ LoL)
  if (msgs.length !== CHATUI.lastCount){
    log.scrollTop = log.scrollHeight;
    CHATUI.lastCount = msgs.length;
  }
}

// toggle ALL/TEAM
(function initChatToggle(){
  const tg = document.getElementById("chatToggle");
  if (!tg) return;
  tg.addEventListener("click", (e)=>{
    const btn = e.target.closest("button[data-mode]");
    if (!btn) return;
    CHATUI.mode = btn.dataset.mode;

    tg.querySelectorAll("button").forEach(b=>b.classList.toggle("active", b===btn));
    renderChat();
  });
})();

// submit form -> send intent
(function initChatForm(){
  const form = document.getElementById("chatForm");
  const input = document.getElementById("chatInput");
  if (!form || !input) return;

  form.addEventListener("submit", (e)=>{
    e.preventDefault();
    const text = (input.value || "").trim();
    if (!text) return;
    input.value = "";
    sendIntent({ type:"chat", text });
  });

  // Enter g·ª≠i, Shift+Enter xu·ªëng d√≤ng (LoL style th∆∞·ªùng kh√¥ng multiline, nh∆∞ng b·∫°n c√≥ th·ªÉ gi·ªØ)
})();


/* =========================================================
   16) Input / HitTest / Drag
========================================================= */
function mousePos(ev){
  const rect = canvas.getBoundingClientRect();
  return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
}

function cardZ(c){
  let z = 10;
  if (c.zone === ZONES.table) z = 50;
  if (c.zone === ZONES.discard) z = 50;
  if (c.zone === ZONES.hand) z = 80;
  if (c.zone === ZONES.deck) z = 40;
  return z + (c.order||0)*0.001;
}
  
function stackZ(s){
  let z = 12;
  if (s.zone === ZONES.table) z = 55;
  if (s.zone === ZONES.hand) z = 85;
  if (s.zone === ZONES.deck) z = 42;
  if (s.zone === ZONES.discard) z = 55;
  return z + (s.cardIds?.length||0)*0.01;
}

function listDrawableObjects(state){
  const out = [];
  if (!state) return out;

  for (const sid in state.stacks){
    const s = state.stacks[sid];
    if (!s) continue;
    out.push({type:"stack", id:sid, x:s.x, y:s.y, zone:s.zone, owner:s.owner, z: stackZ(s)});
  }
  for (const cid in state.cards){
    const c = state.cards[cid];
    if (!c || c.stackId) continue;
    out.push({type:"card", id:cid, x:c.x, y:c.y, zone:c.zone, owner:c.owner, z: cardZ(c)});
  }
  out.sort((a,b)=>a.z-b.z);
  return out;
}

function hitTest(worldX, worldY){
  const state = getState();
  if (!state) return null;

  const objs = listDrawableObjects(state);
  for (let i=objs.length-1; i>=0; i--){
    const o = objs[i];
    const w = CARD.w, h = CARD.h;
    const x0 = o.x - w/2, y0 = o.y - h/2;
    if (worldX >= x0 && worldX <= x0+w && worldY >= y0 && worldY <= y0+h){
      if (o.zone === ZONES.hand && o.owner && o.owner !== client.selfId) return null;
      return {type:o.type, id:o.id};
    }
  }
  return null;
}

function calcDragOffset(state, target, p){
  if (target.type === "card"){
    const c = state.cards[target.id];
    if (!c) return {dx:0,dy:0};
    return {dx: p.x - c.x, dy: p.y - c.y};
  } else {
    const s = state.stacks[target.id];
    if (!s) return {dx:0,dy:0};
    return {dx: p.x - s.x, dy: p.y - s.y};
  }
}

canvas.addEventListener("mousedown", (ev)=>{
  const st = getState();
  if (!st) return;

  const p = toWorld(mousePos(ev));
  const hit = hitTest(p.x, p.y);

  if (hit){
    client.selected = hit;
    updateInspector();
    client.dragging = { target: hit, start: p, offset: calcDragOffset(st, hit, p), moved:false };
  }else{
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
  }
});

addEventListener("mousemove", (ev)=>{
  if (!client.dragging) return;
  hideInspectorPopup();
  const st = getState();
  if (!st) return;
  const p = toWorld(mousePos(ev));
  client.dragging.moved = true;
  client.dragging.cur = p;
});

addEventListener("mouseup", (ev)=>{
  if (!client.dragging) return;

  const st = getState();
  const drag = client.dragging;
  client.dragging = null;
  if (!st) return;

  const p = toWorld(mousePos(ev));

  if (!drag.moved){
    showInspectorPopup();
    return;
  }

  const hit = hitTest(p.x, p.y);
  if (hit && !(hit.type===drag.target.type && hit.id===drag.target.id)){
    hideInspectorPopup();
    sendIntent({ type:"stack", dragTargetType: drag.target.type, dragId: drag.target.id, dropOnType: hit.type, dropOnId: hit.id });
    return;
  }

  hideInspectorPopup();
  sendIntent({
    type:"move",
    targetType: drag.target.type,
    id: drag.target.id,
    x: p.x - (drag.offset?.dx||0),
    y: p.y - (drag.offset?.dy||0),
  });
});

/* =========================================================
   17) Keyboard + Inspector buttons (n√∫t b·∫•m, t∆∞∆°ng t√°c)
========================================================= */
if (INS.btnFlip) INS.btnFlip.onclick = ()=>{
  if (!client.selected) return;
  sendIntent({type:"flip", targetType: client.selected.type, id: client.selected.id});
};
if (INS.btnDiscard) INS.btnDiscard.onclick = ()=>{
  if (!client.selected) return;
  sendIntent({type:"discard", targetType: client.selected.type, id: client.selected.id});
};
if (INS.btnUnstack) INS.btnUnstack.onclick = ()=>{
  const sel = client.selected;
  if (!sel || sel.type!=="stack") return;
  sendIntent({type:"unstack", stackId: sel.id});
};
if (INS.btnShuffle) INS.btnShuffle.onclick = ()=>{
  const sel = client.selected;
  if (sel?.type==="stack") sendIntent({type:"shuffle", stackId: sel.id});
  else sendIntent({type:"shuffle", stackId:"stack_deck"});
};

addEventListener("keydown", (ev)=>{
  if (ev.target && (ev.target.tagName==="INPUT" || ev.target.tagName==="TEXTAREA")) return;

  const st = getState();
  if (!st) return;

  const key = ev.key.toLowerCase();
  if (key === "escape"){
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
    return;
  }
  if (key === "q"){
    sendIntent({type:"draw"});
    toast("Draw 1");
    return;
  }
  if (key === "w"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"flip", targetType: sel.type, id: sel.id});
    return;
  }
  if (key === "e"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"shuffle", stackId: sel.id});
    else sendIntent({type:"shuffle", stackId:"stack_deck"});
    return;
  }
  if (key === "r"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"unstack", stackId: sel.id});
    return;
  }
  if (key === "t"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"discard", targetType: sel.type, id: sel.id});
    return;
  }
});

/* =========================================================
   18) Rendering helpers + main loop
========================================================= */
function rr(x,y,w,h,r){
  ctx.beginPath();
  const r2 = Math.min(r, w/2, h/2);
  ctx.moveTo(x+r2, y);
  ctx.arcTo(x+w, y, x+w, y+h, r2);
  ctx.arcTo(x+w, y+h, x, y+h, r2);
  ctx.arcTo(x, y+h, x, y, r2);
  ctx.arcTo(x, y, x+w, y, r2);
  ctx.closePath();
}

function drawZone(rect, label, subtitle="", highlight=false, tint=null){
  const s0 = toScreen({x:rect.x, y:rect.y});
  const s1 = toScreen({x:rect.x+rect.w, y:rect.y+rect.h});
  const x = s0.x, y = s0.y, w = (s1.x-s0.x), h = (s1.y-s0.y);

  ctx.save();

  rr(x,y,w,h,18);

  // base
  ctx.globalAlpha = highlight ? 0.85 : 0.35;
  ctx.fillStyle = highlight ? "rgba(122,162,255,.22)" : "rgba(0,0,0,.10)";
  ctx.fill();

  // tint color for player zone
  if (tint){
    ctx.globalAlpha = highlight ? 0.18 : 0.10;
    ctx.fillStyle = tint;
    ctx.fill();
  }

  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(233,236,255,.85)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText(label, x+12, y+18);

  if (subtitle){
    ctx.globalAlpha = 0.6;
    ctx.fillText(subtitle, x+12, y+34);
  }

  ctx.restore();
}

function drawCardAtScreen(
  cx, cy,
  faceUp,
  frontSeed,
  accent=null,
  isSelected=false,
  isStackTop=false,
  stackCount=0,
  frontUrl="",
  backUrl=""
){
  const w = CARD.w * camera.scale;
  const h = CARD.h * camera.scale;
  const x = cx - w/2, y = cy - h/2;
  const r = CARD.r * camera.scale;

  ctx.save();

  ctx.globalAlpha = 0.35;
  rr(x+4, y+6, w, h, r);
  ctx.fillStyle = "rgba(0,0,0,.65)";
  ctx.fill();
  ctx.globalAlpha = 1;

  rr(x, y, w, h, r);
  ctx.fillStyle = faceUp ? "rgba(255,255,255,.07)" : "rgba(0,0,0,.20)";
  ctx.fill();
  ctx.strokeStyle = isSelected ? "rgba(122,162,255,.85)" : "rgba(255,255,255,.14)";
  ctx.lineWidth = isSelected ? 2 : 1;
  ctx.stroke();

  if (accent){
    ctx.globalAlpha = 0.75;
    rr(x+8, y+8, w-16, 14*camera.scale, 9*camera.scale);
    ctx.fillStyle = accent;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  const url = faceUp ? (frontUrl || "") : (backUrl || "");
  const img = url ? loadImg(url) : null;

  if (img && img.complete && img.naturalWidth > 0){
    const padX = 6*camera.scale;
    const topPad = 28*camera.scale;
    const botPad = 10*camera.scale;
    rr(x+padX, y+topPad, w-2*padX, h-topPad-botPad, 10*camera.scale);
    ctx.clip();
    ctx.globalAlpha = 0.95;

    const iw = img.naturalWidth, ih = img.naturalHeight;
    const availW = w-2*padX;
    const availH = h-topPad-botPad;
    const scale = Math.min(availW/iw, availH/ih);
    const dw = iw*scale, dh = ih*scale;

    ctx.drawImage(img, x + (w-dw)/2, y + topPad + (availH-dh)/2, dw, dh);
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = "rgba(233,236,255,.9)";
    ctx.font = `${Math.max(10, 12*camera.scale)}px ui-monospace, monospace`;
    if (faceUp && frontSeed){
      const n = String(frontSeed).padStart(2,"0");
      ctx.fillText("CARD " + n, x + 12*camera.scale, y + 34*camera.scale);
    } else {
      ctx.fillText("BACK", x + 12*camera.scale, y + 34*camera.scale);
    }
  }

  if (isStackTop && stackCount>1){
    ctx.globalAlpha = 0.95;
    rr(x+w-34*camera.scale, y+10*camera.scale, 24*camera.scale, 18*camera.scale, 8*camera.scale);
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.stroke();
    ctx.fillStyle = "rgba(233,236,255,.86)";
    ctx.font = `${Math.max(10, 11*camera.scale)}px ui-monospace, monospace`;
    ctx.fillText(String(stackCount), x+w-28*camera.scale, y+24*camera.scale);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(0,0,0,.25)";
  ctx.fillRect(0,0,innerWidth,innerHeight);
  ctx.restore();

  const rects = zoneRects();
  const s = getState();
  if (!s){
    requestAnimationFrame(draw);
    return;
  }

  const seatName = (seat)=>{
    const p = s.players.find(pp=>pp.seat===seat);
    return p ? p.name : "(empty)";
  };

  drawZone(rects.table, "TABLE", "", false);

  const selfId = client.selfId ?? client.playerId ?? client.uid ?? FB?.uid;
  const me = s.players.find(p => p.id === selfId);
  const mySeat = me ? (Number(me.seat) | 0) : -1;
  
  const playerBySeat = (seat)=> s.players.find(pp => (Number(pp.seat)|0) === seat) || null;
  const tintBySeat = (seat)=>{
    const p = playerBySeat(seat);
    return p ? (COLORS?.[p.color] ?? p.color ?? null) : null;
  };
  
  drawZone(rects.handTopLeft,     "Ng∆∞·ªùi ch∆°i 1", seatName(0), mySeat===0, tintBySeat(0));
  drawZone(rects.handTopRight,    "Ng∆∞·ªùi ch∆°i 3", seatName(2), mySeat===2, tintBySeat(2));
  drawZone(rects.handBottomLeft,  "Ng∆∞·ªùi ch∆°i 2", seatName(1), mySeat===1, tintBySeat(1));
  drawZone(rects.handBottomRight, "Ng∆∞·ªùi ch∆°i 4", seatName(3), mySeat===3, tintBySeat(3));
  drawZone(rects.handRightTop,    "Ng∆∞·ªùi ch∆°i 5", seatName(4), mySeat===4, tintBySeat(4));
  drawZone(rects.handRightBottom, "Ng∆∞·ªùi ch∆°i 6", seatName(5), mySeat===5, tintBySeat(5));

  drawZone(rects.deck, "DECK");
  drawZone(rects.discard, "DISCARD");

  const objs = listDrawableObjects(s);
  const backUrlDefault = s.assets?.backUrl || "";

  for (const o of objs){
    const isSelected = client.selected && client.selected.type === o.type && client.selected.id === o.id;

    let wx = o.x, wy = o.y;
    if (client.dragging &&
        client.dragging.target.type === o.type &&
        client.dragging.target.id === o.id &&
        client.dragging.cur){
      wx = client.dragging.cur.x - (client.dragging.offset?.dx||0);
      wy = client.dragging.cur.y - (client.dragging.offset?.dy||0);
    }

    const sp = toScreen({x: wx, y: wy});

    if (o.type === "card"){
      const c = s.cards[o.id];
      if (!c) continue;

      const owner = s.players.find(p=>p.id===(c.ownerId || c.owner));
      const accent = owner ? COLORS[owner.color] : null;

      const frontUrl = c.frontUrl || (s.assets?.frontBase ? (s.assets.frontBase + c.id + ".png") : "");
      drawCardAtScreen(sp.x, sp.y, !!c.faceUp, c.frontSeed, accent, isSelected, false, 0, frontUrl, backUrlDefault);
    } else {
      const stack = s.stacks[o.id];
      if (!stack) continue;

      const topId = stack.cardIds?.[0];
      const top = topId ? s.cards[topId] : null;

      const topOwnerId = top?.ownerId || top?.owner || stack.owner;
      const owner = s.players.find(p=>p.id===topOwnerId);
      const accent = owner ? COLORS[owner.color] : null;

      if (top){
        const frontUrl = top.frontUrl || (s.assets?.frontBase ? (s.assets.frontBase + topId + ".png") : "");
        drawCardAtScreen(sp.x, sp.y, !!top.faceUp, top.frontSeed, accent, isSelected, true, stack.cardIds.length, frontUrl, backUrlDefault);

        if (stack.cardIds.length > 1){
          ctx.save();
          ctx.globalAlpha = 0.25;
          for (let i=1; i<Math.min(4, stack.cardIds.length); i++){
            const dx = i * 2 * camera.scale;
            const dy = i * 2 * camera.scale;
            drawCardAtScreen(sp.x+dx, sp.y+dy, false, 0, null, false, false, 0, "", backUrlDefault);
          }
          ctx.restore();
        }
      }
    }
  }
  requestAnimationFrame(draw);
  renderStatusBoard();
}
requestAnimationFrame(draw);

const _statInputs = new Map(); // key: uid

function seatRectKey(seat){
  switch (seat){
    case 0: return "handTopLeft";
    case 1: return "handBottomLeft";
    case 2: return "handTopRight";
    case 3: return "handBottomRight";
    case 4: return "handRightTop";
    case 5: return "handRightBottom";
    default: return null;
  }
}

function ensureStatBoxForUser(userId){
  if (_statInputs.has(userId)) return _statInputs.get(userId);

  const box = document.createElement("div");
  box.className = "statBox";

  const dot = document.createElement("div");
  dot.className = "dot";

  const name = document.createElement("div");
  name.className = "name";
  name.textContent = "Player";

  const mkField = (labelText)=>{
    const wrap = document.createElement("div");
    const lab = document.createElement("label");
    lab.textContent = labelText;
    const inp = document.createElement("input");
    inp.type = "number";
    inp.step = "1";
    inp.value = "0";
    wrap.appendChild(lab);
    wrap.appendChild(inp);
    return {wrap, inp};
  };

  const atk = mkField("ATK");
  const def = mkField("DEF");
  const hp  = mkField("HP");

  box.appendChild(dot);
  box.appendChild(name);
  box.appendChild(atk.wrap);
  box.appendChild(def.wrap);
  box.appendChild(hp.wrap);

  // realtime update to RTDB (ai c≈©ng s·ª≠a)
  const commit = async (uid, patch)=>{
    if (!(client.transport instanceof FirebaseTransport)) return;
    if (!client.roomId) return;
    try{
      await FB.db.ref(`AllRoom/${client.roomId}/users/${uid}`).update(patch);
    }catch(e){}
  };

  const bind = (inp, key)=> {
    inp.addEventListener("change", ()=>{
      const v = parseInt(inp.value,10);
      commit(userId, {[key]: Number.isFinite(v) ? v : 0});
    });
    inp.addEventListener("keydown", (e)=>{
      if (e.key === "Enter"){
        e.preventDefault();
        inp.blur();
      }
    });
  };

  bind(atk.inp, "atk");
  bind(def.inp, "def");
  bind(hp.inp,  "hp");

  STATS_UI.root && STATS_UI.root.appendChild(box);

  const obj = { box, dot, name, atk: atk.inp, def: def.inp, hp: hp.inp };
  _statInputs.set(userId, obj);
  return obj;
}

const STATUS = {
  el: document.getElementById("statusBoard"),
  body: document.getElementById("sbBody"),
  toggle: document.getElementById("sbToggle"),
  lastSig: "",
  bound: false,
  editing: false,
  _timer: null,
  collapsed: true,
};

function isHost(s){
  // t√πy b·∫°n ƒëang l∆∞u host th·∫ø n√†o
  // ∆∞u ti√™n state.hostId, n·∫øu kh√¥ng c√≥ th√¨ client.isHost
  return (s?.hostId && client.selfId === s.hostId) || !!client.isHost;
}

function ensureStatsRow(s, playerId){
  s.ui = s.ui || {};
  s.ui.statHeaders = s.ui.statHeaders || ["ATK","DEF","HP","COIN"];
  s.ui.statsByPlayer = s.ui.statsByPlayer || {};
  if (!s.ui.statsByPlayer[playerId]) s.ui.statsByPlayer[playerId] = ["", "", "", ""];
  // ƒë·∫£m b·∫£o ƒë·ªß 4 √¥
  for (let i=0;i<4;i++){
    if (s.ui.statsByPlayer[playerId][i] == null) s.ui.statsByPlayer[playerId][i] = "";
  }
  return s.ui.statsByPlayer[playerId];
}
  
function initStatusBoardUI(){
  if (!STATUS.el || !STATUS.body || STATUS.bound) return;
  STATUS.bound = true;

  // toggle +/-
  if (STATUS.toggle){
    const apply = ()=>{
      STATUS.el.classList.toggle("collapsed", STATUS.collapsed);
      STATUS.toggle.textContent = STATUS.collapsed ? "+" : "‚àí";
    };
    STATUS.toggle.addEventListener("click", ()=>{
      STATUS.collapsed = !STATUS.collapsed;
      apply();
    });
    apply();
  }

  // event delegation: bind 1 l·∫ßn tr√™n body
  STATUS.body.addEventListener("input", (e)=>{
    const inp = e.target.closest("input[data-kind]");
    if (!inp) return;

    const s = getState();
    if (!s) return;

    const host = isHost(s);
    const kind = inp.dataset.kind;

    if (kind === "header"){
      if (!host) return;
      const idx = Number(inp.dataset.idx) | 0;
      const value = (inp.value ?? "").toString().slice(0, 12);
      sendIntentDebounced({ type:"set_stat_header", idx, value });
    } else if (kind === "stat"){
      const pid = inp.dataset.pid;
      const idx = Number(inp.dataset.idx) | 0;
      const value = (inp.value ?? "").toString().slice(0, 12);
      sendIntentDebounced({ type:"set_stat", playerId: pid, idx, value });
    }
  });

  // ƒëang g√µ -> ƒë·ª´ng re-render
  STATUS.body.addEventListener("focusin", (e)=>{
    if (e.target.closest("input[data-kind]")) STATUS.editing = true;
  });
  STATUS.body.addEventListener("focusout", (e)=>{
    if (e.target.closest("input[data-kind]")){
      setTimeout(()=>{
        const active = document.activeElement;
        STATUS.editing = !!(active && STATUS.body.contains(active) && active.matches("input[data-kind]"));
      }, 0);
    }
  });
}


// debounce g·ª≠i intent
function sendIntentDebounced(intent){
  clearTimeout(STATUS._timer);
  STATUS._timer = setTimeout(()=> sendIntent(intent), 120);
}

function renderStatusBoard(){
  initStatusBoardUI();

  const s = getState();
  if (!s || !STATUS.el || !STATUS.body) return;

  // n·∫øu ƒëang edit input th√¨ kh√¥ng rebuild DOM (tr√°nh lag + m·∫•t con tr·ªè)
  if (STATUS.editing) return;

  // ƒë·∫£m b·∫£o shape
  s.ui = s.ui || {};
  const headers = (s.ui.statHeaders || ["ATK","DEF","HP","COIN"]).slice(0,4);
  while (headers.length < 4) headers.push("");

  const host = isHost(s);

  // t·∫°o "signature" nh·∫π ƒë·ªÉ ch·ªâ update khi data ƒë·ªïi
  // (d√πng version + headers + players + stats)
  let sig = `v=${s.version||0}|h=${headers.join(",")}|p=`;
  const players = (s.players || []);
  for (let i=0;i<players.length;i++){
    const p = players[i];
    if (!p) continue;
    const stats = ensureStatsRow(s, p.id); // ƒë·∫£m b·∫£o c√≥ 4 √¥
    sig += `${p.id}:${p.name||""}:${p.color||""}:${stats.join("/")};`;
  }

  if (sig === STATUS.lastSig) return; // ‚úÖ kh√¥ng ƒë·ªïi th√¨ th√¥i
  STATUS.lastSig = sig;

  // ===== render HTML (ch·ªâ ch·∫°y khi sig ƒë·ªïi) =====
  const headerHtml = headers.map((h, idx)=>{
    // d√πng readonly thay v√¨ disabled ƒë·ªÉ v·∫´n click/copy ƒë∆∞·ª£c
    const ro = host ? "" : "readonly";
    return `
      <th style="padding:6px 6px; text-align:center;">
        <input ${ro}
          data-kind="header" data-idx="${idx}"
          value="${escapeHtml(h ?? "")}"
          style="
            width: 70px;
            text-align:center;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 8px;
            color: #fff;
            padding: 4px 6px;
            outline: none;
          "
        />
      </th>
    `;
  }).join("");

  const rows = players.map(p=>{
    if (!p) return "";
    const stats = ensureStatsRow(s, p.id);

    const tds = stats.slice(0,4).map((v, idx)=>{
      return `
        <td style="padding:6px 6px; text-align:center;">
          <input
            data-kind="stat"
            data-pid="${p.id}"
            data-idx="${idx}"
            value="${escapeHtml((v ?? "").toString())}"
            title="S·ª≠a t·ª± do"
            style="
              width: 70px;
              text-align:center;
              background: rgba(0,0,0,0.25);
              border: 1px solid rgba(255,255,255,0.18);
              border-radius: 8px;
              color: #fff;
              padding: 4px 6px;
              outline: none;
            "
          />
        </td>
      `;
    }).join("");

    return `
      <tr style="border-top: 1px solid rgba(255,255,255,0.10);">
        <td style="padding:6px 8px; white-space:nowrap;">
          <span style="
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:3px;
            background:${COLORS?.[p.color] ?? "rgba(255,255,255,.35)"};
            margin-right:6px;
          "></span>
          <span style="opacity:0.92; font-weight:600;">
            ${escapeHtml(p.name || "Player")}
          </span>
        </td>
        ${tds}
      </tr>
    `;
  }).join("");
  
  // ch·ªâ render BODY, kh√¥ng ƒë·ª•ng header
  STATUS.body.innerHTML = `
    <table style="border-collapse:collapse;width:100%;">
      <thead>
        <tr>
          <th style="padding:6px 8px;text-align:left;opacity:0.85;">Player</th>
          ${headerHtml}
        </tr>
      </thead>
      <tbody>
        ${rows || ""}
      </tbody>
    </table>
  `;

}

// ch·ªëng XSS (v√¨ d√πng innerHTML)
function escapeHtml(str){
  return (str ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}


/* =========================================================
   19) UI bindings (bind 1 l·∫ßn)
========================================================= */
if (UI.modeSelect){
  UI.modeSelect.addEventListener("change", ()=>{
    if (UI.wsRow) UI.wsRow.style.display = (UI.modeSelect.value === "ws") ? "flex" : "none";
  });
}

if (UI.applyDeckBtn){
  UI.applyDeckBtn.addEventListener("click", ()=>{
    if (!client.isHost) return toast("Host m·ªõi set deck images");
    sendIntent({ type:"setAssets", frontBase: UI.frontBaseInput?.value, backUrl: UI.backUrlInput?.value });
    toast("Applied deck images");
  });
}

if (UI.createBtn){
  UI.createBtn.addEventListener("click", async ()=>{
    try{
      if (UI.modeSelect?.value === "firebase") await createRoomAsHost_Firebase();
      else createRoomAsHost_LocalOrWS();
    }catch(e){
      console.error(e);
      toast("Create error: " + (e.message || e));
    }
  });
}

if (UI.joinBtn){
  UI.joinBtn.addEventListener("click", async ()=>{
    try{
      if (UI.modeSelect?.value === "firebase") await joinRoomAsClient_Firebase();
      else joinRoomAsClient_LocalOrWS();
    }catch(e){
      console.error(e);
      toast("Join error: " + (e.message || e));
    }
  });
}

if (UI.resetBtn){
  UI.resetBtn.addEventListener("click", ()=>{
    if (!client.authoritative) return;
    if (!client.isHost) return toast("Ch·ªâ Host m·ªõi reset.");
    sendIntent({type:"reset"});
  });
}

if (UI.copyLinkBtn){
  UI.copyLinkBtn.addEventListener("click", async ()=>{
    readInputs();
    const url = new URL(location.href);
    url.searchParams.set("room", client.roomCode);
    url.searchParams.set("mode", UI.modeSelect?.value || "local");
    if (UI.modeSelect?.value === "ws"){
      const ws = (UI.wsUrlInput?.value || "").trim();
      if (ws) url.searchParams.set("ws", ws);
    }
    try{
      await navigator.clipboard.writeText(url.toString());
      toast("ƒê√£ copy link ph√≤ng.");
    }catch(e){
      toast("Copy failed (tr√¨nh duy·ªát ch·∫∑n).");
    }
  });
}

document.querySelectorAll(".collapse-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const panelId = btn.dataset.target;
    const panel = document.getElementById(panelId);
    if (!panel) return;
    const collapsed = panel.classList.toggle("collapsed");
    btn.textContent = collapsed ? "+" : "‚àí";
  });
});

/* =========================================================
   20) Auth UI buttons (login/register/anon/logout/leave)
========================================================= */
async function registerUser(){
  fbInitOnce();
  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";
  const username = (document.getElementById("authUsername")?.value || "").trim();

  if (!email || !password || !username){
    toast("Nh·∫≠p ƒë·∫ßy ƒë·ªß email / m·∫≠t kh·∫©u / t√™n");
    return;
  }

  const cred = await FB.auth.createUserWithEmailAndPassword(email, password);
  const user = cred.user;

  await FB.db.ref(`AllUser/${user.uid}`).set({
    username,
    email,
    createdAt: Date.now(),
    setCard: {}
  });

  // sync runtime
  FB.user = user; FB.uid = user.uid; FB.username = username;
  if (UI.nameInput) UI.nameInput.value = username;

  toast("ƒêƒÉng k√Ω th√†nh c√¥ng");
  goLobby();
}

async function loginUser(){
  fbInitOnce();
  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";

  if (!email || !password){
    toast("Nh·∫≠p email v√† m·∫≠t kh·∫©u");
    return;
  }

  await FB.auth.signInWithEmailAndPassword(email, password);

  // sau login, l·∫•y username t·ª´ profile n·∫øu c√≥
  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  const snap = await FB.db.ref(`AllUser/${FB.uid}`).get();
  const prof = snap.val() || {};
  FB.username = (prof.username || "Player").slice(0,18);

  if (UI.nameInput) UI.nameInput.value = FB.username;

  toast("ƒêƒÉng nh·∫≠p th√†nh c√¥ng");
  goLobby();
}

const loginBtn = document.getElementById("loginBtn");
const registerBtn = document.getElementById("registerBtn");
const playAnonBtn = document.getElementById("playAnonBtn");
const logoutBtn = document.getElementById("logoutBtn");
const leaveMatchBtn = document.getElementById("leaveMatchBtn");

if (registerBtn){
  registerBtn.onclick = async ()=> {
    try{ await registerUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (loginBtn){
  loginBtn.onclick = async ()=> {
    try{ await loginUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (playAnonBtn){
  playAnonBtn.onclick = async ()=>{
    try{
      fbInitOnce();
      await FB.auth.signInAnonymously();
      FB.user = FB.auth.currentUser;
      FB.uid = FB.user.uid;

      const uname =
        ((document.getElementById("authUsername")?.value || "").trim().slice(0,18)) ||
        "Guest";
      FB.username = uname;

      const uref = FB.db.ref(`AllUser/${FB.uid}`);
      const snap = await uref.get();
      if (!snap.exists()){
        await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
      }else{
        await uref.update({ username: FB.username });
        const cur = snap.val() || {};
        if (!cur.setCard) await uref.update({ setCard:{} });
      }

      if (UI.nameInput) UI.nameInput.value = FB.username;

      goLobby();
      toast("Ch∆°i th·ª≠: v√†o s·∫£nh ch·ªù");
    }catch(e){
      console.error(e);
      toast("Anonymous error: " + (e.message || e));
    }
  };
}
if (logoutBtn){
  logoutBtn.onclick = async ()=>{
    try{ if (FB?.auth?.currentUser) await FB.auth.signOut(); }catch(e){}
    try{ leaveRoom(); }catch(e){}
    goAuth();
    toast("ƒê√£ ƒëƒÉng xu·∫•t");
  };
}
if (leaveMatchBtn){
  leaveMatchBtn.onclick = ()=>{
    try{ leaveRoom(); }catch(e){}
    goLobby();
    toast("ƒê√£ r·ªùi ph√≤ng");
  };
}

// S·∫£nh ch·ªù////////////////////////////////////////////////
  ///////////////////
  (function initLobbyTabs(){
  const root = document.getElementById("lobbyScreen");
  if(!root) return;

  const tabs = Array.from(root.querySelectorAll(".tab"));
  const navs = Array.from(root.querySelectorAll(".nav-item"));
  const iconNavs = Array.from(root.querySelectorAll(".icon-btn[data-tab]"));

  function showTab(tabId){
    tabs.forEach(t => t.classList.toggle("active", t.id === tabId));
    navs.forEach(b => b.classList.toggle("active", b.dataset.tab === tabId));
  }

  navs.forEach(btn => {
    btn.addEventListener("click", ()=> showTab(btn.dataset.tab));
  });
  iconNavs.forEach(btn => {
    btn.addEventListener("click", ()=> showTab(btn.dataset.tab));
  });

  // mirror: Inventory buttons call existing ids (no change to your logic)
  const invOpen = document.getElementById("invOpenDeckBtn");
  const openDeckBtn = document.getElementById("openDeckBtn");
  if(invOpen && openDeckBtn){
    invOpen.addEventListener("click", ()=> openDeckBtn.click());
  }

  const invApply = document.getElementById("invApplyDeckBtn");
  const applyDeckBtn = document.getElementById("applyDeckBtn");
  if(invApply && applyDeckBtn){
    invApply.addEventListener("click", ()=> applyDeckBtn.click());
  }

  // Net pill reflect netBadge text if you keep updating #netBadge elsewhere
  const netBadge = document.getElementById("netBadge");
  const netPill = document.getElementById("netPill");
  const netTxt = document.getElementById("netTxt");
  const dot = document.getElementById("netDot");
  if(netBadge && netPill && netTxt){
    const sync = ()=>{
      const t = (netBadge.textContent || "").trim().toUpperCase();
      netTxt.textContent = t || "OFFLINE";
      const online = t && t !== "OFFLINE";
      netPill.classList.toggle("online", online);
      if(dot) dot.style.background = online ? "#42d392" : "#a64b4b";
    };
    sync();
    // n·∫øu b·∫°n c√≥ c∆° ch·∫ø update netBadge li√™n t·ª•c, c√≥ th·ªÉ observe:
    new MutationObserver(sync).observe(netBadge, { childList:true, subtree:true, characterData:true });
  }

  // Small UX: Paste room code
  const pasteBtn = document.getElementById("pasteRoomBtn");
  const quickIn = document.getElementById("quickRoomSearch");
  const roomInput = document.getElementById("roomInput");
  const focusBtn = document.getElementById("focusRoomBtn");
  if(pasteBtn && quickIn){
    pasteBtn.addEventListener("click", async ()=>{
      try{
        const txt = await navigator.clipboard.readText();
        quickIn.value = (txt || "").trim();
      }catch(e){}
    });
  }
  if(focusBtn && quickIn && roomInput){
    focusBtn.addEventListener("click", ()=>{
      const v = (quickIn.value || "").trim();
      if(v) roomInput.value = v;
      showTab("tabRoom");
      roomInput.focus();
    });
  }

  // Customize sliders text
  const uiSfx = document.getElementById("uiSfx");
  const uiSfxTxt = document.getElementById("uiSfxTxt");
  if(uiSfx && uiSfxTxt){
    const render = ()=> uiSfxTxt.textContent = uiSfx.value + "%";
    uiSfx.addEventListener("input", render);
    render();
  }
})();

(function initLobbyDock(){
  const byId = (id)=> document.getElementById(id);

  const dockRoomBtn = byId("dockRoomBtn");
  const dockBrowserBtn = byId("dockBrowserBtn");
  const dockDeckBtn = byId("dockDeckBtn");

  const dockCopyBtn = byId("dockCopyBtn");
  const dockResetBtn = byId("dockResetBtn");
  const dockJoinBtn = byId("dockJoinBtn");

  const copyLinkBtn = byId("copyLinkBtn");
  const resetBtn = byId("resetBtn");
  const joinBtn = byId("joinBtn");
  const openDeckBtn = byId("openDeckBtn");

  // Tab switch helper: d√πng ƒë√∫ng c∆° ch·∫ø data-tab b·∫°n ƒë√£ d√πng
  function showTab(tabId){
    const root = byId("lobbyScreen");
    if(!root) return;
    root.querySelectorAll(".tab").forEach(t=> t.classList.toggle("active", t.id === tabId));
    root.querySelectorAll(".nav-item").forEach(b=> b.classList.toggle("active", b.dataset.tab === tabId));
  }

  dockRoomBtn?.addEventListener("click", ()=> showTab("tabRoom"));
  dockBrowserBtn?.addEventListener("click", ()=> showTab("tabRoomBrowser"));
  dockDeckBtn?.addEventListener("click", ()=> openDeckBtn?.click());

  dockCopyBtn?.addEventListener("click", ()=> copyLinkBtn?.click());
  dockResetBtn?.addEventListener("click", ()=> resetBtn?.click());
  dockJoinBtn?.addEventListener("click", ()=> joinBtn?.click());

  // Hint ƒë·ªïi theo tab (optional)
  const hint = byId("dockHint");
  if(hint){
    const map = {
      tabRoom: "T·∫°o ph√≤ng ho·∫∑c nh·∫≠p m√£ ƒë·ªÉ v√†o ph√≤ng.",
      tabRoomBrowser: "Browser: l·ªçc theo tag/preset r·ªìi Join nhanh.",
      tabInventory: "T·ªß ƒë·ªì: preset deck / cosmetics.",
      tabCustomize: "T√πy ch·ªânh: theme / sound / fps.",
      tabShop: "C·ª≠a h√†ng: cosmetics (kh√¥ng ·∫£nh h∆∞·ªüng gameplay).",
      tabNotifications: "Th√¥ng b√°o: tips & system.",
    };
    document.querySelectorAll('#lobbyScreen .nav-item[data-tab]').forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const t = btn.dataset.tab;
        if(map[t]) hint.textContent = map[t];
      });
    });
  }
})();

  
/* =========================================================
   21) Deck modal binds
========================================================= */
if (DECKUI.openBtn){
  DECKUI.openBtn.onclick = async ()=>{
    try{
      await refreshSetList();
      openDeckModal();
    }catch(e){
      console.error(e);
      toast("Deck modal error: " + (e.message||e));
    }
  };
}
if (DECKUI.closeBtn) DECKUI.closeBtn.onclick = closeDeckModal;
if (DECKUI.newSetBtn) DECKUI.newSetBtn.onclick = createNewSet;
if (DECKUI.saveBtn) DECKUI.saveBtn.onclick = saveCurrentSet;
if (DECKUI.deleteSetBtn) DECKUI.deleteSetBtn.onclick = deleteCurrentSet;
if (DECKUI.loadSetBtn) DECKUI.loadSetBtn.onclick = loadSelectedSet;
if (DECKUI.addCardBtn) DECKUI.addCardBtn.onclick = ()=>{
    DECKUI.list.appendChild(makeCardTypeRow());
  };

/* =========================================================
   22) Auto-fill URL params
========================================================= */
(function initFromQuery(){
  const u = new URL(location.href);
  const room = u.searchParams.get("room");
  const mode = u.searchParams.get("mode");
  const ws = u.searchParams.get("ws");
  if (room && UI.roomInput) UI.roomInput.value = room.toUpperCase();
  if (mode && UI.modeSelect && (mode==="local" || mode==="ws" || mode==="firebase")){
    UI.modeSelect.value = mode;
    if (UI.wsRow) UI.wsRow.style.display = mode === "ws" ? "flex" : "none";
  }
  if (ws && UI.wsUrlInput) UI.wsUrlInput.value = ws;
})();

addEventListener("beforeunload", ()=>{ try{ leaveRoom(); }catch(e){} });

window.addEventListener("error", (e) => {
  toast("JS error: " + (e.message || "unknown"));
});
window.addEventListener("unhandledrejection", (e) => {
  toast("Promise error: " + ((e.reason && e.reason.message) || e.reason || "unknown"));
});

/* =========================================================
   23) Boot
========================================================= */
goAuth();
setNetBadge("OFFLINE");

</script>
</body>
</html>
