<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Tabletop Card Sandbox (4P) ‚Äî Canvas + Realtime</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33cc;
      --panelSolid:#121a33;
      --border:#2a3566;
      --text:#e9ecff;
      --muted:#9aa6d6;
      --accent:#7aa2ff;
      --danger:#ff6b8b;
      --ok:#49d17c;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      background:
        radial-gradient(1200px 800px at 20% 10%, #18224b 0%, transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #1c2f66 0%, transparent 55%),
        radial-gradient(700px 600px at 50% 85%, #12214b 0%, transparent 50%),
        var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* Layout */
    #app{
      position:relative;
      width:100%;
      height:100%;
    }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      display:flex;
      gap:5px;
      align-items:flex-start;
      z-index:10;
      pointer-events:auto; /* let canvas interactions through */
    }
    .panel{
      pointer-events:auto;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      /* min-width: 280px; */
    }
    .panel header{
      padding:8px 10px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .panel header .title{
      font-weight:700;
      letter-spacing:.2px;
      font-size:13px;
      color:var(--text);
    }
    .panel header .badge{
      font-size:11px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:4px 8px;
      background: rgba(0,0,0,.12);
    }
    .panel .content{
      padding:12px;
    }

    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .col{display:flex; flex-direction:column; gap:8px;}
    label{font-size:12px; color:var(--muted);}
    input,button,select{
      font-family:inherit;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:5px 10px;
      outline:none;
    }
    input::placeholder{color:rgba(233,236,255,.45)}
    button{
      cursor:pointer;
      border:1px solid rgba(122,162,255,.35);
      background: linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.08));
    }
    button:hover{border-color: rgba(122,162,255,.6)}
    button.secondary{
      border-color: rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
    }
    button.danger{
      border-color: rgba(255,107,139,.45);
      background: rgba(255,107,139,.12);
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    /* Chat */
    #chatPanel{
      position:absolute;
      right:14px;
      bottom:14px;
      width:min(420px, 42vw);
      height:min(320px, 42vh);
      z-index:20;
      display:flex;
      flex-direction:column;
      pointer-events:auto;
      border-radius:14px;
      overflow:hidden;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    
    #chatPanel.collapsed{
      height:44px !important;
    }
    
    #chatPanel header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px 8px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
    }
    
    #chatPanel .titleRow{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    
    #chatPanel .title{
      font-weight:800;
      letter-spacing:.08em;
      font-size:11px;
      opacity:.9;
    }
    
    #chatPanel .badge{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
    }
    
    #chatPanel .actions{
      display:flex;
      align-items:center;
      gap:6px;
    }
    
    .chatToggle{
      display:flex;
      gap:4px;
      padding:3px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .chatToggle button{
      border:0;
      background: transparent;
      color: rgba(233,236,255,.72);
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      cursor:pointer;
    }
    .chatToggle button.active{
      background: rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
    }
    
    #chatPanel .content{
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    
    #chatLog{
      flex:1;
      overflow:auto;
      padding:10px 10px 8px 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      scroll-behavior:smooth;
    }
    
    /* scrollbar subtle */
    #chatLog::-webkit-scrollbar{ width:10px; }
    #chatLog::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border:3px solid rgba(0,0,0,0);
      background-clip: padding-box;
      border-radius:999px;
    }

    #roomList::-webkit-scrollbar{ width:10px; }
    #roomList::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border:3px solid rgba(0,0,0,0);
      background-clip: padding-box;
      border-radius:999px;
    }
    
    #cardUrlList::-webkit-scrollbar{ width:10px; }
    #cardUrlList::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border:3px solid rgba(0,0,0,0);
      background-clip: padding-box;
      border-radius:999px;
    }
    
    /* Message row */
    .msg{
      display:flex;
      gap:8px;
      align-items:flex-start;
    }
    
    .msg .dot{
      width:10px; height:10px; border-radius:999px;
      margin-top:6px;
      flex:0 0 auto;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.18);
    }
    
    .msg .bubble{
      flex:1;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding:7px 9px;
      max-width:100%;
    }
    
    .msg .meta{
      display:flex;
      gap:8px;
      align-items:baseline;
      flex-wrap:wrap;
      margin-bottom:4px;
      font-size:11px;
      color: rgba(233,236,255,.62);
    }
    .msg .name{
      font-weight:700;
      color: rgba(255,255,255,.88);
    }
    .msg .time{
      opacity:.75;
      font-variant-numeric: tabular-nums;
    }
    
    .msg .text{
      font-size:13px;
      line-height:1.35;
      color: rgba(255,255,255,.92);
      white-space:pre-wrap;
      word-break:break-word;
    }
    
    /* Fade older messages a bit (LoL vibe) */
    .msg.age2 .bubble{ opacity:.92; }
    .msg.age3 .bubble{ opacity:.82; }
    .msg.age4 .bubble{ opacity:.70; }
    
    #chatForm{
      display:flex;
      gap:8px;
      padding:10px;
      border-top:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
    }
    
    #chatInput{
      flex:1;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:10px 12px;
      color: rgba(255,255,255,.92);
      outline:none;
    }
    #chatInput::placeholder{ color: rgba(233,236,255,.45); }
    
    #chatSend{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.9);
      padding:10px 14px;
      cursor:pointer;
    }
    #chatSend:hover{ background: rgba(255,255,255,.12); }
    
    /* Small */
    @media (max-width: 880px){
      #chatPanel{ width:min(360px, 60vw); height:min(280px, 40vh); }
    }


    /* Floating help */
    #help{
      position:absolute;
      left:12px;
      bottom:12px;
      z-index:10;
      pointer-events:auto;
    }
    #help .panel{pointer-events:auto}
    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      padding: 2px 6px;
      margin: 0 2px;
      border-radius: 7px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      font-size: 11px;
      color: rgba(233,236,255,.85);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,.22);
    }

    /* Toast */
    #toast{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      top:14px;
      z-index:20;
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(233,236,255,.92);
      box-shadow: var(--shadow);
      display:none;
      pointer-events:none;
      backdrop-filter: blur(8px);
      font-size: 12px;
    }

    /* Small */
    @media (max-width: 880px){
      #help{display:none;}
      #chatPanel{ width:min(360px, 60vw); height:min(280px, 40vh); }
      .hud{flex-direction:column;}
    }

   #inspector{
      position: fixed;      
      z-index: 90;
      display:none;
      pointer-events:auto;
      width: min(52vh, 360px);
    }

    
    #inspector .panel{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: 15px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    
    #insPreview{
      width:100%;
      aspect-ratio: 86 / 122;     /* ƒë√∫ng t·ªâ l·ªá CARD.w/h c·ªßa b·∫°n */
      min-height: 240px;
      border-radius: 12px;
      background: rgba(0,0,0,.18);
    }
    
    #insPreview img{
      width:100%;
      height:100%;
      object-fit: contain;
      display:block;
    }
    .panel.collapsed .content {
      display: none;
    }
    
    .panel.collapsed {
      min-height: unset;
    }
    
    .collapse-btn {
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      color: #e9ecff;
      line-height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .collapse-btn:hover {
      background: rgba(122,162,255,.25);
    }

    .modal{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal-card{
      width: min(535px, 92vw);
      max-height: min(86vh, 780px);
      pointer-events: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      min-width: 280px;
      padding: 10px;
    }
    .card-url-row{
      display:flex; gap:5px; align-items:center;
    }
    
    /* Optional: minimize buttons row */
    .hud .panel header{ cursor:default; }
    
    .screen{ display:none; width:100%; height:100%; }
    .screen.active{ display:block; }
    #authScreen{align-items:flex-start; justify-content:center; }
    #matchScreen{ position:relative; width:100%; height:100%; }

    /* =========================
   LOBBY - FULLSCREEN FLEX (LoL-ish)
   Top 15% | Middle 70% | Dock 15%
   Sidebar 20% | Main 80%
   ========================= */

html, body{
  height: 100%;
  margin: 0;
}
body{ overflow: hidden; } /* lobby full-screen: tr√°nh scroll to√†n trang */

#lobbyScreen.lobby{
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;

  color: #e7e2d8;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
}

/* ===== Background layers (absolute, ignore layout) ===== */
#lobbyScreen .lobby-bg{
  position:absolute;
  inset:-60px;
  background:
    radial-gradient(1200px 650px at 15% 20%, rgba(199,166,101,.18), transparent 60%),
    radial-gradient(1000px 600px at 85% 25%, rgba(80,140,255,.12), transparent 55%),
    radial-gradient(900px 550px at 50% 92%, rgba(40,220,170,.09), transparent 60%),
    linear-gradient(180deg, #0b0f16, #070a10 60%, #05070c);
  filter: saturate(1.08);
  pointer-events:none;
}
#lobbyScreen .lobby-vignette{
  position:absolute; inset:0;
  background: radial-gradient(1200px 700px at 50% 10%, transparent 35%, rgba(0,0,0,.70) 82%);
  pointer-events:none;
}
#lobbyScreen .lobby-noise{
  position:absolute; inset:0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.25'/%3E%3C/svg%3E");
  mix-blend-mode: overlay;
  opacity: .08;
  pointer-events:none;
}

/* ===== HUD: 3 t·∫ßng b·∫±ng FLEX (ƒë·∫πp + ·ªïn ƒë·ªãnh h∆°n grid) ===== */
#lobbyScreen .hud{
  position: relative;
  width: 100%;
  height: 100%;

  padding: 14px 16px;
  box-sizing: border-box;

  display: flex;
  flex-direction: column;
  gap: 5px;
}

/* ========= TOPBAR 15% ========= */
#lobbyScreen .lobby-topbar{
  flex: 0 0 15vh;
  min-height: 92px;         /* b·∫£o ƒë·∫£m kh√¥ng qu√° b√© */
  width: 100%;
  box-sizing: border-box;

  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;

  padding: 10px 12px;
  border-radius: 18px;
  border: 1px solid rgba(199,166,101,.18);
  background: rgba(8, 11, 18, .45);
  box-shadow: 0 18px 44px rgba(0,0,0,.45);
  backdrop-filter: blur(12px);
}

#lobbyScreen .brand{
  display:flex;
  align-items:center;
  gap: 12px;
  min-width: 240px;
}
#lobbyScreen .brand-logo{
  width: 44px; height: 44px;
  border-radius: 14px;
  background:
    radial-gradient(circle at 30% 30%, rgba(255,225,160,.9), rgba(199,166,101,.25) 45%, rgba(0,0,0,.0) 70%),
    linear-gradient(135deg, rgba(199,166,101,.35), rgba(120,170,255,.10));
  border: 1px solid rgba(199,166,101,.35);
  box-shadow: 0 10px 24px rgba(0,0,0,.45);
}
#lobbyScreen .brand-title{
  font-weight: 800;
  letter-spacing: .14em;
  font-size: 13px;
  color: #f3efe7;
}
#lobbyScreen .brand-sub{
  font-size: 12px;
  opacity: .75;
  margin-top: 2px;
}

#lobbyScreen .top-actions{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap: 10px;
  flex: 1;
  min-width: 320px;
}

#lobbyScreen .top-pill{
  display:flex; align-items:center; gap: 10px;
  padding: 8px 12px;
  border-radius: 999px;
  background: rgba(10, 14, 22, .55);
  border: 1px solid rgba(199,166,101,.22);
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  backdrop-filter: blur(10px);
  white-space: nowrap;
}
#lobbyScreen .top-pill .dot{
  width: 8px; height: 8px; border-radius: 999px;
  background: #a64b4b;
  box-shadow: 0 0 0 3px rgba(166,75,75,.15);
}
#lobbyScreen .top-pill.online .dot{
  background: #42d392;
  box-shadow: 0 0 0 3px rgba(66,211,146,.18);
}
#lobbyScreen .top-pill .txt{ font-size: 12px; letter-spacing:.04em; opacity:.9; }

#lobbyScreen .icon-btn{
  position: relative;
  height: 38px; width: 38px;
  border-radius: 12px;
  border: 1px solid rgba(199,166,101,.22);
  background: rgba(10, 14, 22, .55);
  color: #f3efe7;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  cursor: pointer;
}
#lobbyScreen .icon-btn:hover{
  border-color: rgba(199,166,101,.45);
  transform: translateY(-1px);
}
#lobbyScreen .icon-btn .bubble{
  position:absolute; top:-6px; right:-6px;
  background: rgba(199,166,101,.95);
  color:#15110b;
  font-weight: 800;
  border-radius: 999px;
  padding: 2px 7px;
  font-size: 11px;
  border: 1px solid rgba(255,255,255,.25);
}
#lobbyScreen .top-logout{
  height: 38px;
  border-radius: 12px;
  padding: 10px 12px;
}

/* ========= MIDDLE 70% ========= */
#lobbyScreen .lobby-shell{
  min-height: 0;            /* CH·ªêT: cho ph√©p scroll n·ªôi b·ªô */
  width: 100%;
  box-sizing: border-box;
  height: 70%;
  display:flex;
  gap: 5px;
}

/* Sidebar 20% */
#lobbyScreen .lobby-sidebar{
  width: 20%;
  height: 100%;
  min-height: 0;
  overflow: auto;

  background: rgba(8, 11, 18, .55);
  border: 1px solid rgba(199,166,101,.20);
  border-radius: 18px;
  box-shadow: 0 18px 44px rgba(0,0,0,.45);
  backdrop-filter: blur(12px);
  display:flex;
  flex-direction: column;
}

/* Main 80% */
#lobbyScreen .lobby-main{
  width: 80%;             /* CH·ªêT: ƒë·ªÉ flex kh√¥ng co theo content */
  height: 100%;
  min-height: 0;
  display:flex;
  flex-direction: column;
  gap: 5px;
}

/* Tabs must stretch full width */
#lobbyScreen .tab{ display:none; width: 100%; }
#lobbyScreen .tab.active{ display:block; width: 100%; height: 100%;}

/* Nav item */
#lobbyScreen .nav-item{
  display:flex; align-items:center; gap: 10px;
  width: 100%;
  padding: 6px 8px;
  border: 1px solid transparent;
  background: transparent;
  color: rgba(231,226,216,.88);
  cursor: pointer;
  text-align:left;
}
#lobbyScreen .nav-item:hover{
  background: rgba(199,166,101,.10);
  border-color: rgba(199,166,101,.22);
}
#lobbyScreen .nav-item.active{
  background: rgba(199,166,101,.14);
  border-color: rgba(199,166,101,.40);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
}
#lobbyScreen .nav-ico{ width: 22px; text-align:center; opacity:.95; }
#lobbyScreen .nav-txt{ font-size: 13px; letter-spacing:.02em; }

#lobbyScreen .sidebar-divider{
  height: 1px;
  margin: 6px 6px;
  background: linear-gradient(90deg, transparent, rgba(199,166,101,.25), transparent);
}

/* ========= DOCK 15% ========= */
#lobbyScreen .lobby-dock{
  flex: 0 0 15vh;
  min-height: 92px;
  width: 100%;
  box-sizing: border-box;

  padding: 10px 12px;

  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;

  border-radius: 18px;
  border: 1px solid rgba(199,166,101,.20);
  background: rgba(8, 11, 18, .55);
  box-shadow: 0 18px 44px rgba(0,0,0,.45);
  backdrop-filter: blur(12px);
}

#lobbyScreen .dock-left,
#lobbyScreen .dock-right{
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap: wrap;
}
#lobbyScreen .dock-mid{
  flex:1;
  min-width: 240px;
  display:flex;
  justify-content:center;
}
#lobbyScreen .dock-pill{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 14px;
  border-radius: 999px;
  border: 1px solid rgba(199,166,101,.18);
  background: rgba(0,0,0,.18);
  width: min(720px, 100%);
  overflow:hidden;
}
#lobbyScreen .dock-pill .dot{
  width: 8px; height: 8px; border-radius: 999px;
  background: rgba(199,166,101,.90);
  box-shadow: 0 0 0 3px rgba(199,166,101,.14);
  flex: 0 0 auto;
}
#lobbyScreen .dock-pill .txt{
  font-size: 12px;
  opacity:.88;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}

/* ===== Panels stretch full width (FIX ch√≠nh c·ªßa ·∫£nh b·∫°n) ===== */
#lobbyScreen .panel{
  width: 100%;
  background: rgba(8, 11, 18, .55) !important;
  border: 1px solid rgba(199,166,101,.20) !important;
  border-radius: 18px !important;
  box-shadow: 0 18px 44px rgba(0,0,0,.45) !important;
  backdrop-filter: blur(12px);
  overflow:hidden;
  height: 100%;
}
#lobbyScreen .panel header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 8px 10px;
  border-bottom: 1px solid rgba(199,166,101,.14);
  background: linear-gradient(180deg, rgba(199,166,101,.10), rgba(0,0,0,0));
}
#lobbyScreen .panel header .title{
  font-weight: 900;
  letter-spacing: .12em;
  font-size: 12px;
  color: rgba(243,239,231,.95);
}
#lobbyScreen .panel .content{ padding: 12px 14px; }
#lobbyScreen .panel .hint{ opacity:.75; font-size: 12px; }

#lobbyScreen .panel.soft header.soft-header{ display:block; }
#lobbyScreen .soft-header .title{ font-size: 12px; letter-spacing:.14em; }
#lobbyScreen .soft-header .sub{ margin-top: 4px; font-size: 12px; opacity:.72; }

/* Inputs/buttons */
#lobbyScreen input, #lobbyScreen select{
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(199,166,101,.18);
  border-radius: 12px;
  color: rgba(243,239,231,.92);
  padding: 10px 10px;
  outline: none;
  width: 100%;
  box-sizing: border-box;
}
#lobbyScreen input:focus, #lobbyScreen select:focus{
  border-color: rgba(199,166,101,.45);
  box-shadow: 0 0 0 3px rgba(199,166,101,.12);
}

#lobbyScreen button{
  border-radius: 12px;
  border: 1px solid rgba(199,166,101,.25);
  background: rgba(199,166,101,.18);
  color: rgba(243,239,231,.95);
  padding: 10px 12px;
  cursor:pointer;
  white-space: nowrap;
}
#lobbyScreen button.secondary{
  background: rgba(10,14,22,.35);
  border-color: rgba(199,166,101,.20);
}
#lobbyScreen button.danger{
  background: rgba(166,75,75,.20);
  border-color: rgba(166,75,75,.35);
}
#lobbyScreen button:hover{
  border-color: rgba(199,166,101,.45);
  transform: translateY(-1px);
}
#lobbyScreen button:active{ transform: translateY(0); }

/* grid-2: cho form ƒë·∫πp h∆°n, nh∆∞ng kh√¥ng l√†m co main */
#lobbyScreen .grid-2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

/* mini panels */
#lobbyScreen .panel.mini{ border-radius: 16px !important; }
#lobbyScreen .mini-header{ padding: 10px 12px !important; }
#lobbyScreen .mini-header .title{
  font-weight: 900;
  letter-spacing:.08em;
  font-size: 12px;
}
#lobbyScreen .mini-header .sub{
  font-size: 12px;
  opacity:.7;
  margin-top: 2px;
}
#lobbyScreen .mono-note{ opacity:.75; font-size: 12px; }

/* Shop */
#lobbyScreen .shop-grid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 12px;
}
#lobbyScreen .shop-card{
  border-radius: 16px;
  border: 1px solid rgba(199,166,101,.18);
  background: rgba(0,0,0,.18);
  padding: 12px;
}
#lobbyScreen .shop-img{
  height: 90px;
  border-radius: 14px;
  border: 1px solid rgba(199,166,101,.20);
  background:
    radial-gradient(circle at 30% 30%, rgba(199,166,101,.35), transparent 55%),
    linear-gradient(135deg, rgba(70,120,255,.12), rgba(0,0,0,.0));
  margin-bottom: 10px;
}
#lobbyScreen .shop-img.alt{
  background:
    radial-gradient(circle at 30% 30%, rgba(120,220,190,.28), transparent 55%),
    linear-gradient(135deg, rgba(199,166,101,.10), rgba(0,0,0,.0));
}
#lobbyScreen .shop-img.alt2{
  background:
    radial-gradient(circle at 30% 30%, rgba(240,120,120,.25), transparent 55%),
    linear-gradient(135deg, rgba(199,166,101,.10), rgba(0,0,0,.0));
}
#lobbyScreen .shop-title{ font-weight: 900; letter-spacing:.04em; }
#lobbyScreen .shop-sub{ opacity:.7; font-size: 12px; margin-top: 2px; }
#lobbyScreen .shop-row{ display:flex; align-items:center; justify-content:space-between; gap: 8px; margin-top: 10px; }
#lobbyScreen .price{ font-weight: 900; letter-spacing:.06em; color: rgba(199,166,101,.95); }

/* Notifications */
#lobbyScreen .notif-item{
  display:flex; gap: 10px; align-items:flex-start;
  padding: 12px;
  border-radius: 16px;
  border: 1px solid rgba(199,166,101,.18);
  background: rgba(0,0,0,.16);
  width: 100%;
}
#lobbyScreen .notif-dot{
  width: 10px; height: 10px; border-radius: 999px;
  margin-top: 4px;
  background: rgba(199,166,101,.85);
}
#lobbyScreen .notif-dot.warn{ background: rgba(240,120,120,.85); }
#lobbyScreen .notif-title{ font-weight: 900; }
#lobbyScreen .notif-sub{ opacity:.75; font-size: 12px; margin-top: 2px; }

/* Quick/Tutorial/Patch */
#lobbyScreen .quick-grid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 12px;
}
#lobbyScreen .quick-card{
  text-align:left;
  padding: 14px;
  border-radius: 16px;
  border: 1px solid rgba(199,166,101,.20);
  background: rgba(0,0,0,.16);
}
#lobbyScreen .q-title{ font-weight: 900; letter-spacing:.06em; }
#lobbyScreen .q-sub{ opacity:.72; font-size: 12px; margin-top: 2px; }

#lobbyScreen .tutorial-grid{
  display:grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 12px;
}
#lobbyScreen .tut-card{
  border-radius: 16px;
  border: 1px solid rgba(199,166,101,.18);
  background: rgba(0,0,0,.14);
  padding: 12px;
}
#lobbyScreen .tut-title{ font-weight: 900; }
#lobbyScreen .tut-sub{ opacity:.72; font-size: 12px; margin-top: 2px; }

#lobbyScreen .patch{ margin: 0; padding-left: 18px; }
#lobbyScreen .patch li{ margin: 8px 0; opacity:.9; }
#lobbyScreen .tag{
  display:inline-block;
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 999px;
  margin-right: 8px;
  border: 1px solid rgba(199,166,101,.25);
  background: rgba(199,166,101,.12);
}
#lobbyScreen .tag.new{ border-color: rgba(120,220,190,.35); background: rgba(120,220,190,.12); }
#lobbyScreen .tag.imp{ border-color: rgba(199,166,101,.40); background: rgba(199,166,101,.16); }
#lobbyScreen .tag.todo{ border-color: rgba(240,120,120,.35); background: rgba(240,120,120,.10); }

/* Room Browser list */
#lobbyScreen .rb-list{
  display:flex;
  flex-direction:column;
  gap: 10px;
  margin-top: 8px;
}
#lobbyScreen .rb-card{
  display:flex;
  gap: 12px;
  align-items:stretch;
  padding: 12px;
  border-radius: 16px;
  border: 1px solid rgba(199,166,101,.18);
  background: rgba(0,0,0,.14);
}
#lobbyScreen .rb-emblem{
  width: 54px;
  border-radius: 14px;
  border: 1px solid rgba(199,166,101,.22);
  background:
    radial-gradient(circle at 30% 30%, rgba(199,166,101,.28), transparent 55%),
    linear-gradient(135deg, rgba(70,120,255,.10), rgba(0,0,0,0));
  flex: 0 0 54px;
}
#lobbyScreen .rb-main{ flex:1; min-width: 0; }
#lobbyScreen .rb-top{ display:flex; align-items:center; justify-content:space-between; gap: 10px; }
#lobbyScreen .rb-name{ font-weight: 900; letter-spacing:.04em; }
#lobbyScreen .rb-meta{ opacity:.72; font-size: 12px; margin-top: 2px; }
#lobbyScreen .rb-tags{ display:flex; gap: 6px; flex-wrap:wrap; margin-top: 8px; }
#lobbyScreen .rb-chip{
  font-size: 11px;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px solid rgba(199,166,101,.20);
  background: rgba(199,166,101,.10);
  opacity: .92;
}
#lobbyScreen .rb-side{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  justify-content:space-between;
  gap: 8px;
  min-width: 170px;
}
#lobbyScreen .rb-stats{
  display:flex;
  gap: 10px;
  opacity:.8;
  font-size: 12px;
}
#lobbyScreen .rb-stat b{ opacity: 1; color: rgba(199,166,101,.95); }
#lobbyScreen .rb-actions{ display:flex; gap: 8px; }
#lobbyScreen .rb-join{ min-width: 86px; }

/* Option: hide duplicate logout in room panel if you want it only on topbar */
#roomPanel #logoutBtn{ display:none; }

/* N√∫t nav-item ƒë·∫∑t trong row c·ªßa roomPanel (gi·ªØ style h·ª£p l√Ω) */
#roomPanel .row .nav-item{
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(199,166,101,.20);
  background: rgba(10,14,22,.35);
  width: auto; /* kh√¥ng chi·∫øm full nh∆∞ sidebar */
}
#roomPanel .row .nav-item .nav-txt{ font-size: 12px; }

/* ===== Responsive ===== */
@media (max-width: 1100px){
  #lobbyScreen .shop-grid{ grid-template-columns: 1fr; }
}
@media (max-width: 980px){
  #lobbyScreen .quick-grid{ grid-template-columns: 1fr; }
  #lobbyScreen .tutorial-grid{ grid-template-columns: 1fr; }
}
@media (max-width: 920px){
  body{ overflow: auto; } /* mobile cho ph√©p scroll n·∫øu c·∫ßn */

  #lobbyScreen .lobby-shell{
    flex-direction: column;
  }
  #lobbyScreen .lobby-sidebar{
    max-width: none;
    width: 100%;
  }
  #lobbyScreen .lobby-dock{
    flex-direction: column;
    align-items: stretch;
  }
  #lobbyScreen .dock-mid{
    width:100%;
  }
  #lobbyScreen .grid-2{
    grid-template-columns: 1fr;
  }
}


    
    /* Status board (LoL-ish compact) */
    #statusBoard{
      position:absolute;
      right:12px;
      top:12px;
      z-index:30;

      overflow:hidden;
      pointer-events:auto;
      
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,.92);
      font-family: system-ui, sans-serif;
      font-size: 12px;
    }
    
    #statusBoard.collapsed{
      height: 40px;
    }
    
    #statusBoard header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
    }
    
    #statusBoard .title{
      font-weight:800;
      letter-spacing:.06em;
      font-size:11px;
      opacity:.9;
      user-select:none;
      margin-right: 10px;
    }
    
    #statusBoard .right{
      display:flex;
      align-items:center;
      gap:8px;
    }
    
    #statusBoard .hint{
      font-size:11px;
      opacity:.65;
      user-select:none;
    }
    
    #statusBoard .body{
      padding: 8px;
    }
    
    #statusBoard.collapsed .body{
      display:none;
    }
    
    #statusBoard table{
      width:100%;
      border-collapse:collapse;
    }
    
    #statusBoard th, #statusBoard td{
      padding: 6px 4px;
      border-top: 1px solid rgba(255,255,255,.08);
      text-align:center;
    }
    
    #statusBoard th:first-child,
    #statusBoard td:first-child{
      text-align:left;
      padding-left: 6px;
    }
    
    #statusBoard thead th{
      border-top:none;
      padding-top: 2px;
    }
    
    .sbName{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .sbDot{
      width:10px; height:10px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.18);
      flex:0 0 auto;
    }
    .sbNameText{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:600;
      opacity:.92;
    }
    
    .sbInp{
      width: 64px;
      max-width: 64px;
      text-align:center;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 6px 6px;
      outline:none;
    }
    
    .sbHdr{
      font-weight:700;
      letter-spacing:.04em;
      font-size:11px;
    }
    
    .sbHdrInp{
      width: 64px;
      max-width: 64px;
      text-align:center;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      padding: 6px 6px;
      outline:none;
    }
    .sbHdrInp[readonly]{
      opacity:.75;
      cursor: default;
    }
    
    .waiting-room{
      margin-top:10px; padding-top:10px;
      border-top:1px solid rgba(255,255,255,.08);
      display:flex; flex-direction:column; gap:10px;
    }
    .wr-title{ font-size:12px; color:var(--muted); font-weight:800; letter-spacing:.6px; }
    .wr-grid{ display:grid; grid-template-columns: 1fr 1.2fr 1fr; gap:10px; }
    .wr-col{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:10px;
    }
    .wr-col-title{ font-size:12px; opacity:.85; font-weight:800; margin-bottom:8px; }
    .seat-list{ display:flex; flex-direction:column; gap:8px; }
    .seat.slot{
      min-height:44px;
      border-radius:10px;
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px;
    }
    .seat.drag-over{ outline:2px solid rgba(255,255,255,.25); }
    .player-pill{ display:flex; align-items:center; justify-content:space-between; width:100%; gap:10px; }
    .player-pill .name{ font-weight:800; }
    .player-pill .sub{ font-size:12px; opacity:.7; }
    .badge-role{
      font-size:11px; padding:2px 8px; border-radius:999px;
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.12);
    }
    .wr-hint{ font-size:12px; opacity:.65; margin-top:6px; }
    /* ===== Lobby HUD (LoL-ish) ===== */
    .lobby-hud{
      padding: 14px;
    }
    
    .lobby-layout{
      display:flex;
      gap: 14px;
      align-items:start;
    }
    
    .lobby-card{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    
    .lobby-card-hd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .lobby-card-hd .title{
      font-weight: 900;
      letter-spacing: .8px;
    }
    .lobby-card-hd .sub{
      font-size: 12px;
      opacity: .7;
      font-weight: 600;
    }
    
    .lobby-card-bd{
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    
    .kv{
      min-width: 320px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding: 3px 5px;
      border-radius: 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
    }
    .kv .k{ font-size: 12px; opacity:.75; font-weight:700; }
    .kv .v{ font-weight: 900; }
    
    .hint.mini{ font-size: 12px; opacity: .65; line-height: 1.35; }
    .micro{ font-size: 12px; opacity: .6; margin-top: 6px; }
    
    /* waiting room */
    .waiting-room2{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }    
    .cap{
      font-size: 12px;
      opacity: .75;
      font-weight: 900;
      letter-spacing: .8px;
      margin-bottom: 8px;
    }
    
    .pill{
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      opacity:.9;
    }
    
    .seat2{
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 100%;
      min-height: 54px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: inherit;
      gap: 2px;
      padding: 10px 12px;
      cursor: pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .seat2:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.25);
    }
    .seat2:active{ transform: translateY(0px) scale(.99); }
    .seat2.empty{
      opacity: .75;
    }
    .seat2 .name{ font-weight: 900; }
    .seat2 .meta{ font-size: 12px; opacity: .7; }
    
    .seat2-grid{
      display:grid;
      margin-top: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    
    .spec-list{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .spec-chip{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 2px 15px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      font-weight: 900; 
      font-size: 12px;
    }
    
    .host-controls{
      margin-top: 8px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .lbl{
      font-size: 12px;
      opacity: .75;
      font-weight: 800;
    }
    .input{
      width:100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: inherit;
      outline: none;
    }

  </style>
</head>
<body>
<!-- =========================
  SCREEN: AUTH (m·∫∑c ƒë·ªãnh hi·ªán)
========================= -->
<div id="authScreen" class="screen active" style="margin-top: 25vh;">
  <!-- ƒêƒÉng nh·∫≠p / ƒêƒÉng k√Ω -->
  <div class="panel" id="authPanel" style="width:380px; margin:40px auto;">
    <header>
      <div class="title">ƒêƒÇNG NH·∫¨P</div>
    </header>
    <div class="content col">
      <input id="authEmail" placeholder="Email" />
      <input id="authPassword" type="password" placeholder="M·∫≠t kh·∫©u" />
      <input id="authUsername" placeholder="T√™n hi·ªÉn th·ªã (khi ƒëƒÉng k√Ω)" />

      <div class="row" style="display: flex;justify-content: center;">
        <button id="loginBtn">ƒêƒÉng nh·∫≠p</button>
        <button id="registerBtn" class="secondary">ƒêƒÉng k√Ω</button>
        <button id="playAnonBtn" class="secondary" style="flex:1">Ch∆°i th·ª≠</button>
      </div>
      <div id="authStatus" style="font-size:12px;color:var(--muted)"></div>
    </div>
  </div>
</div>


<!-- =========================
  SCREEN: LOBBY (·∫©n ban ƒë·∫ßu)
  D√πng l·∫°i roomPanel l√†m "S·∫£nh ch·ªù"
  (Kh√¥ng ƒë·ªïi id roomPanel ƒë·ªÉ JS/CSS kh·ªèi v·ª°)
========================= -->
<div id="lobbyScreen" class="screen lobby">
  <!-- Background layers -->
  <div class="lobby-bg"></div>
  <div class="lobby-vignette"></div>
  <div class="lobby-noise"></div>

  <div class="hud">
    <!-- Top bar -->
    <div class="lobby-topbar">
      <div class="brand">
        <div class="brand-logo"></div>
        <div class="brand-text">
          <div class="brand-title">CARD ARENA</div>
          <div class="brand-sub">Sandbox Tabletop ‚Ä¢ 4 Players</div>
        </div>
      </div>

      <div class="top-actions">
        <div class="top-pill" id="netPill">
          <span class="dot" id="netDot"></span>
          <span class="txt" id="netTxt">OFFLINE</span>
          <!-- gi·ªØ nguy√™n badge g·ªëc -->
          <div class="badge" id="netBadge" style="display:none">OFFLINE</div>
        </div>

        <button class="icon-btn" data-tab="tabNotifications" title="Th√¥ng b√°o">
          <span class="ico">üîî</span>
          <span class="bubble" id="notifBubble" style="display:none">1</span>
        </button>
        <button class="icon-btn" data-tab="tabShop" title="C·ª≠a h√†ng">
          <span class="ico">üõí</span>
        </button>

        <!-- gi·ªØ nguy√™n n√∫t logout c·ªßa b·∫°n (id=logoutBtn) nh∆∞ng ‚Äúƒë·∫∑t l√™n top bar‚Äù -->
        <button id="logoutBtn" class="danger top-logout">ƒêƒÉng xu·∫•t</button>
      </div>
    </div>

    <div class="lobby-shell">
      <!-- Sidebar navigation -->
      <aside class="lobby-sidebar">
        <div style="display: flex;
          padding: 5px 5px;
          gap: 5px;
          flex-direction: column;">
          <button class="nav-item active" data-tab="tabRoom">
            <span class="nav-ico">üè†</span><span class="nav-txt">T·∫°o / T√¨m ph√≤ng</span>
          </button>
          <button class="nav-item" data-tab="tabCustomize">
            <span class="nav-ico">üéõÔ∏è</span><span class="nav-txt">T√πy ch·ªânh</span>
          </button>
          <button class="nav-item" data-tab="tabInventory">
            <span class="nav-ico">üß∞</span><span class="nav-txt">T·ªß ƒë·ªì</span>
          </button>
          <button class="nav-item" data-tab="tabShop">
            <span class="nav-ico">üõí</span><span class="nav-txt">C·ª≠a h√†ng</span>
          </button>
          <button class="nav-item" data-tab="tabNotifications">
            <span class="nav-ico">üîî</span><span class="nav-txt">Th√¥ng b√°o</span>
          </button>
  
          <div class="sidebar-divider"></div>
  
          <!-- M·ª•c s√°ng t·∫°o th√™m -->
          <button class="nav-item" data-tab="tabQuickPlay">
            <span class="nav-ico">‚ö°</span><span class="nav-txt">Quick Play</span>
          </button>
          <button class="nav-item" data-tab="tabTutorial">
            <span class="nav-ico">üìò</span><span class="nav-txt">H∆∞·ªõng d·∫´n</span>
          </button>
          <button class="nav-item" data-tab="tabPatchNotes">
            <span class="nav-ico">üßæ</span><span class="nav-txt">Patch notes</span>
          </button>
        </div>
      </aside>

      <!-- Main content -->
      <main class="lobby-main">
        <!-- TAB: Room -->
        <section class="tab panel active" id="tabRoom">
          <div class="panel collapsible" id="roomPanel">
            <header>
              <div class="title">PH√íNG CH∆†I</div>
            </header>
            
          <div style="display: flex; flex-direction: column; height: 100%;">
            <!-- List ph√≤ng -->
            <div style="display:flex; width: 100%; flex-direction: column; height: 100%;">
              <!-- T√¨m ki·∫øm ph√≤ng -->
              <div style="display:flex;gap: 15px; padding: 5px; justify-content: space-between;">
                <div style="width: 70%">
                  <input id="roomSearchInput" placeholder="T√¨m ph√≤ng, v√≠ d·ª•: ROOM42" maxlength="255" /> 
                </div>
                <div style="width: 30%; display: flex; flex-direction: row; height: 100%; justify-content: flex-end;">
                  <button class="secondary" id="openCreateRoomBtn">T·∫°o ph√≤ng</button>
                </div>
              </div>
              <!-- list -->
              <div id="roomList" style="padding: 5px; height: 75%; overflow: auto;">
                <div id="listRoom" style="display: flex;
                flex-direction: column;
                gap: 5px;
                min-height: 100%;
                padding: 5px;
                overflow: auto;
                background: rgba(0,0,0,.22);
                border: 1px solid rgba(199,166,101,.18);
                border-radius: 12px;">
                  <!-- N∆°i load list ph√≤ng -->
                  <!-- M·ªói d√≤ng s·∫Ω c√≥ [M√£ ph√≤ng][T√™n ph√≤ng][N√∫t v√†o ph√≤ng] -->
                </div>
              </div>
            </div>
        </section>
        
        <!-- TAB: Customize -->
        <section class="tab" id="tabCustomize">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">T√ôY CH·ªàNH</div>
              <div class="sub">C√° nh√¢n h√≥a tr·∫£i nghi·ªám s·∫£nh & b√†n ch∆°i</div>
            </header>

            <div class="content col">
              <div class="grid-2">
                <div class="field">
                  <label>Theme</label>
                  <select id="uiThemeSelect">
                    <option value="gold">Gold Noir (LoL-like)</option>
                    <option value="emerald">Emerald</option>
                    <option value="crimson">Crimson</option>
                    <option value="ice">Ice</option>
                  </select>
                </div>

                <div class="field">
                  <label>Lobby motion</label>
                  <select id="uiMotionSelect">
                    <option value="full">Full</option>
                    <option value="reduced">Reduced</option>
                    <option value="off">Off</option>
                  </select>
                </div>

                <div class="field">
                  <label>Sound</label>
                  <div class="row">
                    <input type="range" id="uiSfx" min="0" max="100" value="40" />
                    <span class="mono" id="uiSfxTxt">40%</span>
                  </div>
                </div>

                <div class="field">
                  <label>FPS cap</label>
                  <select id="uiFpsSelect">
                    <option value="60">60</option>
                    <option value="90">90</option>
                    <option value="120">120</option>
                    <option value="uncapped">Uncapped</option>
                  </select>
                </div>
              </div>

              <div class="panel mini">
                <header class="mini-header">
                  <div class="title">Profile</div>
                  <div class="sub">T√™n hi·ªÉn th·ªã & tag</div>
                </header>
                <div class="content">
                  <div class="row">
                    <!-- d√πng l·∫°i nameInput g·ªëc -->
                    <div style="flex:1">
                      <label>T√™n hi·ªÉn th·ªã (ƒë√£ c√≥)</label>
                      <div class="mono-note">B·∫°n ch·ªânh tr·ª±c ti·∫øp ·ªü tab T·∫°o/T√¨m ph√≤ng (nameInput).</div>
                    </div>
                    <div style="min-width:220px">
                      <label>Clan tag</label>
                      <input id="clanTagInput" class="mono" placeholder="VD: HIC" maxlength="6"/>
                    </div>
                  </div>
                </div>
              </div>

              <div class="row" style="justify-content:flex-end; gap:10px">
                <button class="secondary" id="customResetBtn">Reset settings</button>
                <button id="customSaveBtn">Save</button>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Inventory -->
        <section class="tab" id="tabInventory">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">T·ª¶ ƒê·ªí</div>
              <div class="sub">Deck / SetCard ‚Ä¢ Back card ‚Ä¢ Cosmetics</div>
            </header>

            <div class="content col">
              <div class="row" style="align-items:flex-end">
                <div class="col" style="flex:1">
                  <label>Deck / SetCard</label>
                  <div class="hint">M·ªü c·∫•u h√¨nh b·ªô b√†i v√† set s·ªë l∆∞·ª£ng t·ª´ng lo·∫°i</div>
                </div>
                <!-- d√πng ƒë√∫ng id openDeckBtn ƒë√£ c√≥: n·∫øu b·∫°n mu·ªën n√≥ ‚Äúch·ªâ n·∫±m ·ªü ƒë√¢y‚Äù
                     th√¨ d√πng CSS ·∫©n trong roomPanel v√† hi·ªán trong tab n√†y b·∫±ng c√°ch move DOM b·∫±ng JS (·ªü d∆∞·ªõi) -->
                <button class="secondary" id="openDeckBtn">M·ªü Deck / SetCard</button>
              </div>

              <div class="grid-2">
                <div class="panel mini">
                  <header class="mini-header">
                    <div class="title">Deck images</div>
                    <div class="sub">Front folder + Back image</div>
                  </header>
                  <div class="content">
                    <div class="hint">B·∫°n ch·ªânh tr·ª±c ti·∫øp ·ªü tab T·∫°o/T√¨m ph√≤ng (frontBaseInput, backUrlInput) ƒë·ªÉ host apply.</div>
                    <div class="row" style="justify-content:flex-end">
                      <button class="secondary" id="invApplyDeckBtn">Apply deck images</button>
                    </div>
                  </div>
                </div>

                <div class="panel mini">
                  <header class="mini-header">
                    <div class="title">Cosmetics</div>
                    <div class="sub">Vi·ªÅn b√†i, hi·ªáu ·ª©ng k√©o th·∫£</div>
                  </header>
                  <div class="content">
                    <div class="row">
                      <label class="chk">
                        <input type="checkbox" id="cosGlow" checked />
                        <span>Card glow on hover</span>
                      </label>
                    </div>
                    <div class="row">
                      <label class="chk">
                        <input type="checkbox" id="cosTrail" />
                        <span>Drag trail</span>
                      </label>
                    </div>
                    <div class="row">
                      <label class="chk">
                        <input type="checkbox" id="cosRareFx" />
                        <span>Rare sparkle (host only)</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>

              <div class="panel mini">
                <header class="mini-header">
                  <div class="title">Presets</div>
                  <div class="sub">L∆∞u / t·∫£i nhanh deck preset</div>
                </header>
                <div class="content">
                  <div class="row">
                    <input id="presetName" placeholder="T√™n preset..." />
                    <button class="secondary" id="presetSave">Save preset</button>
                    <button class="secondary" id="presetLoad">Load preset</button>
                    <button class="danger" id="presetDelete">Delete</button>
                  </div>
                  <div class="hint">G·ª£i √Ω: preset gi√∫p host set s·∫µn b·ªô b√†i theo ‚Äúmode ch∆°i‚Äù (draft / poker / tcg...).</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Shop -->
        <section class="tab" id="tabShop">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">C·ª¨A H√ÄNG</div>
              <div class="sub">Mua cosmetics (client-side) ‚Ä¢ Kh√¥ng ·∫£nh h∆∞·ªüng gameplay</div>
            </header>

            <div class="content">
              <div class="shop-grid">
                <div class="shop-card">
                  <div class="shop-img"></div>
                  <div class="shop-title">Card Back: Obsidian</div>
                  <div class="shop-sub">Dark ‚Ä¢ Minimal ‚Ä¢ Premium</div>
                  <div class="shop-row">
                    <div class="price">1200</div>
                    <button class="secondary">Xem</button>
                    <button>Mua</button>
                  </div>
                </div>

                <div class="shop-card">
                  <div class="shop-img alt"></div>
                  <div class="shop-title">Border: Gold Line</div>
                  <div class="shop-sub">LoL-ish golden edge</div>
                  <div class="shop-row">
                    <div class="price">800</div>
                    <button class="secondary">Xem</button>
                    <button>Mua</button>
                  </div>
                </div>

                <div class="shop-card">
                  <div class="shop-img alt2"></div>
                  <div class="shop-title">Emote Pack</div>
                  <div class="shop-sub">Quick reactions</div>
                  <div class="shop-row">
                    <div class="price">500</div>
                    <button class="secondary">Xem</button>
                    <button>Mua</button>
                  </div>
                </div>
              </div>

              <div class="hint">B·∫°n c√≥ th·ªÉ n·ªëi c·ª≠a h√†ng v·ªõi inventory sau (localStorage / server profile).</div>
            </div>
          </div>
        </section>

        <!-- TAB: Notifications -->
        <section class="tab" id="tabNotifications">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">TH√îNG B√ÅO</div>
              <div class="sub">Th√¥ng tin h·ªØu √≠ch d√†nh cho c√°c b√†i th·ªß</div>
            </header>

            <div class="content col">
              <div class="notif-item">
                <div style="width: 80%; display: flex;
                  flex-direction: row;
                  align-items: flex-start;
                  gap: 10px;">
                  <div class="notif-dot"></div>
                  <div class="notif-body">
                    <div class="notif-title">Tip: S·ª≠ d·ª•ng ph√≠m t·∫Øt</div>
                    <div class="notif-sub">D√πng ph√≠m t·∫Øt khi ch∆°i ƒë·ªÉ thu·∫≠n ti·ªán h∆°n nh√©</div>
                  </div>
                </div>
                <div style="display: flex;
                  width: 20%;
                  flex-direction: column;
                  align-content: center;
                  justify-content: center;
                  align-items: center;">
                  <button class="secondary">ƒê√£ hi·ªÉu</button>
                </div>
              </div>

              <div class="row" style="justify-content:flex-end">
                <button class="danger" id="clearNotifBtn">X√≥a h·∫øt</button>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Quick Play (s√°ng t·∫°o) -->
        <section class="tab" id="tabQuickPlay">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">QUICK PLAY</div>
              <div class="sub">T·∫°o ph√≤ng nhanh v·ªõi c·∫•u h√¨nh ph·ªï bi·∫øn</div>
            </header>
            <div class="content">
              <div class="quick-grid">
                <button class="quick-card" data-quick="draft">
                  <div class="q-title">Draft</div>
                  <div class="q-sub">Deck preset: Draft 60</div>
                </button>
                <button class="quick-card" data-quick="poker">
                  <div class="q-title">Poker</div>
                  <div class="q-sub">Preset: 52 + Jokers</div>
                </button>
                <button class="quick-card" data-quick="tcg">
                  <div class="q-title">TCG</div>
                  <div class="q-sub">Preset: 40 ‚Ä¢ rarity fx</div>
                </button>
              </div>
              <div class="hint">Quick Play ch·ªâ ‚Äúƒëi·ªÅn s·∫µn‚Äù setCard/preset v√† t·∫°o ph√≤ng host.</div>
            </div>
          </div>
        </section>

        <!-- TAB: Tutorial (s√°ng t·∫°o) -->
        <section class="tab" id="tabTutorial">
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">H∆Ø·ªöNG D·∫™N</div>
              <div class="sub">Ph√≠m t·∫Øt ‚Ä¢ thao t√°c ‚Ä¢ m·∫πo</div>
            </header>
            <div class="content">
              <div class="tutorial-grid">
                <div class="tut-card">
                  <div class="tut-title">K√©o th·∫£ b√†i</div>
                  <div class="tut-sub">Drag ƒë·ªÉ di chuy·ªÉn ‚Ä¢ Shift ƒë·ªÉ snap (n·∫øu c√≥)</div>
                </div>
                <div class="tut-card">
                  <div class="tut-title">Host tools</div>
                  <div class="tut-sub">Reset b√†n ‚Ä¢ Apply deck images ‚Ä¢ SetCard</div>
                </div>
                <div class="tut-card">
                  <div class="tut-title">Sync</div>
                  <div class="tut-sub">Client g·ª≠i intent ‚Ä¢ host quy·∫øt ƒë·ªãnh state</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- TAB: Patch Notes (s√°ng t·∫°o) -->
        <section class="tab" id="tabPatchNotes" >
          <div class="panel soft">
            <header class="soft-header">
              <div class="title">PATCH NOTES</div>
              <div class="sub">Ghi ch√∫ c·∫≠p nh·∫≠t ‚Ä¢ roadmap</div>
            </header>
            <div class="content">
              <ul class="patch">
                <li><span class="tag new">NEW</span> Lobby modular tabs</li>
                <li><span class="tag imp">IMP</span> Better visual hierarchy + LoL-like theme</li>
                <li><span class="tag todo">TODO</span> Host migration, friends list, room browser</li>
              </ul>
            </div>
          </div>
        </section>
      </main>
    </div>
    <!-- Bottom dock: n√∫t li√™n quan / ti·ªán √≠ch nhanh -->
    <div class="lobby-dock">
      <div class="dock-left">
        <button class="secondary" id="dockRoomBtn">Ph√≤ng</button>
        <button class="secondary" id="dockBrowserBtn">Browser</button>
        <button class="secondary" id="dockDeckBtn">Deck</button>
      </div>
    
      <div class="dock-mid">
        <div class="dock-pill">
          <span class="dot"></span>
          <span class="txt" id="dockHint">Tip: Local mode m·ªü 4 tab</span>
        </div>
      </div>
    
      <div class="dock-right">
        <button class="secondary" id="dockCopyBtn">Copy link</button>
        <button class="danger" id="dockResetBtn">Reset</button>
        <button id="dockJoinBtn">Join</button>
      </div>
    </div>
  </div>
</div>

<!-- =========================
  SCREEN: MATCH (·∫©n ban ƒë·∫ßu)
  Gi·ªØ nguy√™n #app v√† m·ªçi id b√™n trong
========================= -->
<div id="matchScreen" class="screen">
  <div id="app">
    <canvas id="c"></canvas>
    <div id="toast"></div>

    <div class="hud lobby-hud">
      <div class="lobby-layout">
        <!-- RIGHT: LOBBY -->
        <div id="mainWaitingRoom" style="" class="panel lobby-card lobby-main">
          <header class="lobby-card-hd" style="display: flex;
          flex-direction: row;
          align-content: center;
          justify-content: center;
          align-items: center;">
            <div style="display: flex;  flex-direction: row; align-content: center; align-items: center;
              width: 90%; gap: 15px;">
              <div style="font-size: 12px; border: 1px solid rgb(215 255 62); border-radius: 999px;padding: 4px 8px;background: rgba(0,0,0,.12);" id="roomBadge">
                (Player)</div>
            </div>
            <div style="display: flex;justify-content: flex-end;align-items: center; width: 10%;align-content: center;">
              <button class="collapse-btn" data-target="mainWaitingRoom">‚àí</button>
            </div>
          </header>
    
          <div class="content lobby-card-bd">
    
            <!-- Seats -->
            <div id="waitingRoom" class="waiting-room2">
              <div class="wr2-top">    
                <div class="wr2-players">
                  <div class="kv">
                    <div style=" display: flex; width: 70%; flex-direction: row;align-items: center;
                      align-content: center; gap: 15px;">
                      <div class="k">B·∫°n l√†</div><div class="v" id="meLine">‚Äî</div>
                    </div>
                    <div>
                      <button id="leaveMatchBtn" class="danger" style="width:100%;">R·ªùi ph√≤ng</button>
                    </div>
                  </div>
                  <div class="sub" id="setupPhaseLine" 
                    style="padding-top: 20px; padding-bottom: 20px;display: flex;justify-content: center; align-items: center;font-size: 13px;">
                    ƒêang ch·ªù ng∆∞·ªùi ch∆°i...
                  </div>
                  <span style=" font-size: 12px;opacity: .75; font-weight: 900;letter-spacing: .8px;">GH·∫æ CH∆†I (Click v√†o gh·∫ø ƒë·ªÉ ch∆°i)</span>
                  <div class="seat2-grid">
                    <button class="seat2 slot" data-slot="play" data-seat="0" type="button"></button>
                    <button class="seat2 slot" data-slot="play" data-seat="1" type="button"></button>
                    <button class="seat2 slot" data-slot="play" data-seat="2" type="button"></button>
                    <button class="seat2 slot" data-slot="play" data-seat="3" type="button"></button>
                  </div>
                  <div class="micro">Gh·∫ø 1 l√† ch·ªß ph√≤ng</div>
                </div>
              </div>
    
              <!-- Spectators -->
              <div class="wr2-spec">
                <div class="cap row" style="justify-content:space-between; align-items:center;">
                  <span>NG∆Ø·ªúI XEM</span>
                  <span class="pill" id="specCount">0</span>
                </div>
                <div id="specList" class="spec-list"></div>
              </div>
            </div>
    
            <!-- StartGame / S·∫µn s√†ng -->
            <div id="blockStartGame" style="display: flex; width: 100%; align-items: center; justify-content: center; align-content: center;>
              <div style="display: flex; width: 100%; align-items: center; justify-content: center; align-content: center;">
                  <button id="startGameBtn" class="primary" style="width:50%">B·∫Øt ƒë·∫ßu ch∆°i</button>
              </div>
            </div>
          </div>
        </div>
    
      </div>
    </div>


    <!-- B·∫£ng score -->
    <div id="statusBoard" class="collapsed">
      <header>
        <div class="right">
          <button class="collapse-btn" id="sbToggle" type="button">+</button>
          <div class="title">B·∫£ng ƒëi·ªÉm</div>
        </div>
        
      </header>
      <div class="body" id="sbBody"></div>
    </div>

    <!-- Chat -->
    <div id="chatPanel" class="collapsible">
      <header>
        <div class="actions">
          <button class="collapse-btn" data-target="chatPanel" type="button">‚àí</button>
          <div class="chatToggle" id="chatToggle">
            <button type="button" data-mode="inGame" class="active">Tr·∫≠n ƒë·∫•u</button>
            <button type="button" data-mode="all">Th·∫ø gi·ªõi</button>
          </div>
        </div>
        <div class="titleRow">
          <div class="badge" id="chatBadge">0</div>
          <div class="title">CHAT</div>
        </div>
      </header>
    
      <div class="content">
        <div id="chatLog"></div>
        <form id="chatForm" autocomplete="off">
          <input id="chatInput" placeholder="Enter ƒë·ªÉ chat..." />
          <button id="chatSend" type="submit">Send</button>
        </form>
      </div>
    </div>


    <!-- Inspector -->
    <div id="inspector">
      <div class="panel" style="height:100%; display:flex; flex-direction:column;">
        <div class="content" style="display:flex; flex-direction:column; gap:3px; height:100%; padding: 5px">
          <div id="insPreview" style="
            display:flex; align-items:center; justify-content:center;
            overflow:hidden;
          ">
            <div style="color:rgba(233,236,255,.55); font-size:12px">Ch·ªçn 1 l√° b√†i...</div>
          </div>

          <div class="row" style="justify-content:space-between">
            <button id="btnFlip" class="secondary" style="flex:1">(W)Flip</button>
            <button id="btnDiscard" class="danger" style="flex:1">(T)Discard</button>
          </div>
          <div class="row" style="justify-content:space-between">
            <button id="btnUnstack" class="secondary" style="flex:1">(R)Unstack</button>
            <button id="btnShuffle" class="secondary" style="flex:1">(E)Shuffle</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Help -->
    <div class="panel collapsible" id="help">
      <div class="panel">
        <header>
          <div class="title">H∆∞·ªõng d·∫´n</div>
          <button class="collapse-btn" data-target="help">‚àí</button>
        </header>
        <div class="content hint">
          <div>
            <span class="kbd">K√©o th·∫£</span> chu·ªôt ƒë·ªÉ di chuy·ªÉn b√†i (table / hand).<br/>
            <span class="kbd">Q</span> r√∫t 1 l√° t·ª´ Deck v·ªÅ Hand c·ªßa b·∫°n (ƒë·ª©ng g·∫ßn Deck ho·∫∑c ch·ªçn Deck).<br/>
            <span class="kbd">W</span> l·∫≠t l√° / ch·ªìng (stack).<br/>
            <span class="kbd">E</span> tr·ªôn ch·ªìng (deck/stack).<br/>
            <span class="kbd">R</span> t√°ch 1 l√° ra kh·ªèi ch·ªìng (l·∫•y top).<br/>
            <span class="kbd">T</span> b·ªè l√° b√†i<br/>
            <span class="kbd">Click</span> ch·ªçn l√°/ch·ªìng. 
            <span class="kbd">Esc</span>/<span class="kbd">Click ngo√†i</span> b·ªè ch·ªçn.
          </div>
        </div>
      </div>
    </div>

  </div>
</div>


<!-- KHU V·ª∞C POPUP --------------------------------------------------------------------------------------------->
<div style="">
  <!-- POPUP T·∫°o ph√≤ng -->
  <div id="popupCreateRoom" class="modal" style="display:none;">
    <div class="modal-card content col" style="max-width:520px;">
      <header style="padding:10px 12px;background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
        border-bottom: 1px solid rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;
        gap:10px;border-radius:15px;">
        <div class="title">T·∫°o ph√≤ng</div>
        <button id="closeCreateRoomBtn" class="collapse-btn" type="button">√ó</button>
      </header>
  
      <div class="col" style="padding:12px; gap:10px;">
        <div class="col">
          <label>T√™n ph√≤ng</label>
          <input id="createRoomNameInput" placeholder="VD: Ph√≤ng c·ªßa Hi" maxlength="38"/>
        </div>
  
        <div class="col">
          <label>M·∫≠t kh·∫©u ph√≤ng (tu·ª≥ ch·ªçn)</label>
          <input id="createRoomPassInput" type="password" placeholder="ƒê·ªÉ tr·ªëng n·∫øu kh√¥ng ƒë·∫∑t" maxlength="32"/>
          <div style="opacity:.65;font-size:12px;margin-top:6px;">
            N·∫øu ƒë·∫∑t m·∫≠t kh·∫©u, ng∆∞·ªùi v√†o ph√≤ng ph·∫£i nh·∫≠p ƒë√∫ng m·ªõi join ƒë∆∞·ª£c.
          </div>
        </div>
  
        <div class="row" style="gap:10px; justify-content:flex-end;">
          <button id="doCreateRoomBtn" type="button">T·∫°o ph√≤ng</button>
        </div>
      </div>
    </div>
  </div>

  <!-- POPUP nh·∫≠p m·∫≠t kh·∫©u khi v√†o ph√≤ng -->
  <div id="popupJoinPass" class="modal" style="display:none;">
    <div class="modal-card">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <div style="font-weight:700;">Nh·∫≠p m·∫≠t kh·∫©u ph√≤ng</div>
        <button class="secondary" id="btnCloseJoinPass">X</button>
      </div>
  
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="joinPassInput" type="password" placeholder="M·∫≠t kh·∫©u..." style="flex:1;" />
        <button class="primary" id="btnJoinPassOk">V√†o ph√≤ng</button>
      </div>
  
      <div id="joinPassHint" style="margin-top:8px; font-size:12px; opacity:.7;"></div>
    </div>
  </div>

  <!-- POPUP Host setting -->
  <!-- Thanh c√¥ng c·ª• -->
  <div id="hostToolBar">
    <!-- add SetCard -->
    <div>
      
    </div>
    <!-- add token -->
    <div>
      
    </div>
    <!-- add image -->
    <div>
      
    </div>
    <!-- add text -->
    <div>
      
    </div>
    <!-- add Shapes -->
    <div>
      
    </div>
  </div>

  <!-- Popup setCard -->
  <div id="popupSetCard" style="display:none">
    <div class="cap">Th√™m b·ªô b√†i ƒë·ªÉ ch∆°i</div>
    <label class="lbl">B·ªô b√†i b·∫°n c√≥"</label>
    <select id="hostSetSelect" class="input"></select>

    <div class="row" style="gap:10px">
      <button id="hostRefreshSetsBtn" class="secondary" style="flex:1">Refresh set</button>
      <button id="hostLoadDeckBtn" class="secondary" style="flex:1">Load deck</button>
    </div>
  </div>
  
  
  <!-- =========================
    POPUP: Deck / SetCard
  ========================= -->
  <div id="deckModal" class="modal" style="display:none;">
    <div class="modal-card">
      <div style="
          display: flex;
          flex-direction: column;
          gap: 5px;
          min-height: 85vh;
          max-height: 85vh;
      ">
        <header style="padding: 10px 12px;background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
              border-bottom: 1px solid rgba(255,255,255,.06);display: flex;align-items: center;justify-content: space-between;
              gap: 10px;border-radius: 15px;">
              <div class="title">T√πy ch·ªânh b·ªô b√†i c·ªßa b·∫°n</div>
              <button id="closeDeckBtn" class="collapse-btn">√ó</button>
          </header>
        
      <div class="content col" style="gap:10px;overflow: hidden; display: flex; justify-content: space-between;">
        <div class="col" style="gap:6px">
          <label>B·ªô ƒë√£ l∆∞u</label>
          <div class="row">
            <select id="setSelect" style="flex:1; min-width:220px"></select>
            <button id="loadSetBtn" class="secondary">Load</button>
            <button id="deleteSetBtn" class="danger">X√≥a</button>
            <button style="margin-left:15px;" id="newSetBtn" class="secondary">+ T·∫°o b·ªô m·ªõi</button>
          </div>
        </div>
  
        <div class="col" style="gap:6px">
          <label>T√™n b·ªô b√†i</label>
          <input id="setNameInput" placeholder="VD: Poker / Game A" />
        </div>
  
        <div class="col" style="gap:6px">
          <label>URL h√¨nh ·∫£nh m·∫∑t sau l√° b√†i (link ·∫£nh .png .jpg)</label>
          <input id="setBackUrlInput" class="mono" placeholder="https://.../img.png" />
        </div>
  
        <div class="row" style="justify-content:space-between">
          <div class="hint">URL h√¨nh ·∫£nh m·∫∑t tr∆∞·ªõc l√° b√†i</div>
          <div style="display: flex; gap:5px;">
            <button id="addCardUrlBtn" class="secondary">+ Th√™m b√†i</button>
            <button id="saveSetBtn">L∆∞u b·ªô b√†i</button>
          </div>
        </div>
        <div style="justify-content: space-between;display: flex;gap: 8px;padding: 6px;background: #cae6ff0d;
          border-radius: 8px;width: 100%;font-family: inherit;font-size: 13px;align-items: center;margin-bottom: -5px;">
          <div style=" width: 38%;">T√™n l√° b√†i</div>
          <div style="width: 35%; ">URL h√¨nh ·∫£nh</div>
          <div >S·ªë l∆∞·ª£ng</div>
          <div style="width: 5%;"></div>
        </div>
        <div id="cardUrlList" class="col" style="gap:8px; max-height:240px; overflow:auto; padding-right:6px"></div>
      </div>
    </div>  
  </div>
</div>
<!-- H·∫æT PH·∫¶N POPUP -->
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script> 
<script>
/* =========================================================
   0) Utils / Core helpers (Firebase-only)
========================================================= */
"use strict";

const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const randInt = (a, b) => (Math.random() * (b - a + 1) + a) | 0;
const now     = () => Date.now();
const uid     = () => (
  crypto?.randomUUID
    ? crypto.randomUUID()
    : ("id_" + Math.random().toString(16).slice(2) + "_" + Date.now())
);
const deepClone = (obj) => (
  typeof structuredClone === "function"
    ? structuredClone(obj)
    : JSON.parse(JSON.stringify(obj))
);

function escapeHtml(str){
  return (str ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function toast(text, ms=1600){
  const el = document.getElementById("toast");
  if (!el) { console.log("[toast]", text); return; }
  el.textContent = text;
  el.style.display = "block";
  clearTimeout(el._t);
  el._t = setTimeout(()=> el.style.display="none", ms);
}

/* =========================================================
   1) Constants / Layout
========================================================= */
const COLORS = {
  red:   "#ff5c7a",
  blue:  "#5aa7ff",
  green: "#4ad37d",
  yellow:"#ffd166",
};
const COLOR_ORDER = ["red","blue","green","yellow"];

const ZONES = {
  table: "table",
  hand: "hand",
  deck: "deck",
  discard: "discard",
};

const CARD = { w: 86, h: 122, r: 12 };

const TABLE = {
  w: 1700,
  h: 900,
  margin: 40,
  handH: 150,
  sideW: 220,
  rightW: 260,
};

function zoneRects(){
  const m = TABLE.margin;
  const { w, h, handH, sideW, rightW } = TABLE;

  const tableRect = {
    x: m + sideW,
    y: m + handH,
    w: w - 2*m - sideW - rightW,
    h: h - 2*m - 2*handH
  };

  return {
    table: tableRect,

    handTopLeft: { x: tableRect.x, y: m, w: tableRect.w / 2, h: handH },
    handTopRight:{ x: tableRect.x + tableRect.w / 2, y: m, w: tableRect.w / 2, h: handH },

    handBottomLeft: { x: tableRect.x, y: tableRect.y + tableRect.h, w: tableRect.w / 2, h: handH },
    handBottomRight:{ x: tableRect.x + tableRect.w / 2, y: tableRect.y + tableRect.h, w: tableRect.w / 2, h: handH },

    handRightTop:    { x: w - m - rightW, y: tableRect.y, w: rightW, h: tableRect.h / 2 },
    handRightBottom: { x: w - m - rightW, y: tableRect.y + tableRect.h / 2, w: rightW, h: tableRect.h / 2 },

    deck:    { x: m, y: tableRect.y, w: sideW, h: tableRect.h / 2 },
    discard: { x: m, y: tableRect.y + tableRect.h / 2, w: sideW, h: tableRect.h / 2 }
  };
}

/* =========================================================
   2) Canvas / Camera
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

const camera = { scale: 1, offsetX: 0, offsetY: 0 };

function updateCamera(){
  const pad = 18;
  const sx = (innerWidth - pad*2) / TABLE.w;
  const sy = (innerHeight - pad*2) / TABLE.h;
  camera.scale = Math.min(sx, sy);
  camera.offsetX = (innerWidth - TABLE.w * camera.scale) / 2;
  camera.offsetY = (innerHeight - TABLE.h * camera.scale) / 2;
}
updateCamera();
addEventListener("resize", updateCamera);

function toScreen(p){
  return { x: camera.offsetX + p.x * camera.scale, y: camera.offsetY + p.y * camera.scale };
}
function toWorld(p){
  return { x: (p.x - camera.offsetX) / camera.scale, y: (p.y - camera.offsetY) / camera.scale };
}

/* =========================================================
   3) UI refs (gi·ªØ nguy√™n id c·ªßa b·∫°n) - Firebase-only
========================================================= */
const UI = {
  // b·ªè modeSelect/wsRow/wsUrlInput (kh√¥ng d√πng n·ªØa)

  nameInput: document.getElementById("nameInput"),
  roomInput: document.getElementById("roomInput"),
  createBtn: document.getElementById("createBtn"),
  joinBtn: document.getElementById("joinBtn"),
  copyLinkBtn: document.getElementById("copyLinkBtn"),
  resetBtn: document.getElementById("resetBtn"),
  netBadge: document.getElementById("netBadge"),
  roomBadge: document.getElementById("roomBadge"),
  meLine: document.getElementById("meLine"),
  hostLine: document.getElementById("hostLine"),
  playersLine: document.getElementById("playersLine"),
  chatBadge: document.getElementById("chatBadge"),
  chatLog: document.getElementById("chatLog"),
  chatForm: document.getElementById("chatForm"),
  chatInput: document.getElementById("chatInput"),
  frontBaseInput: document.getElementById("frontBaseInput"),
  backUrlInput: document.getElementById("backUrlInput"),
  applyDeckBtn: document.getElementById("applyDeckBtn"),
  setupPhaseLine: document.getElementById("setupPhaseLine"),
  hostSetupControls: document.getElementById("hostSetupControls"),
  hostToolBar: document.getElementById("hostToolBar"),
  blockStartGame: document.getElementById("blockStartGame"),
  hostSetSelect: document.getElementById("hostSetSelect"),
  hostRefreshSetsBtn: document.getElementById("hostRefreshSetsBtn"),
  hostLoadDeckBtn: document.getElementById("hostLoadDeckBtn"),
  startGameBtn: document.getElementById("startGameBtn"),
  createRoomNameInput: document.getElementById("createRoomNameInput"),
  createRoomPassInput: document.getElementById("createRoomPassInput"),
  doCreateRoomBtn: document.getElementById("doCreateRoomBtn"),
};

/* =========================================================
   4) Screens Router
========================================================= */
const SCREENS = {
  auth:  document.getElementById("authScreen")  || document.getElementById("screenAuth"),
  lobby: document.getElementById("lobbyScreen") || document.getElementById("screenLobby"),
  match: document.getElementById("matchScreen") || document.getElementById("screenMatch"),
};

function setScreen(name){
  for (const k in SCREENS){
    const el = SCREENS[k];
    if (el) el.classList.remove("active");
  }
  if (SCREENS[name]) SCREENS[name].classList.add("active");
}
function goAuth(){ setScreen("auth"); }
function goLobby(){ setScreen("lobby"); }
function goMatch(){
  setScreen("match");
  try{ resize(); updateCamera(); }catch(e){}
}
goAuth();

/* =========================================================
   5) Firebase-only helpers
========================================================= */
async function fbEnsureAuth(){
  if (typeof window.fbEnsureAuth === "function" && window.fbEnsureAuth !== fbEnsureAuth){
    return window.fbEnsureAuth();
  }
  if (!window.FB?.db) throw new Error("Firebase ch∆∞a kh·ªüi t·∫°o (FB.db kh√¥ng t·ªìn t·∫°i)");
  if (window.FB?.uid) return true;
  throw new Error("Ch∆∞a ƒëƒÉng nh·∫≠p Firebase (FB.uid ch∆∞a c√≥). H√£y login tr∆∞·ªõc.");
}

function getRoomRef(roomId){
  if (!window.FB?.db) throw new Error("Firebase ch∆∞a kh·ªüi t·∫°o (FB.db kh√¥ng t·ªìn t·∫°i)");
  if (!roomId) throw new Error("Thi·∫øu roomId");
  return FB.db.ref(`AllRoom/${roomId}`);
}

/* =========================================================
   6) Host setCard -> load v√†o room (Firebase-only)
========================================================= */
let _hostSetsCache = {}; // {setId: data}

async function refreshHostSetSelect(){
  await fbEnsureAuth();
  if (!UI.hostSetSelect) return;

  const snap = await FB.db.ref(`AllUser/${FB.uid}/setCard`).get();
  _hostSetsCache = snap.val() || {};

  UI.hostSetSelect.innerHTML = "";
  const ids = Object.keys(_hostSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(ch∆∞a c√≥ setCard)";
    UI.hostSetSelect.appendChild(op);
    return;
  }

  for (const id of ids){
    const set = _hostSetsCache[id] || {};
    const cnt = Object.keys(set.cards || {}).length;
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${set.name || id} (${cnt} lo·∫°i)`;
    UI.hostSetSelect.appendChild(op);
  }
}

async function hostLoadSelectedSetToRoom_FromSaved(){
  if (typeof client === "undefined") {
    throw new Error("client ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o (ƒë·∫∑t code n√†y SAU ƒëo·∫°n const client = {...})");
  }
  if (!client.isHost) return toast("Ch·ªâ host m·ªõi load deck");
  if (!(client.transport instanceof FirebaseTransport)) return toast("Ch·ª©c nƒÉng n√†y ch·ªâ d√πng trong Firebase");

  await fbEnsureAuth();

  if (!client.roomId) return toast("Ch∆∞a v√†o ph√≤ng / roomId tr·ªëng");
  if (!client.host?.state) return toast("Host state ch∆∞a s·∫µn s√†ng");

  const setId = UI.hostSetSelect?.value || "";
  if (!setId) return toast("Ch∆∞a ch·ªçn set");

  if (!_hostSetsCache[setId]) await refreshHostSetSelect();
  const data = _hostSetsCache[setId];
  if (!data) return toast("Set kh√¥ng t·ªìn t·∫°i");

  const types = Object.values(data.cards || {})
    .map(t=>({
      name: (t?.name || "").trim(),
      frontUrl: (t?.frontUrl || "").trim(),
      count: Math.max(1, parseInt(t?.count, 10) || 1),
    }))
    .filter(t => t.frontUrl && t.count > 0);

  const total = types.reduce((s,t)=> s + (t.count|0), 0);
  if (total <= 0) return toast("Set r·ªóng (ch∆∞a c√≥ URL / count)");

  const backUrl = (data.backUrl || "").trim();
  const roomRef = FB.db.ref(`AllRoom/${String(client.roomId).toLowerCase()}`)

  // meta: l∆∞u l·ªãch s·ª≠ nhi·ªÅu deck (append)
  const deckItem = {
    uid: FB.uid,
    setId,
    name: (data?.name || "Deck").slice(0,38),
    backUrl,
    total,
    types: types.length,
    at: now(),
  };
  await roomRef.child("meta/decks").push(deckItem);

  // build deck v√†o state
  const st = client.host.state;
  st.assets = st.assets || { backUrl:"" };
  st.assets.backUrl = backUrl;

  if (typeof hostCreateDeckFromSet !== "function"){
    throw new Error("hostCreateDeckFromSet ch∆∞a t·ªìn t·∫°i (b·∫°n ch∆∞a d√°n function ph·∫ßn B)");
  }

  hostCreateDeckFromSet(st, types, deckItem.name);

  if (typeof client.host.bumpVersion === "function") client.host.bumpVersion();
  await client.transport.writeState(st);

  toast(`ƒê√£ t·∫°o deck m·ªõi: ${types.length} lo·∫°i / ${total} l√°`);
}


/* =========================================================
   7) Wire UI buttons
========================================================= */
if (UI.hostRefreshSetsBtn){
  UI.hostRefreshSetsBtn.onclick = async ()=>{
    try{ await refreshHostSetSelect(); toast("ƒê√£ refresh set"); }
    catch(e){ console.error(e); toast(e?.message || e); }
  };
}

// =========================
// Host: Load setCard -> build deck v√†o room (Firebase-only)
// =========================
if (UI.hostLoadDeckBtn){
  UI.hostLoadDeckBtn.onclick = async ()=>{
    try{
      await hostLoadSelectedSetToRoom_FromSaved();
    }catch(e){
      console.error(e);
      toast(e?.message || e);
    }
  };
}

if (UI.startGameBtn){
  UI.startGameBtn.onclick = ()=>{
    if (!window.client) return toast("client ch∆∞a s·∫µn s√†ng");
    if (!client.isHost) return toast("Ch·ªâ host m·ªõi b·∫Øt ƒë·∫ßu");

    // ‚úÖ lu√¥n d√πng intent ƒë·ªÉ host authority x·ª≠ l√Ω
    if (typeof window.sendIntent === "function"){
      sendIntent({ type:"startGame" });
      toast("B·∫Øt ƒë·∫ßu!");
      return;
    }

    toast("sendIntent ch∆∞a s·∫µn s√†ng");
  };
}

/* =========================================================
   Inspector (card inspector popup)
========================================================= */
const INS = {
  preview: document.getElementById("insPreview"),
  btnFlip: document.getElementById("btnFlip"),
  btnDiscard: document.getElementById("btnDiscard"),
  btnUnstack: document.getElementById("btnUnstack"),
  btnShuffle: document.getElementById("btnShuffle"),
};

function getCardAny(st, cardId){
  return (st?.all?.cards?.[cardId]) || (st?.cards?.[cardId]) || null;
}
function getStackAny(st, stackId){
  return st?.stacks?.[stackId] || null;
}

function getWorldPosOfTarget(st, target){
  if (!st || !target) return null;
  if (target.type === "card"){
    const c = getCardAny(st, target.id);
    if (!c) return null;
    return {x: c.x, y: c.y};
  } else {
    const s = getStackAny(st, target.id);
    if (!s) return null;
    return {x: s.x, y: s.y};
  }
}

function getTargetScreenRect(st, target){
  const wp = getWorldPosOfTarget(st, target);
  if (!wp) return null;
  const sp = toScreen(wp);

  // card rect theo size render hi·ªán t·∫°i
  const w = CARD.w * camera.scale;
  const h = CARD.h * camera.scale;

  return {
    left: sp.x - w/2,
    right: sp.x + w/2,
    top: sp.y - h/2,
    bottom: sp.y + h/2,
    cx: sp.x,
    cy: sp.y,
  };
}

function smartPlaceInspector(insEl, avoidRect){
  const pad = 10;
  const vw = window.innerWidth;
  const vh = window.innerHeight;

  // ƒëo k√≠ch th∆∞·ªõc panel th·∫≠t
  insEl.style.visibility = "hidden";
  insEl.style.display = "block";
  insEl.style.left = "0px";
  insEl.style.top = "0px";

  const b = insEl.getBoundingClientRect();
  const iw = b.width || 320;
  const ih = b.height || 420;

  // N·∫øu kh√¥ng c√≥ rect ƒë·ªÉ n√©, ƒë·∫∑t g√≥c ph·∫£i tr√™n
  if (!avoidRect){
    const left = vw - iw - pad;
    const top  = pad;
    insEl.style.left = `${left}px`;
    insEl.style.top  = `${top}px`;
    insEl.style.visibility = "visible";
    return;
  }

  // 4 v·ªã tr√≠ ·ª©ng vi√™n: right, left, top, bottom
  const candidates = [];

  // right
  candidates.push({
    left: avoidRect.right + 16,
    top:  clamp(avoidRect.cy - ih/2, pad, vh - ih - pad),
    score: 0
  });
  // left
  candidates.push({
    left: avoidRect.left - iw - 16,
    top:  clamp(avoidRect.cy - ih/2, pad, vh - ih - pad),
    score: 0
  });
  // top
  candidates.push({
    left: clamp(avoidRect.cx - iw/2, pad, vw - iw - pad),
    top:  avoidRect.top - ih - 16,
    score: 0
  });
  // bottom
  candidates.push({
    left: clamp(avoidRect.cx - iw/2, pad, vw - iw - pad),
    top:  avoidRect.bottom + 16,
    score: 0
  });

  // ƒë√°nh ƒëi·ªÉm: ∆∞u ti√™n kh√¥ng tr√†n m√†n h√¨nh + xa card h∆°n
  for (const c of candidates){
    const overflowX = Math.max(0, pad - c.left) + Math.max(0, (c.left + iw + pad) - vw);
    const overflowY = Math.max(0, pad - c.top)  + Math.max(0, (c.top + ih + pad) - vh);
    const dx = (c.left + iw/2) - avoidRect.cx;
    const dy = (c.top + ih/2) - avoidRect.cy;
    const dist = Math.sqrt(dx*dx + dy*dy);

    // overflow l√† ph·∫°t n·∫∑ng
    c.score = dist - (overflowX + overflowY) * 9999;
  }

  candidates.sort((a,b)=> b.score - a.score);
  let best = candidates[0];

  // clamp cu·ªëi
  best.left = clamp(best.left, pad, vw - iw - pad);
  best.top  = clamp(best.top,  pad, vh - ih - pad);

  insEl.style.left = `${best.left}px`;
  insEl.style.top  = `${best.top}px`;
  insEl.style.visibility = "visible";
}

function positionInspectorNearTarget(){
  const st = getState?.();
  const sel = client?.selected;
  const ins = document.getElementById("inspector");
  if (!st || !sel || !ins) return;

  const rect = getTargetScreenRect(st, sel);
  smartPlaceInspector(ins, rect);
}

function showInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "block";
  updateInspector();
  requestAnimationFrame(positionInspectorNearTarget);
}

function hideInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "none";
}

function updateInspector(){
  const st = getState?.();
  const sel = client?.selected;

  if (!INS.preview) return;

  if (!st || !sel){
    INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Ch·ªçn 1 l√° b√†i...</div>`;
    return;
  }

  // enable/disable buttons theo selection
if (INS.btnFlip)    INS.btnFlip.disabled    = !sel;
if (INS.btnDiscard) INS.btnDiscard.disabled = !sel;
if (INS.btnUnstack) INS.btnUnstack.disabled = !(sel && sel.type === "stack");
if (INS.btnShuffle) INS.btnShuffle.disabled = !(sel && sel.type === "stack");

  // STACK
  if (sel.type === "stack"){
    const s = getStackAny(st, sel.id);
    if (!s){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Stack not found</div>`;
      return;
    }
    const topId = s.cardIds?.[0] || null;
    if (!topId){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Empty stack</div>`;
      return;
    }

    const c = getCardAny(st, topId);
    if (!c){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Top card missing</div>`;
      return;
    }

    const frontUrl = (c.frontUrl || "") || (st.assets?.frontBase ? (st.assets.frontBase + c.id + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">No image set</div>`;

    return;
  }

  // CARD
  if (sel.type === "card"){
    const c = getCardAny(st, sel.id);
    if (!c){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Card not found</div>`;
      return;
    }

    const frontUrl = (c.frontUrl || "") || (st.assets?.frontBase ? (st.assets.frontBase + c.id + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">No image set</div>`;
  }
}
function bindInspectorButtons(){
  // Re-query ƒë·ªÉ ch·∫Øc ch·∫Øn DOM ƒë√£ c√≥ n√∫t
  INS.preview    = document.getElementById("insPreview");
  INS.btnFlip    = document.getElementById("btnFlip");
  INS.btnDiscard = document.getElementById("btnDiscard");
  INS.btnUnstack = document.getElementById("btnUnstack");
  INS.btnShuffle = document.getElementById("btnShuffle");

  const inspectorEl = document.getElementById("inspector");
  if (inspectorEl){
    const stop = (e)=> { e.stopPropagation(); e.preventDefault(); };
    inspectorEl.addEventListener("mousedown", stop, {passive:false});
    inspectorEl.addEventListener("mousemove", stop, {passive:false});
    inspectorEl.addEventListener("mouseup",   stop, {passive:false});
    inspectorEl.addEventListener("click",     stop, {passive:false}); // ‚úÖ th√™m click
  }

  const safeSel = ()=>{
    const st = getState?.();
    const sel = client?.selected;
    if (!st || !sel) return null;
    return { st, sel };
  };

  // helper: bind 1 l·∫ßn (tr√°nh bind tr√πng n·∫øu g·ªçi l·∫°i)
  const bindOnce = (el, key, fn)=>{
    if (!el) return;
    if (el.dataset?.[key] === "1") return;
    el.dataset[key] = "1";
    el.addEventListener("click", (e)=>{ e.preventDefault(); e.stopPropagation(); fn(); }, {passive:false});
  };

  bindOnce(INS.btnFlip, "boundFlip", ()=>{
    const pack = safeSel(); if (!pack) return;
    const { sel } = pack;
    sendIntent({ type:"flip", targetType: sel.type, id: sel.id });
    updateInspector();
    requestAnimationFrame(positionInspectorNearTarget);
  });

  bindOnce(INS.btnDiscard, "boundDiscard", ()=>{
    const pack = safeSel(); if (!pack) return;
    const { sel } = pack;
    sendIntent({ type:"discard", targetType: sel.type, id: sel.id });
    updateInspector();
    requestAnimationFrame(positionInspectorNearTarget);
  });

  bindOnce(INS.btnUnstack, "boundUnstack", ()=>{
    const pack = safeSel(); if (!pack) return;
    const { sel } = pack;
    if (sel.type !== "stack") return;
    sendIntent({ type:"unstack", stackId: sel.id });
    updateInspector();
    requestAnimationFrame(positionInspectorNearTarget);
  });

  bindOnce(INS.btnShuffle, "boundShuffle", ()=>{
    const pack = safeSel(); if (!pack) return;
    const { sel } = pack;
    if (sel.type !== "stack") return;
    sendIntent({ type:"shuffle", stackId: sel.id });
    updateInspector();
    requestAnimationFrame(positionInspectorNearTarget);
  });
}

// ‚úÖ g·ªçi bind sau khi DOM s·∫µn s√†ng
// n·∫øu script c·ªßa b·∫°n n·∫±m cu·ªëi body th√¨ v·∫´n ok; n·∫øu kh√¥ng ch·∫Øc th√¨ d√πng DOMContentLoaded
if (document.readyState === "loading"){
  document.addEventListener("DOMContentLoaded", bindInspectorButtons);
} else {
  bindInspectorButtons();
}

/* =========================================================
   6) Networking (Firebase Realtime ONLY)
   - Client g·ª≠i intents -> /intents
   - Host listen intents, apply -> write /state
   - All clients listen /state
========================================================= */
class NetTransport {
  constructor(){
    this.onState = ()=>{};
    this.onStatus = ()=>{};
    this.onIntents = ()=>{}; // host only
  }
  close() {}
}

/* =========================================================
   FirebaseTransport (SINGLE SOURCE OF TRUTH)
   - FIX: ch·ªâ khai b√°o 1 l·∫ßn, tr√°nh "already declared"
   - H·ªó tr·ª£:
     + presence (.info/connected + onDisconnect)
     + users list (AllRoom/{roomId}/users)
     + state stream (AllRoom/{roomId}/state)
     + intents stream (AllRoom/{roomId}/intents) host x·ª≠ l√Ω r·ªìi ack
========================================================= */
class FirebaseTransport extends NetTransport {
  constructor(roomId){
    super();
    if (!roomId) throw new Error("Missing roomId");
    if (!FB?.db) throw new Error("FB.db missing");

    this.roomId = roomId;

    this.roomRef   = FB.db.ref(`AllRoom/${roomId}`);
    this.stateRef  = this.roomRef.child("state");
    this.intentsRef= this.roomRef.child("intents");
    this.metaRef   = this.roomRef.child("meta");
    this.usersRef  = this.roomRef.child("users");
    this.presRef   = this.roomRef.child(`presence/${FB.uid}`);

    this._stateCb = null;
    this._intentsCb = null;
    this._usersCb = null;

    this._connectedRef = FB.db.ref(".info/connected");
    this._connectedCb = null;

    // b√°o tr·∫°ng th√°i ban ƒë·∫ßu
    this.onStatus({connected:true, mode:"firebase"});
  }

  /* ---------- Presence ---------- */
  async attachPresence(){
    const uid = FB.uid;
    const roomRef = FB.db.ref(`AllRoom/${this.roomId}`);
    const myPresRef = roomRef.child(`presence/${uid}`);
    const myUserRef = roomRef.child(`users/${uid}`);
    const connectedRef = FB.db.ref(".info/connected");
  
    // l∆∞u ref/cb ƒë·ªÉ close() off ƒë∆∞·ª£c
    this._connectedRef = connectedRef;
  
    return new Promise((resolve)=>{
      let done = false;
  
      this._connectedCb = async (snap)=>{
        if (snap.val() !== true) return;
  
        try{ await myPresRef.onDisconnect().remove(); }catch(e){}
        try{ await myUserRef.onDisconnect().remove(); }catch(e){}
  
        try{
          await myPresRef.set({ uid, name: FB.username || "", at: Date.now() });
        }catch(e){}
  
        if (!done){ done = true; resolve(); }
      };
  
      connectedRef.on("value", this._connectedCb);
    });
  }

  /* ---------- Streams ---------- */
  listenUsers(onUsers){
    if (this._usersCb) return;
    this._usersCb = (snap)=> onUsers(snap.val() || {});
    this.usersRef.on("value", this._usersCb);
  }

  listenState(onState){
    if (this._stateCb) return;
    this._stateCb = (snap)=> onState(snap.val() || null);
    this.stateRef.on("value", this._stateCb);
  }

  // HOST: child_added intents, x·ª≠ l√Ω t·ª´ng c√°i r·ªìi ack
  listenIntentsAsHost(onIntent){
    if (this._intentsCb) return;
    this._intentsCb = (snap)=>{
      const v = snap.val();
      if (!v) return;
      onIntent(v, snap.key, snap.ref);
    };
    this.intentsRef.limitToLast(300).on("child_added", this._intentsCb);
  }

  /* ---------- Actions ---------- */
  async sendIntent(action){
    // th·ªëng nh·∫•t payload theo code b·∫°n ƒëang d√πng ·ªü create/join:
    // { fromId/fromName/at/action }
    const payload = {
      fromId: FB.uid,
      fromName: FB.username,
      at: now(),
      action
    };
    await this.intentsRef.push(payload);
  }

  async writeState(state){
    await this.stateRef.set(state);
  }

  async updateMeta(patch){
    await this.metaRef.update(patch);
  }

  async ackIntent(intentRef){
    if (!intentRef) return;
    await intentRef.remove().catch(()=>{});
  }

  /* ---------- Cleanup ---------- */
  close(){
    try{
      // off listeners
      if (this._stateCb)   this.stateRef.off("value", this._stateCb);
      if (this._intentsCb) this.intentsRef.off("child_added", this._intentsCb);
      if (this._usersCb)   this.usersRef.off("value", this._usersCb);
      if (this._connectedRef && this._connectedCb) {
        this._connectedRef.off("value", this._connectedCb);
      }
  
      this._stateCb = null;
      this._intentsCb = null;
      this._usersCb = null;
      this._connectedCb = null;
      this._connectedRef = null;
  
      // ‚úÖ leave ch·ªß ƒë·ªông: d·ªçn presence/users c·ªßa m√¨nh
      try{ this.presRef?.remove(); }catch(e){}
      try{ this.usersRef?.child(FB.uid)?.remove(); }catch(e){}
    }catch(e){}
  
    this.onStatus({connected:false, mode:"firebase"});
  }

}

/* =========================================================
   7) Game State / Redaction (Authoritative on Host)
========================================================= */
function makeFreshTableState(roomCode, hostId){
  const st = {
    roomCode,
    hostId,

    // ‚úÖ 4 gh·∫ø c·ªë ƒë·ªãnh, KH√îNG d·ªìn m·∫£ng
    players: [null, null, null, null],

    version: 1,
    assets: { backUrl:"" },  // back chung
    game: { phase:"waiting" },

    // ===== Card pool theo zone =====
    all: {
      cards: {}, // cardId -> card data (faceUp, frontUrl, ownerId...)
      onDeck: {},    // deckId -> { stackId }
      onHand: {},    // playerId -> { stackId }
      onTable: {},   // tableId -> { stackId } (c√≥ th·ªÉ d√πng 1 stackId duy nh·∫•t)
      onDiscard: {}, // discardId -> { stackId }
    },

    // ===== Stacks v·∫≠t l√Ω (ƒë·ªÉ drag/stack/unstack) =====
    stacks: {}, // stackId -> {id, zone, ownerId|null, x,y, cardIds:[]}
    chat: [],
    ui: { statHeaders:["ATK","DEF","HP","COIN"], statsByPlayer:{} },
  };

  return st;
}
  
function hostCreateDeckFromSet(st, types, deckName="Deck"){
  // types: [{name, frontUrl, count}]
  const rects = zoneRects();
  const deckRect = rects.deck;

  const deckId = "deck_" + uid().slice(0,6);
  const stackId = "stack_" + deckId;

  // t·∫°o 1 stack n·∫±m trong v√πng DECK
  st.stacks = st.stacks || {};
  st.all = st.all || {};
  st.all.cards = st.all.cards || {};
  st.all.onDeck = st.all.onDeck || {};

  st.stacks[stackId] = {
    id: stackId,
    zone: ZONES.deck,
    ownerId: null, // deck kh√¥ng c√≥ owner
    x: deckRect.x + deckRect.w/2 + randInt(-40,40),
    y: deckRect.y + deckRect.h/2 + randInt(-40,40),
    cardIds: []
  };

  st.all.onDeck[deckId] = { stackId, name: deckName, createdAt: now() };

  // t·∫°o card theo setCard
  for (const t of types){
    const frontUrl = (t.frontUrl||"").trim();
    const count = Math.max(1, parseInt(t.count,10)||1);
    const name = (t.name||"").trim();
    if (!frontUrl) continue;

    for (let i=0;i<count;i++){
      const cid = "C_" + uid().slice(0,10);

      st.all.cards[cid] = {
        id: cid,
        typeName: name,
        frontUrl,
        faceUp: false,     // m·∫∑c ƒë·ªãnh √∫p trong deck
        ownerId: null
      };

      // l√° m·ªõi t·∫°o n·∫±m tr√™n c√πng
      st.stacks[stackId].cardIds.unshift(cid);
    }
  }

  // shuffle ngay l√∫c t·∫°o (n·∫øu mu·ªën)
  const a = st.stacks[stackId].cardIds;
  for (let i=a.length-1;i>0;i--){
    const j = randInt(0,i);
    [a[i],a[j]] = [a[j],a[i]];
  }

  st.version = (st.version||0) + 1;
  return { deckId, stackId };
}

  
function ensureStateShape(state){
  const s = deepClone(state || {});

  // ‚úÖ normalize players: array OR object -> fixed 4 slots
  const outPlayers = [null, null, null, null];
  const srcP = s.players;

  if (Array.isArray(srcP)){
    for (let i=0;i<4;i++){
      const p = srcP[i];
      outPlayers[i] = (p && typeof p === "object") ? p : null;
    }
  } else if (srcP && typeof srcP === "object"){
    for (let i=0;i<4;i++){
      const p = srcP[i] || srcP[String(i)] || null;
      outPlayers[i] = (p && typeof p === "object") ? p : null;
    }
  }
  s.players = outPlayers;

  // ph·∫ßn c√≤n l·∫°i gi·ªØ nguy√™n logic c·ªßa b·∫°n
  if (!s.assets) s.assets = { backUrl:"" };
  if (!s.game) s.game = { phase:"waiting" };
  if (!s.ui) s.ui = { statHeaders:["ATK","DEF","HP","COIN"], statsByPlayer:{} };

  s.all = s.all || {};
  s.all.cards = s.all.cards || {};
  s.all.onDeck = s.all.onDeck || {};
  s.all.onHand = s.all.onHand || {};
  s.all.onTable = s.all.onTable || {};
  s.all.onDiscard = s.all.onDiscard || {};

  s.stacks = s.stacks || {};
  s.chat = Array.isArray(s.chat) ? s.chat : [];
  s.version = typeof s.version === "number" ? s.version : 1;
  return s;
}


function redactStateForViewer(state, viewerId){
  const base = ensureStateShape(state);
  if (!base) return null;

  // ‚úÖ clone n√¥ng ƒë·ªÉ tr√°nh mutate tr·ª±c ti·∫øp state g·ªëc
  const s = { ...base };

  // ‚úÖ normalize players v·ªÅ ƒë√∫ng 4 gh·∫ø (0..3), d√π Firebase tr·∫£ array hay object
  const srcP = base.players;
  const players = [null, null, null, null];

  if (Array.isArray(srcP)){
    for (let i=0;i<4;i++){
      const p = srcP[i];
      players[i] = (p && typeof p === "object") ? p : null;
    }
  } else if (srcP && typeof srcP === "object"){
    for (let i=0;i<4;i++){
      const p = srcP[i] || srcP[String(i)] || null;
      players[i] = (p && typeof p === "object") ? p : null;
    }
  }
  s.players = players;

  // ‚úÖ t√¨m viewer (kh√¥ng d√πng .find tr√™n object n·ªØa)
  let viewer = null;
  for (let i=0;i<4;i++){
    const p = players[i];
    if (p && p.id === viewerId){ viewer = p; break; }
  }

  // ‚úÖ cards c√≥ th·ªÉ n·∫±m ·ªü s.cards ho·∫∑c s.all.cards (tu·ª≥ version code)
  const srcCards = (base.all && base.all.cards) ? base.all.cards : (base.cards || {});
  const cards = { ...srcCards };

  // che b√†i ng∆∞·ªùi kh√°c tr√™n tay
  for (const cardId in cards){
    const c0 = cards[cardId];
    if (!c0) continue;

    // clone card object ƒë·ªÉ kh√¥ng mutate b·∫£n g·ªëc
    const c = { ...c0 };

    const ownerId = (c.ownerId ?? c.owner ?? null);

    if (c.zone === ZONES.hand && ownerId && ownerId !== viewerId){
      c.faceUp = false;
      c.frontSeed = 0;
      if (c.frontUrl) c.frontUrl = "";
    }

    cards[cardId] = c;
  }

  // g·∫Øn l·∫°i v√†o ƒë√∫ng ch·ªó
  if (base.all && base.all.cards){
    s.all = { ...(base.all || {}), cards };
  } else {
    s.cards = cards;
  }

  s._viewer = viewer ? { id: viewer.id, name: viewer.name, color: viewer.color } : null;
  return s;
}


/* =========================================================
   8) Host Controller (Authoritative) - Firebase-only
========================================================= */
function canInteract(card, actorId){
  if (!card) return false;
  if (card.zone === ZONES.hand) return card.owner === actorId;
  return true; // table/deck/discard allow (deck dragging is blocked separately)
}
function canInteractStack(stack, actorId){
  if (!stack) return false;
  const owner = stack.owner ?? stack.ownerId ?? null;
  if (stack.zone === ZONES.hand) return owner === actorId;
  return true;
}

const ensureUIState = (st) => {
  st.ui = st.ui || {};
  st.ui.statHeaders = st.ui.statHeaders || ["ATK","DEF","HP","COIN"];
  st.ui.statsByPlayer = st.ui.statsByPlayer || {};
};

class HostController {
  constructor(roomCode, hostId){
    this.roomCode = roomCode;
    this.hostId = hostId;
    this.state = makeFreshTableState(roomCode, hostId);
  }

  bumpVersion(){
    this.state.version = (this.state.version || 0) + 1;
  }
  
  addOrUpdatePlayerAtSeat(id, name, seat){
    if (!id) return { ok:false, reason:"Missing id" };
    seat = seat|0;
    
    if (seat < 0 || seat > 3) return { ok:false, reason:"Bad seat" };
    
    if (!Array.isArray(this.state.players)) this.state.players = [];
    const ps = this.state.players;
  
    // n·∫øu player ƒë√£ ·ªü seat kh√°c -> clear seat c≈©
    for (let i=0; i<4; i++){
      const p = ps[i];
      if (p && p.id === id){
        ps[i] = null;
        break;
      }
    }
  
    // n·∫øu seat ƒëang c√≥ ng∆∞·ªùi kh√°c -> t·ª´ ch·ªëi (ƒë·ªÉ tr√°nh ch·ªìng)
    const occ = ps[seat];
    if (occ && occ.id !== id){
      return { ok:false, reason:"Seat occupied" };
    }
  
    // ch·ªçn m√†u theo seat (ƒë·ªìng b·ªô canvas)
    const color = (typeof COLOR_ORDER !== "undefined" && Array.isArray(COLOR_ORDER) && COLOR_ORDER.length)
      ? (COLOR_ORDER[seat % COLOR_ORDER.length] || "gray")
      : (["red","blue","green","purple"][seat] || "gray");
  
    const p = { id, name: name || "Player", color, seat, connectedAt: now() };
    ps[seat] = p;
  
    ensureUIState(this.state);
    if (!this.state.ui.statsByPlayer[p.id]) this.state.ui.statsByPlayer[p.id] = ["","","",""];
  
    this.bumpVersion();
    return { ok:true, player:p };
  }

  removePlayer(id){
    if (!Array.isArray(this.state.players)) this.state.players = [];
    const ps = this.state.players;
  
    for (let i=0; i<4; i++){
      const p = ps[i];
      if (p && p.id === id){
        ps[i] = null; // ‚úÖ clear slot, kh√¥ng d·ªìn m·∫£ng
        break;
      }
    }
  
    this.bumpVersion();
  }


  // ==============================
  // Helpers (t√°ch ra ƒë·ªÉ d·ªÖ b·∫£o tr√¨)
  // ==============================
  _ensureState(){
    const curHostId = this.state?.hostId || this.hostId || "";
    const st = this.state = ensureStateShape(this.state) || makeFreshTableState(this.roomCode, curHostId);
    ensureUIState(st);

    // ƒë·∫£m b·∫£o shape t·ªëi thi·ªÉu
    st.all = st.all || {};
    st.all.cards = st.all.cards || {};
    st.stacks = st.stacks || {};

    return st;
  }

  _ensureCard(st, id){
    return (st.all?.cards?.[id]) || (st.cards?.[id]) || null; // t∆∞∆°ng th√≠ch n·∫øu b·∫°n c√≤n st.cards
  }

  _ensureStack(st, id){
    return st.stacks?.[id] || null;
  }

  _removeCardEverywhere(st, cardId){
    // x√≥a kh·ªèi all.cards (ngu·ªìn ch√≠nh)
    if (st.all?.cards?.[cardId]) delete st.all.cards[cardId];
    // t∆∞∆°ng th√≠ch c≈©
    if (st.cards?.[cardId]) delete st.cards[cardId];

    // x√≥a kh·ªèi m·ªçi stack.cardIds
    Object.values(st.stacks || {}).forEach(ss=>{
      if (!ss?.cardIds) return;
      const idx = ss.cardIds.indexOf(cardId);
      if (idx >= 0) ss.cardIds.splice(idx, 1);
    });
  }

  _deleteStackHard(st, stackId){
    const ss = this._ensureStack(st, stackId);
    if (!ss) return;

    // x√≥a to√†n b·ªô card trong stack
    const ids = Array.isArray(ss.cardIds) ? ss.cardIds.slice() : [];
    for (const cid of ids) this._removeCardEverywhere(st, cid);

    delete st.stacks[stackId];
  }

  _detachFromStack(st, cardId){
    const c = this._ensureCard(st, cardId);
    if (!c || !c.stackId) return;

    const ss = this._ensureStack(st, c.stackId);
    if (!ss) { c.stackId = null; return; }

    ss.cardIds = (ss.cardIds || []).filter(id => id !== cardId);
    c.stackId = null;

    // x√≥a stack r·ªóng (tr·ª´ stack h·ªá th·ªëng n·∫øu b·∫°n mu·ªën gi·ªØ)
    if ((ss.cardIds?.length || 0) === 0 && ss.id !== "stack_deck" && ss.id !== "stack_table" && ss.id !== "stack_discard"){
      delete st.stacks[ss.id];
    }
  }

  _createStackFromCard(st, cardId){
    const c = this._ensureCard(st, cardId);
    if (!c) return null;

    const sid = "stack_" + uid().slice(0,8);
    const zone = c.zone ?? ZONES.table;
    const owner = (zone === ZONES.hand) ? (c.ownerId ?? c.owner ?? null) : null;

    st.stacks[sid] = { id:sid, zone, owner, ownerId: owner, x:c.x, y:c.y, cardIds:[cardId] };
    c.stackId = sid;
    return sid;
  }

  _seatToHandKey(seat){
    switch (seat){
      case 0: return "handTopLeft";
      case 1: return "handBottomLeft";
      case 2: return "handTopRight";
      case 3: return "handBottomRight";
      default: return null;
    }
  }

  applyIntent(fromId, action){
    const st = this._ensureState();

    // ch·ªâ allow n·∫øu ƒë√£ join (tr·ª´ action join)
    const player = (st.players || []).find(p => p && p.id === fromId);
    const isHost = (fromId === (st.hostId || ""));
    if (!player && !isHost && action?.type !== "join") return { ok:false, reason:"Not in room" };


    const rects = zoneRects();

    // ‚úÖ 4 hand zones mapping ƒë√∫ng 4 ng∆∞·ªùi
    const HAND_ZONES = [
      { key: "handTopLeft", seat: 0 },
      { key: "handBottomLeft", seat: 1 },
      { key: "handTopRight", seat: 2 },
      { key: "handBottomRight", seat: 3 },
    ];

    const normalizeCardZoneFromPos = (x, y) => {
      // ‚úÖ DECK ZONE
      {
        const r = rects.deck;
        if (r){
          const inRect =
            x >= r.x && x <= r.x + r.w &&
            y >= r.y && y <= r.y + r.h;
          if (inRect) return { zone: ZONES.deck, owner: null };
        }
      }
    
      // ‚úÖ DISCARD ZONE (n·∫øu c·∫ßn)
      {
        const r = rects.discard;
        if (r){
          const inRect =
            x >= r.x && x <= r.x + r.w &&
            y >= r.y && y <= r.y + r.h;
          if (inRect) return { zone: ZONES.discard, owner: null };
        }
      }
    
      // ‚úÖ HAND ZONES
      for (const hz of HAND_ZONES){
        const r = rects[hz.key];
        if (!r) continue;
    
        const inRect =
          x >= r.x && x <= r.x + r.w &&
          y >= r.y && y <= r.y + r.h;
        if (!inRect) continue;
    
        const ownerPlayer = st.players.find(pp => pp && pp.seat === hz.seat);
        if (!ownerPlayer) return { zone: ZONES.table, owner: null };
    
        return { zone: ZONES.hand, owner: ownerPlayer.id };
      }
    
      // ‚úÖ TABLE (default)
      return { zone: ZONES.table, owner: null };
    };


    switch (action.type){
      case "move": {
        const { targetType, id, x, y } = action;
      
        if (targetType === "card"){
          const c = this._ensureCard(st, id);
          if (!c || !canInteract(c, fromId)) return { ok:false, reason:"No access" };
      
          // t√°ch kh·ªèi stack (n·∫øu c√≥)
          this._detachFromStack(st, id);
      
          const z = normalizeCardZoneFromPos(x, y);
      
          c.x = x; c.y = y;
          c.zone = z.zone;
      
          st._z = (st._z || 0) + 1;
          c.z = st._z;
      
          if (z.zone === ZONES.hand){
            const handOwner = z.owner ?? null;
            if (handOwner){
              c.owner = handOwner;
              c.ownerId = handOwner;
      
              // v√†o tay ng∆∞·ªùi kh√°c th√¨ √∫p
              if (handOwner !== fromId) c.faceUp = false;
            } else {
              // fallback -> coi nh∆∞ table
              c.zone = ZONES.table;
            }
          } else if (z.zone === ZONES.deck){
            // ‚úÖ CH·ªà y√™u c·∫ßu c·ªßa b·∫°n: v√†o deck zone th√¨ reset vi·ªÅn/ch·ªß
            c.owner = null;
            c.ownerId = null;
            // deck zone kh√¥ng b·∫Øt bu·ªôc √∫p, nh∆∞ng b·∫°n mu·ªën th√¨ b·∫≠t:
            // c.faceUp = false;
          } else {
            // table ho·∫∑c discard: ‚úÖ gi·ªØ nguy√™n owner/ownerId (gi·ªØ vi·ªÅn nh∆∞ b·∫°n mu·ªën)
          }
      
          // card r·ªùi
          c.stackId = null;
        }
      
        if (targetType === "stack"){
          const ss = this._ensureStack(st, id);
          if (!ss) return { ok:false, reason:"Missing stack" };
          if (!canInteractStack(ss, fromId)) return { ok:false, reason:"No access" };
      
          const z = normalizeCardZoneFromPos(x, y);
      
          ss.x = x; ss.y = y;
          st._z = (st._z || 0) + 1;
          ss.z = st._z;
      
          // zone/owner c·ªßa stack
          if (z.zone === ZONES.hand){
            const handOwner = z.owner ?? null;
            if (handOwner){
              ss.zone = ZONES.hand;
              ss.owner = handOwner;
            } else {
              ss.zone = ZONES.table;
              ss.owner = null;
            }
          } else {
            // ‚úÖ cho ph√©p stack n·∫±m ·ªü deck/discard/table ƒë√∫ng zone
            ss.zone = z.zone;
            ss.owner = null;
      
            // ‚úÖ ch·ªâ khi stack v√†o deck zone th√¨ reset vi·ªÅn/ch·ªß c·ªßa stack (n·∫øu stack c√≥ d√πng vi·ªÅn)
            if (z.zone === ZONES.deck){
              ss.owner = null;
              ss.ownerId = null;
            }
          }
      
          // sync cards theo stack
          for (const cid of (ss.cardIds || [])){
            const c = this._ensureCard(st, cid);
            if (!c) continue;
      
            c.stackId = ss.id;
            c.x = ss.x;
            c.y = ss.y;
            c.zone = ss.zone;
      
            if (ss.zone === ZONES.hand && ss.owner){
              c.owner = ss.owner;
              c.ownerId = ss.owner;
              c.faceUp = false;
            } else if (ss.zone === ZONES.deck){
              // ‚úÖ stack n·∫±m trong deck zone th√¨ reset vi·ªÅn/ch·ªß c·ªßa c√°c l√° (ƒë√∫ng y√™u c·∫ßu)
              c.owner = null;
              c.ownerId = null;
              // c.faceUp = false; // n·∫øu mu·ªën deck zone lu√¥n √∫p
            } else {
              // table/discard: ‚úÖ gi·ªØ nguy√™n vi·ªÅn/ch·ªß
            }
          }
        }
      
        this.bumpVersion();
        return { ok:true };
      }

      case "flip": {
        const { targetType, id } = action;

        if (targetType === "card"){
          const c = this._ensureCard(st, id);
          if (!c || !canInteract(c, fromId)) return { ok:false, reason:"No access" };
          c.faceUp = !c.faceUp;
        } else {
          const ss = this._ensureStack(st, id);
          if (!ss || !canInteractStack(ss, fromId)) return { ok:false, reason:"No access" };
          const topId = ss.cardIds?.[0];
          if (topId){
            const c = this._ensureCard(st, topId);
            if (c) c.faceUp = !c.faceUp;
          }
        }

        this.bumpVersion();
        return { ok:true };
      }

      case "shuffle": {
        const { stackId } = action;
        const ss = this._ensureStack(st, stackId);
        if (!ss || !canInteractStack(ss, fromId)) return { ok:false, reason:"No access" };

        for (let i = (ss.cardIds?.length||0) - 1; i > 0; i--){
          const j = randInt(0, i);
          [ss.cardIds[i], ss.cardIds[j]] = [ss.cardIds[j], ss.cardIds[i]];
        }

        this.bumpVersion();
        return { ok:true };
      }

      // ‚úÖ Draw: stack n√†o ƒë∆∞·ª£c ch·ªçn th√¨ coi nh∆∞ deck, r√∫t random, stack m·∫•t l√°
      case "draw": {
        const { stackId, count = 1, random = true } = action || {};
        if (!stackId) return { ok:false, reason:"Missing stackId" };

        const deck = this._ensureStack(st, stackId);
        if (!deck) return { ok:false, reason:"Missing stack" };
        if (!canInteractStack(deck, fromId)) return { ok:false, reason:"No access" };

        deck.cardIds = Array.isArray(deck.cardIds) ? deck.cardIds : [];
        if (deck.cardIds.length === 0) return { ok:false, reason:"Empty stack" };

        const n = Math.max(1, Math.min(50, count|0));

        const mySeat = (st.players||[]).find(p => p && p.id === fromId)?.seat ?? -1;
        const handKey = this._seatToHandKey(mySeat);
        const hr = handKey ? rects[handKey] : null;

        for (let i = 0; i < n; i++){
          if (deck.cardIds.length === 0) break;

          const idx = random ? randInt(0, deck.cardIds.length - 1) : (deck.cardIds.length - 1);
          const [cid] = deck.cardIds.splice(idx, 1);
          if (!cid) break;

          const c = this._ensureCard(st, cid);
          if (!c) continue;

          // ra kh·ªèi stack -> v√†o hand
          c.stackId = null;
          c.zone = ZONES.hand;
          c.owner = fromId;
          c.ownerId = fromId;
          //c.faceUp = false; 

          if (hr){
            c.x = hr.x + randInt(40, Math.max(40, hr.w - 40));
            c.y = hr.y + randInt(40, Math.max(40, hr.h - 40));
          } else {
            // fallback b√†n
            c.zone = ZONES.table;
            c.owner = null;
            c.ownerId = null;
            c.x = rects.table.x + rects.table.w/2 + randInt(-120, 120);
            c.y = rects.table.y + rects.table.h/2 + randInt(-80, 80);
          }
        }

        // n·∫øu stack r·ªóng th√¨ x√≥a (tu·ª≥ b·∫°n)
        if (deck.id !== "stack_deck" && deck.id !== "stack_table" && deck.id !== "stack_discard" && deck.cardIds.length === 0){
          delete st.stacks[deck.id];
        }

        this.bumpVersion();
        return { ok:true };
      }

      // ‚úÖ Delete: host-only
      case "delete": {
        if (fromId !== st.hostId) return { ok:false, reason:"Host only" };

        const { targetType, id } = action || {};
        if (!targetType || !id) return { ok:false, reason:"Missing target" };

        if (targetType === "card"){
          this._removeCardEverywhere(st, id);
          this.bumpVersion();
          return { ok:true };
        }

        if (targetType === "stack"){
          if (id === "stack_table" || id === "stack_discard") return { ok:false, reason:"Cannot delete system stack" };
          this._deleteStackHard(st, id);
          this.bumpVersion();
          return { ok:true };
        }

        return { ok:false, reason:"Bad targetType" };
      }

      case "discard": {
        const { targetType, id } = action;
        const r = rects.discard;
      
        // v·ªã tr√≠ th·∫£ trong discard zone (g·∫ßn gi·ªØa + random nh·∫π)
        const pickDiscardPos = () => ({
          x: r.x + randInt(30, Math.max(30, r.w - 30)),
          y: r.y + randInt(30, Math.max(30, r.h - 30)),
        });
      
        const placeCardAloneInDiscard = (c) => {
          if (!c) return;
      
          // N·∫øu card ƒëang trong stack th√¨ t√°ch ra (v√¨ ta ƒëang discard "l√° r·ªùi")
          if (c.stackId) this._detachFromStack(st, c.id);
      
          const p = pickDiscardPos();
          c.x = p.x; c.y = p.y;
      
          c.zone = ZONES.discard;
      
          // ‚úÖ theo y√™u c·∫ßu tr∆∞·ªõc c·ªßa b·∫°n: table/discard gi·ªØ vi·ªÅn/ch·ªß
          // -> KH√îNG reset ownerId ·ªü ƒë√¢y
          // N·∫øu b·∫°n mu·ªën discard trung l·∫≠p th√¨ m·ªü 2 d√≤ng d∆∞·ªõi:
          // c.owner = null;
          // c.ownerId = null;
      
          // discard th∆∞·ªùng faceUp ƒë·ªÉ xem ƒë∆∞·ª£c
          c.faceUp = true;
      
          c.stackId = null;
        };
      
        const placeStackInDiscard = (ss) => {
          if (!ss) return;
      
          const p = pickDiscardPos();
      
          // ƒë∆∞a c·∫£ stack v√†o discard nh∆∞ 1 stack b√¨nh th∆∞·ªùng
          ss.x = p.x;
          ss.y = p.y;
          ss.zone = ZONES.discard;
          ss.owner = null;
          // n·∫øu stack c√≥ ownerId ƒë·ªÉ v·∫Ω vi·ªÅn m√† b·∫°n mu·ªën gi·ªØ, th√¨ ƒë·ª´ng reset
          // ss.ownerId = null; // ch·ªâ b·∫≠t n·∫øu b·∫°n mu·ªën discard reset vi·ªÅn stack
      
          st._z = (st._z || 0) + 1;
          ss.z = st._z;
      
          // sync c√°c card theo stack (GI·ªÆ stackId, KH√îNG unstack)
          for (const cid of (ss.cardIds || [])) {
            const c = this._ensureCard(st, cid);
            if (!c) continue;
      
            c.stackId = ss.id;
            c.x = ss.x;
            c.y = ss.y;
            c.zone = ZONES.discard;
      
            // discard pile th∆∞·ªùng cho xem
            c.faceUp = true;
      
            // ‚úÖ gi·ªØ vi·ªÅn/ch·ªß theo y√™u c·∫ßu (kh√¥ng reset owner/ownerId)
            // n·∫øu b·∫°n mu·ªën discard trung l·∫≠p th√¨ b·∫≠t:
            // c.owner = null;
            // c.ownerId = null;
          }
        };
      
        if (targetType === "card") {
          const c = this._ensureCard(st, id);
          if (!c || !canInteract(c, fromId)) return { ok:false, reason:"No access" };
          placeCardAloneInDiscard(c);
        } else {
          const ss = this._ensureStack(st, id);
          if (!ss || !canInteractStack(ss, fromId)) return { ok:false, reason:"No access" };
          placeStackInDiscard(ss);
        }
      
        this.bumpVersion();
        return { ok:true };
      }


      case "stack": {
        const { dragTargetType, dragId, dropOnType, dropOnId } = action;

        const isOtherHand = (zone, ownerId) => (zone === ZONES.hand) && ownerId && ownerId !== fromId;

        let moving = [];
        let srcStackId = null;

        if (dragTargetType === "card"){
          const c = this._ensureCard(st, dragId);
          if (!c || !canInteract(c, fromId)) return { ok:false, reason:"No access" };
          if (c.stackId === "stack_deck") return { ok:false, reason:"Cannot stack from deck (use draw)" };

          moving = [dragId];
          srcStackId = c.stackId || null;
        } else {
          const ss = this._ensureStack(st, dragId);
          if (!ss || !canInteractStack(ss, fromId)) return { ok:false, reason:"No access" };
          if (ss.id === "stack_deck") return { ok:false, reason:"Deck fixed" };

          moving = [...(ss.cardIds || [])];
          srcStackId = ss.id;
        }

        if (moving.length === 0) return { ok:false, reason:"Nothing to stack" };

        // resolve drop stack
        let dropStackId = null;

        if (dropOnType === "card"){
          const c2 = this._ensureCard(st, dropOnId);
          if (!c2) return { ok:false, reason:"Missing drop card" };
          if (c2.stackId === "stack_deck") return { ok:false, reason:"Cannot stack onto deck" };
          if (isOtherHand(c2.zone, c2.owner)) return { ok:false, reason:"Cannot stack into other player's hand" };

          dropStackId = c2.stackId || this._createStackFromCard(st, c2.id);
        } else {
          const s2 = this._ensureStack(st, dropOnId);
          if (!s2) return { ok:false, reason:"Missing drop stack" };
          if (s2.id === "stack_deck") return { ok:false, reason:"Cannot stack onto deck" };
          if (isOtherHand(s2.zone, s2.owner)) return { ok:false, reason:"Cannot stack into other player's hand" };

          dropStackId = s2.id;
        }

        if (!dropStackId) return { ok:false, reason:"No drop stack" };
        if (srcStackId && srcStackId === dropStackId) return { ok:true };

        const dropStack = this._ensureStack(st, dropStackId);
        if (!dropStack) return { ok:false, reason:"Drop stack missing" };
        if (!canInteractStack(dropStack, fromId)) return { ok:false, reason:"No access" };

        const oldDrop = [...(dropStack.cardIds || [])];

        // remove moving from old places
        if (dragTargetType === "stack"){
          const src = this._ensureStack(st, dragId);
          if (src && src.id !== "stack_deck") delete st.stacks[src.id];
        } else {
          this._detachFromStack(st, dragId);
        }

        const movingSet = new Set(moving);
        const rest = oldDrop.filter(cid => !movingSet.has(cid));

        // newest on top
        dropStack.cardIds = [...moving, ...rest];

        // sync cards to stack (NO flip)
        for (const cid of dropStack.cardIds){
          const c = this._ensureCard(st, cid);
          if (!c) continue;

          c.stackId = dropStackId;
          c.x = dropStack.x;
          c.y = dropStack.y;
          c.zone = dropStack.zone;

          c.owner = (dropStack.zone === ZONES.hand) ? (dropStack.owner ?? null) : null;
          if (dropStack.zone === ZONES.hand && dropStack.owner) c.ownerId = dropStack.owner;
          //else c.ownerId = null;
        }

        this.bumpVersion();
        return { ok:true };
      }

      case "unstack": {
        const { stackId } = action;
        const ss = this._ensureStack(st, stackId);
        if (!ss || !canInteractStack(ss, fromId)) return { ok:false, reason:"No access" };
        if ((ss.cardIds?.length || 0) <= 1) return { ok:true };

        const topId = ss.cardIds.shift(); // top l√† [0]
        const c = this._ensureCard(st, topId);
        if (!c) return { ok:false, reason:"Missing card" };

        c.stackId = null;
        c.x = ss.x + randInt(-90, 90);
        c.y = ss.y + randInt(-60, 60);
        c.zone = ss.zone;

        c.owner = (ss.zone === ZONES.hand) ? (ss.owner ?? ss.ownerId ?? null) : null;
        st._z = (st._z || 0) + 1;
        c.z = st._z;
        
        // ‚úÖ ownerId: ch·ªâ ƒë·ªïi n·∫øu n√≥ ƒëang ·ªü hand (ƒë·ªïi theo ch·ªß hand)
        // c√≤n n·∫øu unstack t·ª´ table/discard th√¨ gi·ªØ nguy√™n ownerId ƒë·ªÉ gi·ªØ vi·ªÅn
        if (ss.zone === ZONES.hand){
          const handOwner = ss.owner ?? ss.ownerId ?? null;
          c.ownerId = handOwner;
        }else if (ss.zone === ZONES.deck){
          c.owner=null; 
          c.ownerId=null;
        }

        this.bumpVersion();
        return { ok:true };
      }

      case "chat": {
        const text = (action.text || "").toString().slice(0, 300);
        if (!text.trim()) return { ok:true };

        st.chat = st.chat || [];
        st.chat.push({ id: uid(), at: now(), fromId, text });
        if (st.chat.length > 120) st.chat.splice(0, st.chat.length - 120);

        this.bumpVersion();
        return { ok:true };
      }

      case "reset": {
        if (fromId !== st.hostId) return { ok:false, reason:"Host only" };

        const keepPlayers = deepClone(st.players);
        this.state = makeFreshTableState(st.roomCode, st.hostId);
        this.state.players = keepPlayers;
        ensureUIState(this.state);

        this.bumpVersion();
        return { ok:true };
      }

      case "setAssets": {
        if (fromId !== st.hostId) return { ok:false, reason:"Host only" };

        st.assets = st.assets || {};
        st.assets.frontBase = (action.frontBase || "").trim();
        st.assets.backUrl = (action.backUrl || "").trim();

        this.bumpVersion();
        return { ok:true };
      }

      case "join": {
        this.bumpVersion();
        return { ok:true };
      }

      case "startGame": {
        if (fromId !== st.hostId) return { ok:false, reason:"Host only" };

        st.game = st.game || {};
        st.game.phase = "playing";
        st.game.startedAt = now();

        this.bumpVersion();
        return { ok:true };
      }

      case "set_stat_header": {
        if (st.hostId && fromId !== st.hostId) return { ok:false, reason:"Host only" };
        ensureUIState(st);

        const idx = (action.idx | 0);
        const value = (action.value ?? "").toString().slice(0, 12);
        if (idx < 0 || idx > 3) return { ok:false, reason:"Bad index" };

        while (st.ui.statHeaders.length < 4) st.ui.statHeaders.push("");
        st.ui.statHeaders[idx] = value;

        this.bumpVersion();
        return { ok:true };
      }

      case "set_stat": {
        ensureUIState(st);

        const playerId = action.playerId;
        const idx = (action.idx | 0);
        const value = (action.value ?? "").toString().slice(0, 12);
        if (idx < 0 || idx > 3) return { ok:false, reason:"Bad index" };

        const p2 = (st.players || []).find(pp => pp && pp.id === playerId);
        if (!p2) return { ok:false, reason:"Player not found" };

        if (!st.ui.statsByPlayer[playerId]) st.ui.statsByPlayer[playerId] = ["", "", "", ""];
        while (st.ui.statsByPlayer[playerId].length < 4) st.ui.statsByPlayer[playerId].push("");

        st.ui.statsByPlayer[playerId][idx] = value;

        this.bumpVersion();
        return { ok:true };
      }

      default:
        return { ok:false, reason:"Unknown action" };
    }
  }
}

/* =========================================================
   9) Firebase (Auth + RTDB) - Firebase-only
========================================================= */
const firebaseConfig = {
  apiKey: "AIzaSyBze3rgBuJ8Ex7c_yWnEVu76huNAuSFll8",
  authDomain: "tablegame-dc4a8.firebaseapp.com",
  databaseURL: "https://tablegame-dc4a8-default-rtdb.firebaseio.com",
  projectId: "tablegame-dc4a8",
  storageBucket: "tablegame-dc4a8.firebasestorage.app",
  messagingSenderId: "715606656270",
  appId: "1:715606656270:web:a1c4055c2d307201f1035f",
  measurementId: "G-KHWGKGT3GE"
};

window.FB = window.FB || { app:null, auth:null, db:null, user:null, uid:null, username:null };
const FB = window.FB;

function fbInitOnce(){
  if (FB.app && FB.auth && FB.db) return;

  FB.app  = firebase.apps?.length ? firebase.app() : firebase.initializeApp(firebaseConfig);
  FB.auth = firebase.auth();
  FB.db   = firebase.database();
}

// ƒë·∫£m b·∫£o ƒë√£ login (anon/email) + c√≥ profile AllUser
async function fbEnsureAuth(){
  fbInitOnce();

  // n·∫øu ch∆∞a login g√¨ c·∫£ -> signInAnonymously (ch·ªâ ƒë·ªÉ c√≥ uid/db)
  if (!FB.auth.currentUser){
    await FB.auth.signInAnonymously();
  }

  FB.user = FB.auth.currentUser;
  FB.uid  = FB.user.uid;

  // ∆∞u ti√™n UI.nameInput n·∫øu c√≥
  FB.username = ((UI.nameInput?.value || FB.username || "").trim().slice(0,18)) || "Player";

  const uref = FB.db.ref(`AllUser/${FB.uid}`);
  const snap = await uref.get();
  if (!snap.exists()){
    await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
  }else{
    const cur = snap.val() || {};
    const upd = {};
    if ((cur.username||"") !== FB.username) upd.username = FB.username;
    if (!cur.setCard) upd.setCard = {};
    if (Object.keys(upd).length) await uref.update(upd);
  }

  // ‚úÖ ƒë·∫£m b·∫£o lu√¥n c√≥ db
  if (!FB.db) throw new Error("FB.db still missing after fbInitOnce()");
}

async function fbAllocateRoomNo(){
  const db = FB.db;

  const freeRef = db.ref("RoomIndex/freeNos");
  const freeSnap = await freeRef.get();
  if (freeSnap.exists()){
    const obj = freeSnap.val() || {};
    const nums = Object.keys(obj).map(x=>parseInt(x,10)).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
    for (const n of nums){
      const oneRef = db.ref(`RoomIndex/freeNos/${n}`);
      const r = await oneRef.transaction((cur)=>{ if (cur === true) return null; return; });
      if (r.committed) return n;
    }
  }

  const nextRef = db.ref("RoomIndex/nextNo");
  const res = await nextRef.transaction((cur)=> (typeof cur !== "number" ? 1 : cur + 1));
  const newVal = res.snapshot.val();
  const roomNo = Math.max(1, newVal - 1);
  return roomNo;
}

async function fbReleaseRoomNo(roomNo){
  if (!roomNo) return;
  await FB.db.ref(`RoomIndex/freeNos/${roomNo}`).set(true);
}

/* =========================================================
   10) Client State + Transport wiring (Firebase-only)
========================================================= */
const client = {
  selfId: "",
  selfName: "",
  roomCode: "",
  roomId: "",
  roomMeta: { roomNo:null, roomId:null, roomName:null,},

  isHost: false,
  transport: null,
  host: null,
  authoritative: null,   // ‚úÖ gi·ªØ nguy√™n (state redact)
  lastVersion: 0,

  lobby: { meta:{}, users:{}, seatClaimsPlay:{} },

  selected: null,
  dragging: null,
};
  
window.client = client;

let _presenceCb = null;
let _hostIdCb = null;

// lobby listeners
let _metaCb = null;
let _seatClaimsCb = null;
let _lobbyUsersCb = null;

function setNetBadge(text, color=null){
  if (!UI.netBadge) return;
  UI.netBadge.textContent = text;
  UI.netBadge.style.borderColor = color ? color : "rgba(255,255,255,.12)";
}

function getState(){
  if (client.isHost && client.host){
    return client.authoritative || redactStateForViewer(client.host.state, client.selfId);
  }
  return client.authoritative;
}
function seatColorKey(seat){
  seat = seat|0;
  // ∆∞u ti√™n COLOR_ORDER n·∫øu b·∫°n c√≥
  if (typeof COLOR_ORDER !== "undefined" && Array.isArray(COLOR_ORDER) && COLOR_ORDER.length){
    return COLOR_ORDER[seat % COLOR_ORDER.length] || "gray";
  }
  // fallback c·ª©ng 4 m√†u
  return ["red","blue","green","purple"][seat] || "gray";
}
function seatColor(seat){
  return COLORS?.[seatColorKey(seat)] || "rgba(255,255,255,.25)";
}
function rgbaWithAlpha(color, a){
  const m = /^rgba?\((\s*\d+\s*),(\s*\d+\s*),(\s*\d+\s*)(?:,(\s*[\d.]+\s*))?\)$/.exec(String(color).trim());
  if (m) return `rgba(${m[1]},${m[2]},${m[3]},${a})`;
  const h = String(color).trim();
  if (/^#([0-9a-fA-F]{6})$/.test(h)){
    const rr = parseInt(h.slice(1,3),16), gg = parseInt(h.slice(3,5),16), bb = parseInt(h.slice(5,7),16);
    return `rgba(${rr},${gg},${bb},${a})`;
  }
  return color;
}

function setStatusUI(){
  const s = client.authoritative;
  if (!s){
    UI.roomBadge && (UI.roomBadge.textContent = "‚Äî");
    UI.meLine && (UI.meLine.textContent = "‚Äî");
    UI.hostLine && (UI.hostLine.textContent = "‚Äî");
    UI.playersLine && (UI.playersLine.textContent = "‚Äî");
    UI.chatBadge && (UI.chatBadge.textContent = "‚Äî");
    updateInspector?.();
    return;
  }

  // ===== ROOM BADGE =====
  const roomName =
    client.lobby.meta?.roomName ||
    client.roomMeta?.roomName ||
    client.roomCode || "‚Äî";
  
  UI.roomBadge.textContent = `PH√íNG: ${roomName}`;

  UI.chatBadge && (UI.chatBadge.textContent = "v" + (s.version || 0));

  // ===== ME =====
  const uid = client.selfId || FB?.uid || "";
  const myName = client.selfName || FB?.username || "B·∫°n";
  const uMe = client.lobby?.users?.[uid] || null;
  const mySeat = Number.isInteger(uMe?.playSeat) ? (uMe.playSeat|0) : null;

  // t√¨m trong state.players (n·∫øu m√¨nh ƒë√£ ƒë∆∞·ª£c add v√†o players)
  const me = (s.players || []).find(p => p && p.id === uid) || null;

  if (UI.meLine){
    if (!uid){
      UI.meLine.textContent = "(ch∆∞a ƒëƒÉng nh·∫≠p)";
    } else {
      // role theo lobby tr∆∞·ªõc (ƒë·ªïi gh·∫ø l√† ƒë·ªïi ngay)
      const isHost = (mySeat === 0); // gh·∫ø 0 l√† host
      const role = (mySeat === null) ? "Xem" : (isHost ? "HOST" : `Gh·∫ø ${mySeat+1}`);
  
      // m√†u theo gh·∫ø (gi·ªëng canvas)
      const c = (mySeat === null) ? "rgba(255,255,255,.25)" : seatColor(mySeat);
  
      UI.meLine.innerHTML = `<span style="display:inline-flex;align-items:center;gap:8px">
        <span style="width:10px;height:10px;border-radius:999px;background:${c};
          box-shadow:0 0 0 3px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.18)"></span>
        <span>${escapeHtml(myName)} ‚Ä¢ ${role}</span>
      </span>`;
    }
  }


  // ===== HOST LINE =====
  const hostId = s.hostId || "";
  const hostP = (s.players || []).find(p=>p && p.id === hostId) || null;

  if (UI.hostLine){
    if (hostP){
      const dot = COLORS?.[hostP.color] || "rgba(255,255,255,.35)";
      UI.hostLine.innerHTML =
        `<span style="display:inline-flex;align-items:center;gap:8px">
          <span style="width:10px;height:10px;border-radius:999px;background:${dot};
            border:1px solid rgba(255,255,255,.18)"></span>
          <span>${escapeHtml(hostP.name || "Host")}</span>
        </span>`;
    } else {
      // host c√≥ th·ªÉ l√† spectator (ch∆∞a c√≥ trong state.players) ho·∫∑c state ch∆∞a k·ªãp sync
      UI.hostLine.textContent = hostId ? "(ƒëang ƒë·ªìng b·ªô...)" : "‚Äî";
    }
  }

  // ===== PLAYERS LIST =====
  if (UI.playersLine){
    UI.playersLine.innerHTML = (s.players || []).map(p=>{
      if (!p) return "";
      const dot = COLORS?.[p.color] || "rgba(255,255,255,.35)";
      const isHost = (p.id === hostId);
      return `<div style="display:flex;align-items:center;gap:8px;margin:2px 0">
        <span style="width:10px;height:10px;border-radius:999px;background:${dot};
          border:1px solid rgba(255,255,255,.18)"></span>
        <span style="color:rgba(233,236,255,.92)">${escapeHtml(p.name || "Player")}</span>
        ${p.color ? `<span style="color:rgba(233,236,255,.55);font-size:12px">(${escapeHtml(p.color)})</span>` : ""}
        ${isHost ? `<span style="margin-left:auto;color:var(--muted);font-size:11px;border:1px solid rgba(255,255,255,.12);
          padding:2px 6px;border-radius:999px">HOST</span>` : ""}
      </div>`;
    }).join("");
  }

  updateInspector?.();

  // n·∫øu inspector ƒëang m·ªü m√† target m·∫•t -> hide, c√≤n th√¨ reposition
  const ins = document.getElementById("inspector");
  if (ins && ins.style.display === "block"){
    const sel = client.selected;
    if (!sel) hideInspectorPopup?.();
    else {
      const wp = getWorldPosOfTarget?.(s, sel);
      if (!wp) hideInspectorPopup?.();
      else positionInspectorNearTarget?.();
    }
  }

  // ===== Setup box UI =====
  const phase = s.game?.phase || "waiting";
  if (UI.setupPhaseLine){
    UI.setupPhaseLine.textContent = (phase === "waiting")
      ? "ƒêang ·ªü ph√≤ng ch·ªù. Host ch·ªçn deck v√† b·∫•m B·∫Øt ƒë·∫ßu."
      : "ƒêang ch∆°i...";
  }

  const hostCanSetup = !!client.isHost;
  if (UI.hostToolBar){
    UI.hostToolBar.style.display = (hostCanSetup && phase === "waiting") ? "flex" : "none";
  }
  if (UI.blockStartGame){
    UI.blockStartGame.style.display = (hostCanSetup && phase === "waiting") ? "flex" : "none";
  }
  
  renderChat?.();
}


async function sendIntent(action){
  if (!client.transport) return;
  // Firebase-only
  await client.transport.sendIntent(action);
}

function installTransport(t){
  if (client.transport) client.transport.close();
  client.transport = t;

  t.onStatus = (st) => {
    if (st?.connected){
      setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
    }else{
      setNetBadge("OFFLINE", "rgba(255,255,255,.12)");
    }
  };
}

/* =========================================================
   11) Room code helpers (Firebase-only)
========================================================= */
function genRoomCode(){
  // ph√≤ng Firebase d√πng ROOM{N} -> h√†m n√†y gi·ªØ l·∫°i ƒë·ªÉ fallback UI
  const a = Math.random().toString(36).slice(2, 6).toUpperCase();
  const b = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `${a}-${b}`;
}

function readInputs(){
  // name l·∫•y t·ª´ fbEnsureAuth (FB.username) l√† chu·∫©n nh·∫•t, nh∆∞ng v·∫´n gi·ªØ UI ƒë·ªÉ hi·ªÉn th·ªã
  client.selfName = (UI.nameInput?.value || "").trim().slice(0,18) || (FB?.username || "Player");
  client.roomCode = (UI.roomInput?.value || "").trim().toUpperCase();
  if (!client.roomCode) client.roomCode = genRoomCode();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;
}

function resetClientSession(){
  if (client.transport) client.transport.close();
  client.transport = null;
  client.isHost = false;
  client.host = null;
  client.authoritative = null;
  client.lastVersion = 0;
  client.selected = null;
  client.dragging = null;
  setStatusUI();
  setNetBadge("OFFLINE");
}

/* =========================================================
   12) Room: Firebase create/join/leave
========================================================= */
//M·ªü popup t·∫°o ph√≤ng
function toggleCreateRoomPopup(force){
  const popup = document.getElementById("popupCreateRoom");
  if (!popup) return;

  // n·∫øu truy·ªÅn true / false th√¨ set c·ª©ng
  if (typeof force === "boolean"){
    popup.style.display = force ? "flex" : "none";
    return;
  }

  // toggle
  const isOpen = popup.style.display === "flex";
  popup.style.display = isOpen ? "none" : "flex";
}

const openCreateRoomBtn = document.getElementById("openCreateRoomBtn");
if (openCreateRoomBtn){
  openCreateRoomBtn.addEventListener("click", ()=>{
    toggleCreateRoomPopup(true); // m·ªü
  });
}

function closePopUpCreateRoom(){ document.getElementById("popupCreateRoom").style.display = "none"; }
closeCreateRoomBtn.addEventListener("click", ()=>{
    closePopUpCreateRoom();
});

// ===============================
//  HASH
// ===============================
async function sha256Hex(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest("SHA-256", enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}

// ===============================
//  CREATE ROOM (HOST) - FULL
//  - write AllRoom (full)
//  - write AllRoomMeta (light)
// ===============================
function isMeHost(meta){
  const hid = meta?.hostId || meta?.hostUid || "";
  return hid && hid === (FB.uid || "");
}

// gh·∫ø click: t·∫°m th·ªùi cho ng∆∞·ªùi d√πng t·ª± xin ng·ªìi
async function requestSit(roomId, seat){
  const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);
  const uid = FB.uid;

  // ‚úÖ ƒëang ch∆°i => c·∫•m ƒë·ªïi gh·∫ø
  const gs = (client.lobby?.meta?.gameStatus || "waiting");
  if (gs === "playing"){
    toast("ƒêang ch∆°i r·ªìi ‚Äî kh√¥ng th·ªÉ ƒë·ªïi gh·∫ø.");
    return;
  }

  const uSnap = await roomRef.child(`users/${uid}`).get();
  const u = uSnap.val() || {};

  // n·∫øu ƒëang ng·ªìi gh·∫ø ƒë√≥ -> click l·∫°i ƒë·ªÉ xu·ªëng
  if (Number.isInteger(u.playSeat)){
    if ((u.playSeat|0) === (seat|0)) return requestUnseat(roomId);
    toast("B·∫°n ƒëang ng·ªìi gh·∫ø kh√°c. H√£y xu·ªëng gh·∫ø ch·ªù tr∆∞·ªõc.");
    return;
  }

  const claimRef = roomRef.child(`seatClaims/play/${seat}`);
  const tx = await claimRef.transaction(cur => (cur === null ? uid : undefined));
  if (!tx.committed || tx.snapshot.val() !== uid){
    toast("Gh·∫ø ƒë√£ c√≥ ng∆∞·ªùi ng·ªìi.");
    return;
  }

  await roomRef.child(`users/${uid}`).update({
    role: "player",
    playSeat: seat|0,
  });

  try{
    await client.transport?.sendIntent?.({ type:"sit", seat: seat|0 });
  }catch(e){}

  // host seat
  if ((seat|0) === 0){
    await roomRef.child(`meta/hostId`).set(uid).catch(()=>{});
    await roomRef.child(`meta/hostUid`).set(uid).catch(()=>{});
  }

  toast((seat|0) === 0 ? "B·∫°n ƒë√£ ng·ªìi gh·∫ø HOST" : `ƒê√£ ng·ªìi gh·∫ø ${seat+1}`);
}

async function requestUnseat(roomId){
  const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);
  const uid = FB.uid;

  // ‚úÖ ƒëang ch∆°i => c·∫•m xu·ªëng gh·∫ø / ƒë·ªïi gh·∫ø
  const gs = (client.lobby?.meta?.gameStatus || "waiting");
  if (gs === "playing"){
    toast("ƒêang ch∆°i r·ªìi ‚Äî kh√¥ng th·ªÉ xu·ªëng gh·∫ø.");
    return;
  }

  const uSnap = await roomRef.child(`users/${uid}`).get();
  const u = uSnap.val() || {};
  const mySeat = Number.isInteger(u.playSeat) ? (u.playSeat|0) : null;

  if (mySeat === null){
    toast("B·∫°n ƒëang ·ªü gh·∫ø ch·ªù r·ªìi.");
    return;
  }

  await roomRef.child(`seatClaims/play/${mySeat}`).transaction(cur=>{
    if (cur === uid) return null;
    return; // abort
  }).catch(()=>{});

  await roomRef.child(`users/${uid}`).update({
    role: "spectator",
    playSeat: null,
  });

  try{
    await client.transport?.sendIntent?.({ type:"unsit" });
  }catch(e){}

  if (mySeat === 0){
    await roomRef.child(`meta/hostId`).transaction(cur => (cur === uid ? "" : undefined)).catch(()=>{});
    await roomRef.child(`meta/hostUid`).transaction(cur => (cur === uid ? "" : undefined)).catch(()=>{});
  }

  toast("ƒê√£ xu·ªëng gh·∫ø ch·ªù");
}
  
function seatColorByUid(uid){
  if (!uid) return null;

  // ∆∞u ti√™n lobby users
  const u = client.lobby?.users?.[uid];
  if (u?.color && COLORS?.[u.color]) return COLORS[u.color];

  // fallback state.players (khi ƒë√£ sync v√†o b√†n)
  const s = client.authoritative;
  const p = (s?.players || []).find(x => x && x.id === uid);
  if (p?.color && COLORS?.[p.color]) return COLORS[p.color];

  return null;
}
function withAlpha(color, a){
  // n·∫øu ƒë√£ l√† rgba(...) th√¨ thay alpha
  const m = /^rgba?\((\s*\d+\s*),(\s*\d+\s*),(\s*\d+\s*)(?:,(\s*[\d.]+\s*))?\)$/.exec(String(color).trim());
  if (m){
    const r = m[1], g = m[2], b = m[3];
    return `rgba(${r},${g},${b},${a})`;
  }
  // n·∫øu l√† hex #rrggbb
  const h = String(color).trim();
  if (/^#([0-9a-fA-F]{6})$/.test(h)){
    const rr = parseInt(h.slice(1,3),16);
    const gg = parseInt(h.slice(3,5),16);
    const bb = parseInt(h.slice(5,7),16);
    return `rgba(${rr},${gg},${bb},${a})`;
  }
  // fallback: kh√¥ng convert ƒë∆∞·ª£c th√¨ d√πng nguy√™n b·∫£n
  return color;
}

async function fetchSeatClaims(roomId){
  const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);
  const snap = await roomRef.child("seatClaims/play").get();
  return snap.val() || {};
}

function renderLobby(roomId, meta, users, seatClaimsPlay){
  users = users || {};
  seatClaimsPlay = seatClaimsPlay || {};

  // host controls show/hide
  const hostBox = document.getElementById("hostSetupControls");
  if (hostBox) hostBox.style.display = isMeHost(meta) ? "" : "none";

  const wr = document.getElementById("waitingRoom");
  if (!wr) return;

  const playBtns  = [...wr.querySelectorAll(`.slot[data-slot="play"]`)];
  const specList  = document.getElementById("specList");
  const specCount = document.getElementById("specCount");

  // PLAY seats: d·ª±a tr√™n seatClaimsPlay
  for (const btn of playBtns){
    const seat = Number(btn.dataset.seat)|0;

    const occUid  = seatClaimsPlay?.[seat] || null;
    const occUser = occUid ? (users?.[occUid] || null) : null;
    const isHostSeat = (seat === 0);

    btn.onclick = null;
    btn.style.border = "";
    btn.style.background = "";
    btn.style.boxShadow = "";
    const base = seatColor(seat);
    btn.style.border = `1px solid ${rgbaWithAlpha(base, 0.22)}`;
    btn.style.background = rgbaWithAlpha(base, 0.06);
    btn.style.boxShadow = `0 0 0 1px rgba(0,0,0,.25) inset`;


    if (occUid){
      btn.classList.remove("empty");

      const isMe = (occUid === (FB.uid||""));

      // n·∫øu claim c√≥ nh∆∞ng user ch∆∞a sync th√¨ v·∫´n hi·ªán ‚Äúƒëang ƒë·ªìng b·ªô‚Äù
      const name = occUser?.username || "ƒêang ƒë·ªìng b·ªô...";
      const label = isHostSeat ? "HOST" : `Gh·∫ø ${seat+1}`;

      const base = seatColor(seat);
      // occupied: ƒë·∫≠m h∆°n
      btn.style.border = `2px solid ${rgbaWithAlpha(base, 0.95)}`;
      btn.style.background = rgbaWithAlpha(base, 0.14);
      btn.style.boxShadow = `0 0 0 2px ${rgbaWithAlpha(base, 0.25)}, 0 0 0 1px rgba(0,0,0,.25) inset`;
      
      // n·∫øu l√† m√¨nh ng·ªìi -> highlight th√™m
      if (isMe){
        btn.style.background = rgbaWithAlpha(base, 0.22);
        btn.style.boxShadow = `0 0 0 2px ${rgbaWithAlpha(base, 0.45)}, 0 10px 22px rgba(0,0,0,.35)`;
      }
      
      // seat 0 host: vi·ªÅn double
      if (seat === 0){
        btn.style.borderStyle = "double";
        btn.style.borderWidth = "3px";
      }

      if (isMe){
        btn.innerHTML = `
          <div class="name">${escapeHtml(name)}</div>
          <div class="meta">Click ƒë·ªÉ xu·ªëng ch·ªù</div>
        `;
        btn.disabled = false;
        btn.onclick = ()=> requestUnseat(roomId);
      } else {
        btn.innerHTML = `
          <div class="name">${escapeHtml(name)}</div>
          <div class="meta">${label}</div>
        `;
        btn.disabled = true;
      }
    } else {
      btn.classList.add("empty");
      const label = isHostSeat ? "Gh·∫ø ch·ªß ph√≤ng" : `Gh·∫ø ${seat+1}`;
      btn.innerHTML = `
        <div class="name">${label}</div>
        <div class="meta">Click ƒë·ªÉ ng·ªìi</div>
      `;
      btn.disabled = false;
      btn.onclick = ()=> requestSit(roomId, seat);
    }
  }

  // SPECTATORS list (nh·ªØng ai playSeat null)
  const entries = Object.entries(users || {});
  const spectators = entries
    .filter(([uid,u])=> !Number.isInteger(u?.playSeat))
    .sort((a,b)=> (a[1]?.joinedAt||0) - (b[1]?.joinedAt||0));

  if (specCount) specCount.textContent = String(spectators.length);

  if (specList){
    specList.innerHTML = "";
    if (!spectators.length){
      specList.innerHTML = `<div style="opacity:.55; font-size:12px;">Kh√¥ng c√≥</div>`;
      return;
    }
    for (const [uid,u] of spectators){
      const chip = document.createElement("div");
      chip.className = "spec-chip";
      chip.innerHTML = `<div class="n">${escapeHtml(u?.username||"‚Äî")}</div>`;
      specList.appendChild(chip);
    }
  }
}
  
function installLobbyRealtimeListeners(roomRef){
  // ===== META =====
  try{ if (_metaCb) roomRef.child("meta").off("value", _metaCb); }catch(e){}
  _metaCb = (snap)=>{
    client.lobby.meta = snap.val() || {};

    // sync roomMeta cho status UI
    if (client.lobby.meta?.roomName){
      client.roomMeta.roomName = client.lobby.meta.roomName;
    }

    setStatusUI?.();
    renderLobby?.(
      client.roomId,
      client.lobby.meta,
      client.lobby.users,
      client.lobby.seatClaimsPlay
    );
  };
  roomRef.child("meta").on("value", _metaCb);

  // ===== SEAT CLAIMS =====
  try{ if (_seatClaimsCb) roomRef.child("seatClaims/play").off("value", _seatClaimsCb); }catch(e){}
  _seatClaimsCb = async (snap)=>{
    client.lobby.seatClaimsPlay = snap.val() || {};
    setStatusUI?.();
    renderLobby?.(
      client.roomId,
      client.lobby.meta,
      client.lobby.users,
      client.lobby.seatClaimsPlay
    );
  
    // üî• QUAN TR·ªåNG: n·∫øu l√† host th√¨ rebuild state.players
    if (client.isHost && client.host){
    await hostRebuildPlayersFromLobby(roomRef);
    await client.transport.writeState(client.host.state);
    client.authoritative = redactStateForViewer(
      client.host.state,
      FB.uid
    );
    client.lastVersion = client.host.state.version;

    }
  };

  roomRef.child("seatClaims/play").on("value", _seatClaimsCb);
}

async function createRoomAsHost_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  const roomNo = await fbAllocateRoomNo();
  const roomId = `room${roomNo}`;

  client.roomId = roomId.toLowerCase();
  client.roomCode = roomId.toUpperCase();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;

  const roomName = (UI.createRoomNameInput?.value || "").trim().slice(0,38) || `Room ${roomNo}`;
  const passRaw  = (UI.createRoomPassInput?.value || "").trim().slice(0,32);

  const passSalt = uid().slice(0,8);
  const passHash = passRaw ? await sha256Hex(`${passSalt}:${passRaw}`) : "";

  const meta = {
    roomNo,
    roomId: client.roomId,
    roomName,
    hasPassword: !!passRaw,
    passSalt: passRaw ? passSalt : "",
    passHash: passRaw ? passHash : "",
    hostId: FB.uid,          // host = gh·∫ø 0
    hostUid: FB.uid,
    status: "active",
    createdAt: Date.now(),
    maxPlayers: 4,
    mode: "Truy·ªÅn th·ªëng",

    // ‚úÖ NEW
    gameStatus: "waiting",   // waiting | playing
    startedAt: 0,
  };

  client.isHost = true;
  client.host = new HostController(client.roomCode, FB.uid);
  client.host.addOrUpdatePlayerAtSeat(FB.uid, FB.username, 0);

  // ‚úÖ ƒë·∫£m b·∫£o state c√≥ phase waiting ngay t·ª´ ƒë·∫ßu
  client.host.state.game = client.host.state.game || {};
  client.host.state.game.phase = "waiting";
  client.host.bumpVersion?.();

  const roomRef = FB.db.ref(`AllRoom/${String(client.roomId).toLowerCase()}`);

  // ‚úÖ ghi room tr∆∞·ªõc
  await roomRef.set({
    meta,
    presence: {},
    intents: {},
    state: client.host.state,
    users: {
      [FB.uid]: {
        username: FB.username,
        joinedAt: Date.now(),
        role: "player",
        playSeat: 0,
        atk: 0, def: 0, hp: 0, coin: 0,
      }
    },
    seatClaims: { play: { 0: FB.uid } },
  });

  // ‚úÖ mirror meta ƒë·ªÉ list ph√≤ng
  await FB.db.ref(`AllRoomMeta/${client.roomId}`).set(meta);

  // ‚úÖ t·∫°o transport TR∆Ø·ªöC khi d√πng t.*
  const t = new FirebaseTransport(client.roomId);
  installTransport(t);

  // ‚úÖ ƒë·∫£m b·∫£o state ƒë∆∞·ª£c write ra DB ngay
  await t.writeState(client.host.state);

  client.authoritative = redactStateForViewer(client.host.state, FB.uid);
  client.lastVersion = client.authoritative.version;
  setStatusUI();

  // listen lobby meta + seatClaims
  installLobbyRealtimeListeners(roomRef);

  // users listener (qua transport)
  t.listenUsers((users)=>{
    client.lobby.users = users || {};
    setStatusUI?.();
    renderLobby?.(
      client.roomId,
      client.lobby.meta,
      client.lobby.users,
      client.lobby.seatClaimsPlay
    );
  });

  await t.attachPresence();
  installHostPresenceReconcile(client.roomId);

  // =========================
  // HOST AUTHORITY (INTENTS)
  // =========================
  t.listenIntentsAsHost(async (msg, intentKey, intentRef)=>{
    const action = msg.action;
    const fromId = msg.fromId;

    // ‚úÖ l·∫•y meta realtime (ƒë·ª° .get() m·ªói intent)
    const gs = client.lobby?.meta?.gameStatus || "waiting";
    const hostIdNow = client.lobby?.meta?.hostId || client.lobby?.meta?.hostUid || "";

    // ‚úÖ ƒëang ch∆°i => c·∫•m sit/unsit
    if (gs === "playing" && (action?.type === "sit" || action?.type === "unsit")){
      await t.ackIntent(intentRef);
      return;
    }

    const isSeatAction =
      action?.type === "join" ||
      action?.type === "leave" ||
      action?.type === "sit"  ||
      action?.type === "unsit";

    // ‚úÖ waiting => ch·ªâ host ƒë∆∞·ª£c gameplay intents
    if (gs === "waiting" && !isSeatAction){
      if (fromId !== hostIdNow){
        await t.ackIntent(intentRef);
        return;
      }
    }

    // ‚úÖ start game (host only)
    if (action?.type === "startGame"){
      if (fromId !== hostIdNow){
        await t.ackIntent(intentRef);
        return;
      }

      // c·∫≠p nh·∫≠t meta (lock gh·∫ø)
      await roomRef.child("meta").update({
        gameStatus: "playing",
        startedAt: now(),
      }).catch(()=>{});

      // c·∫≠p nh·∫≠t state (ƒë·ªÉ client UI/draw ƒë·ªçc)
      client.host.state.game = client.host.state.game || {};
      client.host.state.game.phase = "playing";
      client.host.bumpVersion?.();

      await t.writeState(client.host.state);
      await t.ackIntent(intentRef);
      return;
    }

    // --- JOIN/LEAVE/SIT/UNSIT: rebuild t·ª´ lobby ---
    if (isSeatAction){
      if (action?.type === "leave"){
        try{ await roomRef.child(`users/${fromId}`).remove(); }catch(e){}
      }

      await hostRebuildPlayersFromLobby(roomRef);

      // ‚úÖ gi·ªØ phase theo meta
      client.host.state.game = client.host.state.game || {};
      client.host.state.game.phase = (client.lobby?.meta?.gameStatus || gs);

      await t.writeState(client.host.state);
      await t.ackIntent(intentRef);
      return;
    }

    // ‚úÖ playing => ch·ªâ ng∆∞·ªùi ƒë√£ ng·ªìi gh·∫ø (playSeat) m·ªõi ƒë∆∞·ª£c thao t√°c
    if (gs === "playing"){
      const u = client.lobby?.users?.[fromId] || null;
      if (!u || !Number.isInteger(u.playSeat)){
        await t.ackIntent(intentRef);
        return;
      }
    }

    // --- gameplay intents (move/flip/draw...) ---
    const r = client.host.applyIntent(fromId, action);
    if (!r.ok && fromId === FB.uid) toast("Action fail: " + r.reason);

    if (r.ok){
      await t.writeState(client.host.state);
    }
    await t.ackIntent(intentRef);
  });

  // state stream
  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;

    if (client.isHost && client.host){
      client.host.state = st;
      client.authoritative = redactStateForViewer(st, FB.uid);
    } else {
      client.authoritative = redactStateForViewer(st, FB.uid);
    }

    client.lastVersion = st.version || client.lastVersion;
    setStatusUI();
  });

  toast(`ƒê√£ t·∫°o room: ${roomId}`);
  client.roomMeta = { roomNo, roomId, roomName };

  installFirebaseRoomCleanup(client.roomId, roomNo);

  toggleCreateRoomPopup(false);
  goMatch();
}

async function hostRebuildPlayersFromLobby(roomRef){
  const [usersSnap, seatSnap, metaSnap] = await Promise.all([
    roomRef.child("users").get(),
    roomRef.child("seatClaims/play").get(),
    roomRef.child("meta").get(),
  ]);

  const users = usersSnap.val() || {};
  const seatClaims = seatSnap.val() || {};
  const meta = metaSnap.val() || {};

  const st = client.host._ensureState ? client.host._ensureState() : client.host.state;
  st.players = Array.isArray(st.players) ? st.players : [];

  // clear ƒë·ªß 4 slot
  for (let i=0;i<4;i++) st.players[i] = null;

  // rebuild theo seatClaims (key c√≥ th·ªÉ l√† "0","1","2","3")
  for (let seat=0; seat<4; seat++){
    const uid = seatClaims?.[seat] || seatClaims?.[String(seat)] || null;
    if (!uid) continue;

    const u = users?.[uid] || {};
    const name = u.username || "Player";

    // ‚úÖ color ƒë·ªìng b·ªô theo seat
    const color = (Array.isArray(COLOR_ORDER) && COLOR_ORDER.length)
      ? (COLOR_ORDER[seat % COLOR_ORDER.length] || "gray")
      : (["red","blue","green","purple"][seat] || "gray");

    st.players[seat] = {
      id: uid,
      name,
      color,
      seat,
      connectedAt: st.players[seat]?.connectedAt || now(),
    };

    ensureUIState(st);
    if (!st.ui.statsByPlayer[uid]) st.ui.statsByPlayer[uid] = ["","","",""];
  }

  // hostId trong state = meta.hostId (ƒë·ªÉ host-only ok)
  st.hostId = meta.hostId || meta.hostUid || st.hostId || "";

  client.host.bumpVersion?.();
  return st;
}

  
// ===============================
//  ROOM LIST UI + JOIN WITH PASS POPUP (FULL)
//  - listen AllRoomMeta (light)
// ===============================
const ROOMUI = {
  listEl: document.getElementById("listRoom"),
  searchEl: document.getElementById("roomSearchInput"),

  passPopup: document.getElementById("popupJoinPass"),
  passInput: document.getElementById("joinPassInput"),
  passHint: document.getElementById("joinPassHint"),
  passClose: document.getElementById("btnCloseJoinPass"),
  passOk: document.getElementById("btnJoinPassOk"),
};

let _roomCache = [];     // [{roomId, meta}]
let _pendingJoin = null; // { roomId, meta }
let _roomsMetaRef = null;
let _roomListStarted = false;

function normRoomCode(s){
  return String(s||"").trim().toUpperCase();
}

function escapeHtml(s){
  return String(s||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function renderRoomList(filterText=""){
  if (!ROOMUI.listEl) return;

  const q = normRoomCode(filterText);
  const items = _roomCache
    .filter(r=>{
      if (!q) return true;
      const code = normRoomCode(r.roomId);
      const name = normRoomCode(r.meta?.roomName || "");
      return code.includes(q) || name.includes(q);
    })
    .sort((a,b)=> (a.meta?.roomNo||999999) - (b.meta?.roomNo||999999));

  ROOMUI.listEl.innerHTML = "";

  if (items.length === 0){
    ROOMUI.listEl.innerHTML = `<div style="opacity:.6; padding:10px;">Kh√¥ng c√≥ ph√≤ng ph√π h·ª£p</div>`;
    return;
  }

  for (const r of items){
    const code = normRoomCode(r.roomId);
    const name = (r.meta?.roomName || code);
    const locked = !!r.meta?.hasPassword;
    const mode = r.meta?.mode || "";

    const row = document.createElement("div");
    row.style.cssText = `
      display:flex; gap:10px; align-items:center;
      padding:10px; border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    `;

    row.innerHTML = `
      <div style="width:110px; font-weight:700; letter-spacing:.6px;">${escapeHtml(code)}</div>
      <div style="flex:1; opacity:.92;">
        <div style="font-weight:650;">${escapeHtml(name)}</div>
        <div style="font-size:12px; opacity:.7;">${escapeHtml(mode)}</div>
      </div>
      <div style="width:60px; text-align:right; opacity:.8;">${locked ? "üîí" : ""}</div>
      <button class="primary" style="width:92px;">V√†o</button>
    `;

    const btn = row.querySelector("button");
    btn.addEventListener("click", async ()=>{
      await onClickJoinRoomFromList(r.roomId, r.meta);
    });

    ROOMUI.listEl.appendChild(row);
  }
}

function startRoomListListener(){
  if (_roomsMetaRef) return;
  _roomsMetaRef = FB.db.ref("AllRoomMeta");

  _roomsMetaRef.on("value", (snap)=>{
    const v = snap.val() || {};
    const arr = [];

    for (const roomId in v){
      const meta = v[roomId] || null;
      if (!meta) continue;
      if (meta.status && meta.status !== "active") continue;
      arr.push({ roomId, meta });
    }

    _roomCache = arr;
    renderRoomList(ROOMUI.searchEl?.value || "");
  });
}

function stopRoomListListener(){
  if (_roomsMetaRef){
    _roomsMetaRef.off();
    _roomsMetaRef = null;
  }
  _roomListStarted = false;
}

// Search input
if (ROOMUI.searchEl){
  ROOMUI.searchEl.addEventListener("input", ()=>{
    renderRoomList(ROOMUI.searchEl.value);
  });
}

// ===============================
//  Join-from-list flow
//  - if locked -> popup
//  - else join direct
// ===============================
async function onClickJoinRoomFromList(roomId, meta){
  await fbEnsureAuth();

  client.roomId = String(roomId).toLowerCase();
  client.roomCode = String(roomId).toUpperCase();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;

  if (meta?.hasPassword){
    _pendingJoin = { roomId, meta };
    openJoinPassPopup(roomId);
    return;
  }

  // kh√¥ng pass -> join th·∫≥ng (skip password check)
  await joinRoomAsClient_Firebase({ skipPasswordCheck:true });
}

function openJoinPassPopup(roomId){
  if (!ROOMUI.passPopup) return;
  ROOMUI.passPopup.style.display = "flex";
  if (ROOMUI.passInput) ROOMUI.passInput.value = "";
  if (ROOMUI.passHint) ROOMUI.passHint.textContent = `Ph√≤ng: ${String(roomId).toUpperCase()}`;
  setTimeout(()=> ROOMUI.passInput?.focus(), 0);
}

function closeJoinPassPopup(){
  if (!ROOMUI.passPopup) return;
  ROOMUI.passPopup.style.display = "none";
  _pendingJoin = null;
}

if (ROOMUI.passClose){
  ROOMUI.passClose.addEventListener("click", closeJoinPassPopup);
}

async function submitJoinWithPassword(){
  if (!_pendingJoin) return;

  const { roomId, meta } = _pendingJoin;
  const pass = (ROOMUI.passInput?.value || "").trim();
  if (!pass) return toast("Nh·∫≠p m·∫≠t kh·∫©u");

  const salt = meta.passSalt || "";
  const expected = meta.passHash || "";
  const got = await sha256Hex(`${salt}:${pass}`);

  if (!salt || !expected || got !== expected){
    toast("Sai m·∫≠t kh·∫©u ph√≤ng");
    return;
  }

  closeJoinPassPopup();

  client.roomId = String(roomId).toLowerCase();
  client.roomCode = String(roomId).toUpperCase();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;

  // pass ƒë√£ OK -> join, skip password check trong join
  await joinRoomAsClient_Firebase({ skipPasswordCheck:true });
}

if (ROOMUI.passOk){
  ROOMUI.passOk.addEventListener("click", submitJoinWithPassword);
}
if (ROOMUI.passInput){
  ROOMUI.passInput.addEventListener("keydown", (e)=>{
    if (e.key === "Enter") submitJoinWithPassword();
    if (e.key === "Escape") closeJoinPassPopup();
  });
}

// ===============================
//  JOIN ROOM (CLIENT) - FULL
//  - default: check password from AllRoom/meta
//  - when coming from list popup: skipPasswordCheck=true
// ===============================
async function claimSeat(roomRef, maxPlayers = 4){
  const uid = FB.uid;

  // n·∫øu uid ƒë√£ c√≥ trong users th√¨ gi·ªØ nguy√™n seat
  const usersSnap0 = await roomRef.child("users").get();
  const users0 = usersSnap0.val() || {};
  if (users0[uid] && Number.isInteger(users0[uid].seat)) return users0[uid].seat;

  // th·ª≠ claim seat b·∫±ng transaction ƒë·ªÉ tr√°nh tr√πng
  for (let attempt = 0; attempt < maxPlayers; attempt++){
    const usersSnap = await roomRef.child("users").get();
    const users = usersSnap.val() || {};

    const taken = new Set(
      Object.values(users)
        .map(u => u?.seat)
        .filter(s => Number.isInteger(s))
    );

    let seat = -1;
    for (let i = 0; i < maxPlayers; i++){
      if (!taken.has(i)) { seat = i; break; }
    }
    if (seat < 0) throw new Error("Ph√≤ng ƒë√£ ƒë·ªß ng∆∞·ªùi (4/4).");

    // claim seat
    const claimRef = roomRef.child(`seatClaims/${seat}`);
    const tx = await claimRef.transaction(cur => (cur === null ? uid : undefined));

    if (tx.committed && tx.snapshot.val() === uid){
      return seat;
    }
    // n·∫øu kh√¥ng commit => seat v·ª´a b·ªã ng∆∞·ªùi kh√°c l·∫•y, loop l·∫°i
  }

  throw new Error("Kh√¥ng gi·ªØ ƒë∆∞·ª£c seat (race). Th·ª≠ v√†o l·∫°i.");
}

async function joinRoomAsClient_Firebase(opts = {}){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  if (!client.roomCode) readInputs();

  client.roomId = client.roomCode.toLowerCase();
  if (!client.roomId.startsWith("room")) return toast("Nh·∫≠p room d·∫°ng: room1 / ROOM1");

  const roomRef = FB.db.ref(`AllRoom/${String(client.roomId).toLowerCase()}`);

  const metaSnap = await roomRef.child("meta").get();
  if (!metaSnap.exists()) return toast("Room kh√¥ng t·ªìn t·∫°i / ƒë√£ ƒë√≥ng");
  const meta = metaSnap.val() || {};
  client.roomMeta = client.roomMeta || { roomNo:null, roomId:null };
  client.roomMeta.roomNo = meta.roomNo ?? client.roomMeta.roomNo;
  client.roomMeta.roomId = client.roomId;
  client.roomMeta.roomName = meta.roomName || client.roomMeta.roomName;

  if (!opts.skipPasswordCheck && meta.hasPassword){
    const pass = prompt("Ph√≤ng c√≥ m·∫≠t kh·∫©u. Nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ v√†o:");
    if (pass == null) return;

    const salt = meta.passSalt || "";
    const expected = meta.passHash || "";
    const got = await sha256Hex(`${salt}:${String(pass).trim()}`);

    if (!salt || !expected || got !== expected){
      toast("Sai m·∫≠t kh·∫©u ph√≤ng");
      return;
    }
  }

  // ‚úÖ join user: spectator
  await roomRef.child(`users/${FB.uid}`).set({
    username: FB.username,
    joinedAt: Date.now(),
    role: "spectator",
    playSeat: null,
    atk: 0, def: 0, hp: 0, coin: 0,
  });

  client.isHost = false;
  client.host = null;

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);

  // lobby meta + seatClaims
  installLobbyRealtimeListeners(roomRef);

  // users listener (transport)
  t.listenUsers((users)=>{
    client.lobby.users = users || {};
    setStatusUI?.();
    renderLobby?.(
      client.roomId,
      client.lobby.meta,
      client.lobby.users,
      client.lobby.seatClaimsPlay
    );
  });
  await t.attachPresence();

  // ‚úÖ avoid duplicate presence listener
  try{ if (_presenceCb) roomRef.child("presence").off("value", _presenceCb); }catch(e){}
  _presenceCb = ()=> { maybeElectNewHost(roomRef).catch(()=>{}); };
  roomRef.child("presence").on("value", _presenceCb);
  maybeElectNewHost(roomRef).catch(()=>{});

  // ‚úÖ listen hostId -> b·∫≠t/t·∫Øt authority
  try{ if (_hostIdCb) roomRef.child("meta/hostId").off("value", _hostIdCb); }catch(e){}
  _hostIdCb = (snap)=>{
    const hostId = snap.val() || "";
    const amHost = (hostId === (FB.uid || ""));

    if (amHost && !client.isHost){
      client.isHost = true;
      startHostAuthority(client.roomId).catch(()=>{});
    }else if (!amHost && client.isHost){
      client.isHost = false;
      stopHostAuthority();
    }
    setStatusUI?.();
  };
  roomRef.child("meta/hostId").on("value", _hostIdCb);

  await t.sendIntent({ type: "join" });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    const red = redactStateForViewer(st, FB.uid);
    if (!red) return;
    client.authoritative = red;
    client.lastVersion = red.version || client.lastVersion;
    setStatusUI();
  });

  toast("ƒê√£ v√†o " + client.roomCode);
  installFirebaseRoomCleanup(client.roomId, meta.roomNo);
  goMatch();
}

async function maybeElectNewHost(roomRef){
  const uid = FB.uid;
  if (!uid) return;

  // l·∫•y snapshot c·∫ßn thi·∫øt
  const [metaSnap, usersSnap, presSnap] = await Promise.all([
    roomRef.child("meta").get(),
    roomRef.child("users").get(),
    roomRef.child("presence").get(),
  ]);

  const meta = metaSnap.val() || {};
  const users = usersSnap.val() || {};
  const pres  = presSnap.val()  || {};

  const curHostId = meta.hostId || "";
  if (!curHostId) return; // ph√≤ng ch∆∞a set hostId

  // n·∫øu host v·∫´n online -> th√¥i
  const hostOnline = !!pres[curHostId];
  if (hostOnline) return;

  // build list candidates online
  const onlineUsers = Object.entries(users)
    .map(([id,u])=>({ id, ...(u||{}) }))
    .filter(u => u.id && pres[u.id]); // online only

  if (onlineUsers.length === 0) return;

  // x√°c ƒë·ªãnh hostSeat (n·∫øu bi·∫øt)
  const hostUser = users[curHostId] || null;
  const hostSeatRaw = (hostUser?.playSeat ?? hostUser?.seat);
  const hostSeat = Number.isInteger(hostSeatRaw) ? (hostSeatRaw|0) : -1;

  // helper ch·ªçn ·ª©ng vi√™n "g·∫ßn nh·∫•t"
  const seatOf = (u)=>{
    const s = (u?.playSeat ?? u?.seat);
    return Number.isInteger(s) ? (s|0) : null;
  };
  
  const playUsers = onlineUsers.filter(u => seatOf(u) !== null);
  let best = null;

  if (playUsers.length){
    // s·∫Øp theo kho·∫£ng c√°ch v√≤ng t·ª´ hostSeat
    const dist = (seat)=>{
      if (hostSeat < 0) return 999; // kh√¥ng bi·∫øt host seat
      const d = (seat - hostSeat + 4) % 4;
      return d === 0 ? 4 : d; // tr√°nh ch·ªçn l·∫°i hostSeat
    };

      best = playUsers
      .slice()
      .sort((a,b)=>{
        const sa = seatOf(a);
        const sb = seatOf(b);
        const da = dist(sa);
        const db = dist(sb);

        if (da !== db) return da - db;
        // tie-break: joinedAt s·ªõm h∆°n
        return (a.joinedAt||0) - (b.joinedAt||0);
      })[0];
  } else {
    // fallback: spectator joined s·ªõm nh·∫•t
    best = onlineUsers
      .slice()
      .sort((a,b)=> (a.joinedAt||0) - (b.joinedAt||0))[0];
  }

  if (!best?.id) return;

  // ch·ªâ ng∆∞·ªùi ƒë∆∞·ª£c ch·ªçn m·ªõi attempt takeover
  if (best.id !== uid) return;

  // transaction ƒë·ªÉ tr√°nh 2 ng∆∞·ªùi c√πng gi√†nh host
  await roomRef.child("meta/hostId").transaction((cur)=>{
    // ch·ªâ takeover n·∫øu host hi·ªán t·∫°i v·∫´n l√† curHostId (tr√°nh ƒë√® ng∆∞·ªùi kh√°c ƒë√£ takeover)
    if (cur === curHostId) return uid;
    return; // abort
  });

  // optional: ghi log
  await roomRef.child("meta/hostChangedAt").set(Date.now()).catch(()=>{});
}

let _stopHostIntents = null;
let _hostGuardCb = null; // cache hostId hi·ªán t·∫°i ƒë·ªÉ host-lock nh·∫π

async function startHostAuthority(roomId){
  const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);

  // 1) ƒë·∫£m b·∫£o transport t·ªìn t·∫°i
  const t = client.transport;
  if (!t) return;

  // 2) t·∫°o HostController n·∫øu ch∆∞a c√≥
  if (!client.host){
    client.host = new HostController(client.roomCode, FB.uid);
  }

  // 3) l·∫•y state hi·ªán t·∫°i t·ª´ DB ƒë·ªÉ takeover ti·∫øp t·ª•c (kh√¥ng reset b√†n)
  const stSnap = await roomRef.child("state").get();
  const st = stSnap.val();
  if (st && typeof st === "object"){
    client.host.state = st;
  }

  // 4) sync hostId trong state theo meta.hostId (ƒë·ªÉ quy·ªÅn host-only trong applyIntent ho·∫°t ƒë·ªông)
  client.host.state.hostId = FB.uid;

  // 5) host lock nh·∫π: cache meta/hostId b·∫±ng listener 1 l·∫ßn
  if (!_hostGuardCb){
    _hostGuardCb = (snap)=>{
      client._hostIdNow = snap.val() || "";
    };
    roomRef.child("meta/hostId").on("value", _hostGuardCb);
    // n·∫°p ngay
    try{ client._hostIdNow = (await roomRef.child("meta/hostId").get()).val() || ""; }catch(e){}
  }

  // 6) b·∫≠t listen intents (ch·ªâ b·∫≠t 1 l·∫ßn)
  if (_stopHostIntents) return;

  const unsub = t.listenIntentsAsHost(async (msg, intentKey, intentRef)=>{
    const action = msg.action;
    const fromId = msg.fromId;

    // ‚úÖ host lock: n·∫øu m√¨nh kh√¥ng c√≤n l√† host th√¨ ch·ªâ ack r·ªìi b·ªè
    const hostIdNow = client._hostIdNow || "";
    if (hostIdNow !== (FB.uid || "")){
      try{ await t.ackIntent(intentRef); }catch(e){}
      return;
    }

    // --- A) JOIN: ch·ªâ sync name/players n·∫øu user ƒëang NG·ªíI GH·∫æ (playSeat != null) ---
    if (action?.type === "join"){
      await hostRebuildPlayersFromLobby(roomRef);
      try{
        const u = (await roomRef.child(`users/${fromId}`).get()).val() || {};
        if (Number.isInteger(u.playSeat)){
          const seat = u.playSeat|0;
          const uname = u.username || msg.fromName || "Player";
          client.host.addOrUpdatePlayerAtSeat(fromId, uname, seat);
          await t.writeState(client.host.state);
        }
      }catch(e){}
      try{ await t.ackIntent(intentRef); }catch(e){}
      return;
    }

    // --- B) SIT/UNSIT: lobby seat -> state.players mapping ---
    if (action?.type === "sit"){
      await hostRebuildPlayersFromLobby(roomRef);
      const seat = action.seat|0;
      if (seat < 0 || seat > 3){
        try{ await t.ackIntent(intentRef); }catch(e){}
        return;
      }

      let uname = msg.fromName || "Player";
      try{
        const u = (await roomRef.child(`users/${fromId}`).get()).val() || {};
        uname = u.username || uname;
      }catch(e){}

      const rr = client.host.addOrUpdatePlayerAtSeat(fromId, uname, seat);
      if (rr?.ok){
        await t.writeState(client.host.state);
      }
      try{ await t.ackIntent(intentRef); }catch(e){}
      return;
    }

    if (action?.type === "unsit"){
      await hostRebuildPlayersFromLobby(roomRef);
      client.host.removePlayer(fromId);
      await t.writeState(client.host.state);
      try{ await t.ackIntent(intentRef); }catch(e){}
      return;
    }

    // --- C) LEAVE: remove kh·ªèi state.players, xo√° user entry (seatClaims ƒë√£ release ·ªü client leave/unseat) ---
    if (action?.type === "leave"){
      await hostRebuildPlayersFromLobby(roomRef);
      client.host.removePlayer(fromId);
      try{ await roomRef.child(`users/${fromId}`).remove(); }catch(e){}
      await t.writeState(client.host.state);
      try{ await t.ackIntent(intentRef); }catch(e){}
      return;
    }

    // --- D) apply gameplay intents (move/flip/draw/...) ---
    const r = client.host.applyIntent(fromId, action);
    if (!r.ok && fromId === (FB.uid || "")) toast("Action fail: " + r.reason);

    if (r.ok){
      await t.writeState(client.host.state);
    }

    try{ await t.ackIntent(intentRef); }catch(e){}
  });

  _stopHostIntents = (typeof unsub === "function") ? unsub : null;

  console.log("[host] authority started");
}

function stopHostAuthority(){
  try{
    if (_stopHostIntents) _stopHostIntents();
  }catch(e){}
  _stopHostIntents = null;

  try{
    const roomId = client.roomId;
    if (roomId && _hostGuardCb){
      const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);
      roomRef.child("meta/hostId").off("value", _hostGuardCb);
    }
  }catch(e){}
  _hostGuardCb = null;
  client._hostIdNow = "";

  console.log("[host] authority stopped");
}
  
// ===============================
//  Bind create-room button
// ===============================
if (UI.doCreateRoomBtn){
  UI.doCreateRoomBtn.addEventListener("click", async ()=>{
    try{
      await createRoomAsHost_Firebase();
    }catch(e){
      console.error(e);
      toast("Create error: " + (e.message || e));
    }
  });
}

// ===============================
//  Leave room
// ===============================
async function releaseMySeatClaim(roomId, seat){
  try{
    const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);

    let s = seat;

    // fallback: n·∫øu kh√¥ng truy·ªÅn seat th√¨ ƒë·ªçc t·ª´ users
    if (!Number.isInteger(s)){
      const usersSnap = await roomRef.child(`users/${FB.uid}`).get();
      const u = usersSnap.val();
      s = u?.seat;
    }

    if (Number.isInteger(s)){
      await roomRef.child(`seatClaims/${s}`).remove();
    }
  }catch(e){
    console.warn("releaseMySeatClaim error", e);
  }
}

async function leaveRoom(){
  const roomId = client.roomId;   // gi·ªØ l·∫°i tr∆∞·ªõc khi reset
  const uid    = FB?.uid || "";

  try{
    try{ await client.transport?.sendIntent?.({ type:"leave" }); }catch(e){}

    if (roomId && uid){
      const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);

      // ‚õî hi·ªán t·∫°i join v√†o spectator, ch∆∞a d√πng seatClaims -> kh√¥ng c·∫ßn release
      // await releaseMySeatClaim(roomId, client.mySeat).catch(()=>{});

      await roomRef.child(`presence/${uid}`).remove().catch(()=>{});
      await roomRef.child(`users/${uid}`).remove().catch(()=>{});
    }
  }catch(e){
    console.warn("leaveRoom error", e);
  }

  try{
    const rr = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);
    if (_metaCb) rr.child("meta").off("value", _metaCb);
    if (_seatClaimsCb) rr.child("seatClaims/play").off("value", _seatClaimsCb);
  }catch(e){}
  _metaCb = null;
  _seatClaimsCb = null;
  
  // ‚úÖ off listener theo ƒë√∫ng roomId ƒë√£ l∆∞u
  try{
    if (roomId){
      const rr = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`);
      if (_presenceCb) rr.child("presence").off("value", _presenceCb);
      if (_hostIdCb) rr.child("meta/hostId").off("value", _hostIdCb);
    }
  }catch(e){}

  _presenceCb = null;
  _hostIdCb = null;

  try{ client.transport?.close?.(); }catch(e){}
  resetClientSession();
  goLobby?.();
}

// ===============================
//  Host cleanup when everyone leaves
//  - remove AllRoom + AllRoomMeta
// ===============================
function installFirebaseRoomCleanup(roomId, roomNo){
  const roomRef = FB.db.ref(`AllRoom/${String(roomId).toLowerCase()}`)
  const presRef = roomRef.child("presence");
  const metaRef = FB.db.ref(`AllRoomMeta/${roomId}`);
  const lockRef = roomRef.child("meta/cleanupLock"); // kho√° ch·ªëng race

  presRef.on("value", async (snap)=>{
    const v = snap.val() || {};
    const keys = Object.keys(v);

    // c√≤n ng∆∞·ªùi -> kh√¥ng l√†m g√¨
    if (keys.length !== 0) return;

    // ‚úÖ l·∫•y lock b·∫±ng transaction: ch·ªâ 1 client ƒë∆∞·ª£c d·ªçn
    let lockResult;
    try{
      lockResult = await lockRef.transaction(cur=>{
        if (cur) return; // ƒë√£ c√≥ ng∆∞·ªùi lock
        return { uid: FB.uid, at: Date.now() };
      });
    }catch(e){
      return;
    }

    if (!lockResult?.committed) return;

    // ‚úÖ double-check presence v·∫´n r·ªóng (tr√°nh case c√≥ ng∆∞·ªùi v√†o l·∫°i)
    let again = {};
    try{
      again = (await presRef.get()).val() || {};
    }catch(e){}

    if (Object.keys(again).length !== 0){
      try{ await lockRef.remove(); }catch(e){}
      return;
    }

    // ‚úÖ xo√° room + meta mirror + tr·∫£ roomNo
    try{ await roomRef.remove(); }catch(e){}
    try{ await metaRef.remove(); }catch(e){}
    try{ await fbReleaseRoomNo(roomNo); }catch(e){}
  });
}

function installHostPresenceReconcile(roomId){
  const roomRef  = FB.db.ref(`AllRoom/${roomId}`);
  const presRef  = roomRef.child("presence");
  const usersRef = roomRef.child("users");

  let _busy = false;

  presRef.on("value", async (snap)=>{
    if (!client.isHost || !client.host?.state) return;
    if (_busy) return;
    _busy = true;

    try{
      const pres = snap.val() || {};
      const online = new Set(Object.keys(pres)); // uid ƒëang online

      let changed = false;

      // 1) D·ªçn users/<uid> kh√¥ng c√≤n online
      const usersSnap = await usersRef.get();
      const users = usersSnap.val() || {};
      const updates = {};
      for (const uid in users){
        if (!online.has(uid)){
          updates[uid] = null;
        }
      }
      if (Object.keys(updates).length){
        await usersRef.update(updates);
        changed = true;
      }

      // 2) D·ªçn state.players theo slot (kh√¥ng filter)
      const st = client.host.state;
      st.players = st.players || [];
      for (let i=0; i<4; i++){
        const p = st.players[i];
        if (p && !online.has(p.id)){
          st.players[i] = null;
          changed = true;
        }
      }

      // ‚úÖ ch·ªâ writeState n·∫øu c√≥ thay ƒë·ªïi
      if (changed){
        if (typeof client.host.bumpVersion === "function") client.host.bumpVersion();
        await client.transport.writeState(st);
      }
    }catch(e){
      // ignore
    }finally{
      _busy = false;
    }
  });
}

/* =========================================================
   13) Deck/SetCard Modal (RTDB) - Firebase-only
========================================================= */
const DECKUI = {
  modal: document.getElementById("deckModal"),
  openBtn: document.getElementById("openDeckBtn"),
  closeBtn: document.getElementById("closeDeckBtn"),
  userBadge: document.getElementById("deckUserBadge"),

  setSelect: document.getElementById("setSelect"),
  newSetBtn: document.getElementById("newSetBtn"),
  loadSetBtn: document.getElementById("loadSetBtn"),
  deleteSetBtn: document.getElementById("deleteSetBtn"),

  setNameInput: document.getElementById("setNameInput"),
  backUrlInput: document.getElementById("setBackUrlInput"),
  addCardBtn: document.getElementById("addCardUrlBtn"),
  list: document.getElementById("cardUrlList"),

  saveBtn: document.getElementById("saveSetBtn"),
};

let deckSetsCache = {};
let deckCurrentSetId = null;

function openDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "flex"; }
function closeDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "none"; }

function makeCardTypeRow({frontUrl="", count=1, name=""} = {}){
  const row = document.createElement("div");
  row.className = "card-url-row";

  const inpName = document.createElement("input");
  inpName.className = "mono";
  inpName.placeholder = "T√™n l√° b√†i";
  inpName.value = name;
  inpName.style.width = "40%";

  const inpUrl = document.createElement("input");
  inpUrl.className = "mono";
  inpUrl.placeholder = "https://.../front.png";
  inpUrl.value = frontUrl;
  inpUrl.style.width = "40%";

  const inpCount = document.createElement("input");
  inpCount.type = "number";
  inpCount.min = "1";
  inpCount.step = "1";
  inpCount.value = String(Math.max(1, parseInt(count,10)||1));
  inpCount.style.width = "8%";

  const del = document.createElement("button");
  del.className = "danger";
  del.textContent = "X";
  del.onclick = ()=> row.remove();

  row.appendChild(inpName);
  row.appendChild(inpUrl);
  row.appendChild(inpCount);
  row.appendChild(del);
  return row;
}

function fillEditorFromSet(setId, data){
  deckCurrentSetId = setId;
  DECKUI.setNameInput.value = data?.name || "";
  DECKUI.backUrlInput.value = data?.backUrl || "";
  DECKUI.list.innerHTML = "";

  const cardsObj = data?.cards || {};
  const types = Object.values(cardsObj);

  for (const t of types){
    DECKUI.list.appendChild(makeCardTypeRow({
      name: t.name || "",
      frontUrl: t.frontUrl || "",
      count: t.count || 1
    }));
  }
  if (types.length === 0){
    DECKUI.list.appendChild(makeCardTypeRow());
  }
}

function editorToSetData(){
  const name = (DECKUI.setNameInput.value||"").trim() || "Untitled";
  const backUrl = (DECKUI.backUrlInput.value||"").trim();

  const rows = [...DECKUI.list.querySelectorAll(".card-url-row")];

  const cards = {};
  let idx = 1;
  for (const row of rows){
    const inputs = row.querySelectorAll("input");
    const rowName  = (inputs[0]?.value || "").trim();
    const frontUrl = (inputs[1]?.value || "").trim();
    const count    = Math.max(1, parseInt(inputs[2]?.value || "1", 10) || 1);

    if (!frontUrl) continue;
    cards["t"+idx] = { name: rowName, frontUrl, count };
    idx++;
  }

  return { name, backUrl, cards, updatedAt: Date.now() };
}

async function refreshSetList(){
  await fbEnsureAuth();
  if (DECKUI.userBadge) DECKUI.userBadge.textContent = `UID: ${FB.uid.slice(0,6)}... | ${FB.username}`;

  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard`);
  const snap = await ref.get();
  deckSetsCache = snap.val() || {};

  if (!DECKUI.setSelect) return;

  DECKUI.setSelect.innerHTML = "";
  const ids = Object.keys(deckSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(ch∆∞a c√≥ set)";
    DECKUI.setSelect.appendChild(op);
    deckCurrentSetId = null;
    fillEditorFromSet(null, {name:"", backUrl:"", cards:{}});
    return;
  }

  for (const id of ids){
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${deckSetsCache[id]?.name || id} (${Object.keys(deckSetsCache[id]?.cards||{}).length})`;
    DECKUI.setSelect.appendChild(op);
  }

  const pick = (deckCurrentSetId && deckSetsCache[deckCurrentSetId]) ? deckCurrentSetId : ids[0];
  DECKUI.setSelect.value = pick;
  fillEditorFromSet(pick, deckSetsCache[pick]);
}

async function createNewSet(){
  await fbEnsureAuth();
  const newId = "set_" + uid().slice(0,8);
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${newId}`);
  await ref.set({ name:"New Set", backUrl:"", cards:{}, createdAt: Date.now(), updatedAt: Date.now() });
  await refreshSetList();
  if (DECKUI.setSelect) DECKUI.setSelect.value = newId;
  fillEditorFromSet(newId, deckSetsCache[newId]);
}

async function saveCurrentSet(){
  await fbEnsureAuth();
  if (!deckCurrentSetId) await createNewSet();
  const data = editorToSetData();
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${deckCurrentSetId}`);
  await ref.update(data);
  toast("ƒê√£ l∆∞u set");
  await refreshSetList();
}

async function deleteCurrentSet(){
  await fbEnsureAuth();
  const id = DECKUI.setSelect?.value;
  if (!id) return;
  await FB.db.ref(`AllUser/${FB.uid}/setCard/${id}`).remove();
  toast("ƒê√£ x√≥a set");
  deckCurrentSetId = null;
  await refreshSetList();
}

async function loadSelectedSet(){
  const id = DECKUI.setSelect?.value;
  if (!id || !deckSetsCache[id]) return;
  fillEditorFromSet(id, deckSetsCache[id]);
  toast("ƒê√£ load set v√†o editor");
}

/* =========================================================
   14) Images cache
========================================================= */
const imgCache = new Map();
function loadImg(url){
  url = (url || "").trim();
  if (!url) return null;

  // reuse
  const cached = imgCache.get(url);
  if (cached) return cached;

  const im = new Image();
  im.crossOrigin = "anonymous"; // ‚úÖ gi√∫p v·∫Ω canvas ·ªïn ƒë·ªãnh h∆°n v·ªõi nhi·ªÅu host
  im.decoding = "async";

  im.onload = () => { /* ok */ };
  im.onerror = () => {
    // n·∫øu link ch·∫øt/kh√¥ng ph·∫£i direct image
    console.warn("[img] failed:", url);
  };

  im.src = url;
  imgCache.set(url, im);
  return im;
}


/* =========================================================
   15) Chat
========================================================= */
const CHATUI = {
  mode: "all", // "all" | "team"
  lastCount: 0,
};

function fmtTime(ts){
  try{
    const d = new Date(ts);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }catch(e){
    return "";
  }
}

function getPlayerById(s, id){
  return (s.players || []).find(p => p && p.id === id) || null;
}

function renderChat(){
  const s = getState();
  if (!s) return;

  const log = document.getElementById("chatLog");
  const badge = document.getElementById("chatBadge");
  if (!log || !badge) return;

  const msgs = (s.chat || []);
  badge.textContent = String(msgs.length);

  // TEAM filter th·∫≠t th√¨ filter ·ªü ƒë√¢y.
  const visible = msgs;

  log.innerHTML = "";

  const n = visible.length;
  for (let i = 0; i < n; i++){
    const m = visible[i];
    const p = getPlayerById(s, m.fromId);
    const name = p?.name || "Player";
    const dot = p ? (COLORS?.[p.color] || "rgba(255,255,255,.55)") : "rgba(255,255,255,.35)";
    const time = m.at ? fmtTime(m.at) : "";

    let ageCls = "";
    const age = n - i;
    if (age > 18) ageCls = "age4";
    else if (age > 12) ageCls = "age3";
    else if (age > 7) ageCls = "age2";

    const row = document.createElement("div");
    row.className = `msg ${ageCls}`;
    row.innerHTML = `
      <div class="dot" style="background:${dot}"></div>
      <div class="bubble">
        <div class="meta">
          <span class="name">${escapeHtml(name)}</span>
          <span class="time">${escapeHtml(time)}</span>
        </div>
        <div class="text">${escapeHtml(m.text || "")}</div>
      </div>
    `;
    log.appendChild(row);
  }

  if (msgs.length !== CHATUI.lastCount){
    log.scrollTop = log.scrollHeight;
    CHATUI.lastCount = msgs.length;
  }
}

(function initChatToggle(){
  const tg = document.getElementById("chatToggle");
  if (!tg) return;
  tg.addEventListener("click", (e)=>{
    const btn = e.target.closest("button[data-mode]");
    if (!btn) return;
    CHATUI.mode = btn.dataset.mode;
    tg.querySelectorAll("button").forEach(b=>b.classList.toggle("active", b===btn));
    renderChat();
  });
})();

(function initChatForm(){
  const form = document.getElementById("chatForm");
  const input = document.getElementById("chatInput");
  if (!form || !input) return;

  form.addEventListener("submit", (e)=>{
    e.preventDefault();
    const text = (input.value || "").trim();
    if (!text) return;
    input.value = "";
    sendIntent({ type:"chat", text });
  });
})();

/* =========================================================
   16) Input / HitTest / Drag
========================================================= */
function mousePos(ev){
  const rect = canvas.getBoundingClientRect();
  return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
}

function cardZ(c){
  let z = 10;
  if (c.zone === ZONES.table) z = 50;
  if (c.zone === ZONES.discard) z = 50;
  if (c.zone === ZONES.hand) z = 80;
  if (c.zone === ZONES.deck) z = 40;
  return z + (c.order||0)*0.001;
}

function stackZ(s){
  let z = 12;
  if (s.zone === ZONES.table) z = 55;
  if (s.zone === ZONES.hand) z = 85;
  if (s.zone === ZONES.deck) z = 42;
  if (s.zone === ZONES.discard) z = 55;
  return z + (s.cardIds?.length||0)*0.01;
}

/* =========================================================
   C) State helpers (compat: old st.cards + new st.all.cards)
========================================================= */
function getAllCardsMap(st){
  // ∆∞u ti√™n model m·ªõi
  if (st?.all?.cards && typeof st.all.cards === "object") return st.all.cards;
  // fallback model c≈©
  if (st?.cards && typeof st.cards === "object") return st.cards;
  return {};
}

function getCardById(st, id){
  const mNew = st?.all?.cards;
  if (mNew && mNew[id]) return mNew[id];
  const mOld = st?.cards;
  if (mOld && mOld[id]) return mOld[id];
  return null;
}

function getStackById(st, id){
  if (st?.stacks && st.stacks[id]) return st.stacks[id];
  return null;
}

function getStackTopCardId(st, stack){
  if (!stack) return null;
  const ids = stack.cardIds || [];
  return ids.length ? ids[0] : null;
}

  
function listDrawableObjects(state){
  const out = [];
  if (!state) return out;

  // stacks
  for (const sid in (state.stacks || {})){
    const s = state.stacks[sid];
    if (!s) continue;
    out.push({
      type:"stack",
      id:sid,
      x:s.x, y:s.y,
      zone:s.zone,
      owner:(s.owner ?? s.ownerId ?? null),
      z: (typeof s.z === "number" ? s.z : stackZ(s))
    });
  }

  // free cards (NOT in stack)
  const allCards = getAllCardsMap(state);
  for (const cid in allCards){
    const c = allCards[cid];
    if (!c) continue;
    if (c.stackId) continue;
    if (typeof c.x !== "number" || typeof c.y !== "number") continue;

    out.push({
      type:"card",
      id:cid,
      x:c.x, y:c.y,
      zone:c.zone,
      owner:(c.owner ?? null),
      z: (typeof c.z === "number" ? c.z : cardZ(c))
    });
  }

  // ‚úÖ sort by z, then type: stack first, card last (card will be drawn on top)
  out.sort((a,b)=>{
    const dz = (a.z||0) - (b.z||0);
    if (dz !== 0) return dz;
    if (a.type === b.type) return 0;
    return (a.type === "stack") ? -1 : 1;
  });

  return out;
}

function hitTest(worldX, worldY){
  const state = getState();
  if (!state) return null;

  const objs = listDrawableObjects(state);
  for (let i=objs.length-1; i>=0; i--){
    const o = objs[i];
    const w = CARD.w, h = CARD.h;
    const x0 = o.x - w/2, y0 = o.y - h/2;
    if (worldX >= x0 && worldX <= x0+w && worldY >= y0 && worldY <= y0+h){
      // ch·∫∑n click v√†o HAND ng∆∞·ªùi kh√°c
      if (o.zone === ZONES.hand && o.owner && o.owner !== client.selfId) return null;
      return {type:o.type, id:o.id};
    }
  }
  return null;
}

function calcDragOffset(state, target, p){
  if (target.type === "card"){
    const c = getCardById(state, target.id);
    if (!c) return {dx:0,dy:0};
    return {dx: p.x - c.x, dy: p.y - c.y};
  } else {
    const s = getStackById(state, target.id);
    if (!s) return {dx:0,dy:0};
    return {dx: p.x - s.x, dy: p.y - s.y};
  }
}


// ======= CANVAS INPUT (click vs drag + smart inspector) =======
function canInteractCanvas(){
  const meta = client.lobby?.meta || {};
  const gs = meta.gameStatus || "waiting";

  const uid = FB.uid || "";
  const hostId = meta.hostId || meta.hostUid || "";

  // l·∫•y user record t·ª´ lobby.users (ƒë√£ listenUsers)
  const u = client.lobby?.users?.[uid] || null;
  const isSeated = !!(u && Number.isInteger(u.playSeat));

  // waiting: ch·ªâ host ƒë∆∞·ª£c thao t√°c
  if (gs === "waiting"){
    return uid && hostId && uid === hostId;
  }

  // playing: ch·ªâ ng∆∞·ªùi ƒë√£ ng·ªìi gh·∫ø ƒë∆∞·ª£c thao t√°c
  if (gs === "playing"){
    return isSeated;
  }

  return false;
}
  
function amSpectator(){
  const u = client.authoritative?._users?.[FB.uid];
  return !u || !Number.isInteger(u.playSeat);
}
  
const DRAG_THRESHOLD_PX = 6;

canvas.addEventListener("mousedown", (ev)=>{
  if (!canInteractCanvas()) return; // ‚úÖ CH·∫∂N

  const st = getState();
  if (!st) return;

  const p = toWorld(mousePos(ev));
  const hit = hitTest(p.x, p.y);

  if (hit){
    client.selected = hit;
    updateInspector();

    client.dragging = {
      target: hit,
      start: p,
      cur: p,
      offset: calcDragOffset(st, hit, p),
      moved: false,
      started: false,
    };
  } else {
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
  }
});

addEventListener("mousemove", (ev)=>{
  if (!client.dragging) return;
  if (!canInteractCanvas()) return; // ‚úÖ CH·∫∂N

  const st = getState();
  if (!st) return;

  const p = toWorld(mousePos(ev));
  client.dragging.cur = p;

  const sp0 = toScreen(client.dragging.start);
  const sp1 = toScreen(p);
  const ddx = sp1.x - sp0.x;
  const ddy = sp1.y - sp0.y;

  if (!client.dragging.started){
    if (Math.hypot(ddx, ddy) >= DRAG_THRESHOLD_PX){
      client.dragging.started = true;
      client.dragging.moved = true;
      hideInspectorPopup();
    } else {
      return;
    }
  } else {
    client.dragging.moved = true;
    hideInspectorPopup();
  }
});

addEventListener("mouseup", (ev)=>{
  if (!client.dragging) return;
  if (!canInteractCanvas()) return; // ‚úÖ CH·∫∂N

  const st = getState();
  const drag = client.dragging;
  client.dragging = null;
  if (!st) return;

  const p = toWorld(mousePos(ev));

  if (!drag.started){
    showInspectorPopup();
    requestAnimationFrame(positionInspectorNearTarget);
    return;
  }

  const dropHit = hitTest(p.x, p.y);

  if (dropHit && !(dropHit.type === drag.target.type && dropHit.id === drag.target.id)){
    hideInspectorPopup();
    sendIntent({
      type:"stack",
      dragTargetType: drag.target.type,
      dragId: drag.target.id,
      dropOnType: dropHit.type,
      dropOnId: dropHit.id
    });
    return;
  }

  hideInspectorPopup();
  sendIntent({
    type:"move",
    targetType: drag.target.type,
    id: drag.target.id,
    x: p.x - (drag.offset?.dx || 0),
    y: p.y - (drag.offset?.dy || 0),
  });
});

/* =========================================================
   17) Keyboard + Inspector buttons (n√∫t b·∫•m, t∆∞∆°ng t√°c)
========================================================= */
addEventListener("keydown", (ev)=>{
  if (ev.target && (ev.target.tagName==="INPUT" || ev.target.tagName==="TEXTAREA")) return;
  if (!canInteractCanvas()) return; // ‚úÖ CH·∫∂N

  const st = getState();
  if (!st) return;

  const key = ev.key.toLowerCase();

  if (key === "escape"){
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
    return;
  }

  if (key === "delete" || key === "backspace" || key === "x"){
    const sel = client.selected;
    if (!sel) return;

    ev.preventDefault();
    sendIntent({ type:"delete", targetType: sel.type, id: sel.id });
    toast("Request delete (host only)");
    return;
  }

  if (key === "q"){
    const sel = client.selected;
    if (!sel || sel.type !== "stack") return toast("H√£y select 1 stack b√†i ƒë·ªÉ r√∫t");
    sendIntent({ type:"draw", stackId: sel.id, count: 1, random: true });
    toast("Draw 1 (random)");
    return;
  }

  if (key === "w"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"flip", targetType: sel.type, id: sel.id});
    return;
  }

  if (key === "e"){
    const sel = client.selected;
    if (!sel || sel.type !== "stack") return toast("H√£y select 1 stack ƒë·ªÉ shuffle");
    sendIntent({type:"shuffle", stackId: sel.id});
    return;
  }

  if (key === "r"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"unstack", stackId: sel.id});
    return;
  }

  if (key === "t"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"discard", targetType: sel.type, id: sel.id});
    return;
  }
});

if (INS.btnShuffle) INS.btnShuffle.onclick = ()=>{
  if (!canInteractCanvas()) return;
  const st = getState();
  const sel = client.selected;

  const isDeck = (sid)=>{
    const stack = st?.stacks?.[sid] || st?.stackById?.[sid];
    return !!(stack && (stack.kind==="deck" || stack.zone==="deck" || stack.isDeck===true));
  };

  if (sel?.type==="stack" && isDeck(sel.id)) sendIntent({type:"shuffle", stackId: sel.id});
  else sendIntent({type:"shuffle", stackId:"stack_deck"});
};

  
/* =========================================================
   18) Rendering helpers + main loop
========================================================= */
function rr(x,y,w,h,r){
  ctx.beginPath();
  const r2 = Math.min(r, w/2, h/2);
  ctx.moveTo(x+r2, y);
  ctx.arcTo(x+w, y, x+w, y+h, r2);
  ctx.arcTo(x+w, y+h, x, y+h, r2);
  ctx.arcTo(x, y+h, x, y, r2);
  ctx.arcTo(x, y, x+w, y, r2);
  ctx.closePath();
}

function drawZone(rect, label, subtitle="", highlight=false, tint=null){
  const s0 = toScreen({x:rect.x, y:rect.y});
  const s1 = toScreen({x:rect.x+rect.w, y:rect.y+rect.h});
  const x = s0.x, y = s0.y, w = (s1.x-s0.x), h = (s1.y-s0.y);

  ctx.save();

  rr(x,y,w,h,18);

  ctx.globalAlpha = highlight ? 0.85 : 0.35;
  ctx.fillStyle = highlight ? "rgba(122,162,255,.22)" : "rgba(0,0,0,.10)";
  ctx.fill();

  if (tint){
    ctx.globalAlpha = highlight ? 0.18 : 0.10;
    ctx.fillStyle = tint;
    ctx.fill();
  }

  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(233,236,255,.85)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText(label, x+12, y+18);

  if (subtitle){
    ctx.globalAlpha = 0.6;
    ctx.fillText(subtitle, x+12, y+34);
  }

  ctx.restore();
}

function drawCardAtScreen(
  cx, cy,
  faceUp,
  frontSeed,
  accent=null,
  isSelected=false,
  isStackTop=false,
  stackCount=0,
  frontUrl="",
  backUrl=""
){
  const w = CARD.w * camera.scale;
  const h = CARD.h * camera.scale;
  const x = cx - w/2, y = cy - h/2;
  const r = CARD.r * camera.scale;

  const pad = Math.max(1, 1 * camera.scale);

  ctx.save();

  // shadow
  ctx.globalAlpha = 0.30;
  rr(x+3*camera.scale, y+5*camera.scale, w, h, r);
  ctx.fillStyle = "rgba(0,0,0,.70)";
  ctx.fill();
  ctx.globalAlpha = 1;

  // card base
  rr(x, y, w, h, r);
  ctx.fillStyle = "rgba(10,12,18,.82)";
  ctx.fill();

  // image clip (full card, pad 1px)
  const url = faceUp ? (frontUrl || "") : (backUrl || "");
  const img = url ? loadImg(url) : null;

  ctx.save();
  rr(x+pad, y+pad, w-2*pad, h-2*pad, Math.max(1, r-pad));
  ctx.clip();

  if (img && img.complete && img.naturalWidth > 0){
    // ‚úÖ ‚Äúfill‚Äù an to√†n: d√πng cover nh∆∞ng t√≠nh to√°n ƒë∆°n gi·∫£n
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const aw = w - 2*pad, ah = h - 2*pad;

    const scale = Math.max(aw/iw, ah/ih);
    const dw = iw * scale, dh = ih * scale;

    const dx = x + pad + (aw - dw)/2;
    const dy = y + pad + (ah - dh)/2;

    ctx.drawImage(img, dx, dy, dw, dh);
  } else {
    // fallback: v·∫Ω ch·ªØ m√¥ t·∫£ (kh√¥ng ƒë·ª•ng t·ªõi bw/bh)
    ctx.fillStyle = "rgba(233,236,255,.92)";
    ctx.font = `${Math.max(10, 12*camera.scale)}px ui-monospace, monospace`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const label = faceUp && frontSeed ? ("CARD " + String(frontSeed).padStart(2,"0")) : "BACK";
    ctx.fillText(label, x + 10*camera.scale, y + 12*camera.scale);
  }

  ctx.restore();

  // base border
  ctx.lineWidth = Math.max(1, 1.2 * camera.scale);
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  rr(x, y, w, h, r);
  ctx.stroke();

  // ‚úÖ owner border (vi·ªÅn m√†u)
  if (accent){
    ctx.save();
    ctx.globalAlpha = 0.78;
    ctx.lineWidth = Math.max(2, 2.4 * camera.scale);
    ctx.strokeStyle = accent;
    rr(x, y, w, h, r);
    ctx.stroke();

    ctx.globalAlpha = 0.18; // glow nh·∫π
    ctx.lineWidth = Math.max(6, 6 * camera.scale);
    rr(x, y, w, h, r);
    ctx.stroke();
    ctx.restore();
  }

  // selected outline ∆∞u ti√™n h∆°n
  if (isSelected){
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.lineWidth = Math.max(2, 2.8 * camera.scale);
    ctx.strokeStyle = "rgba(122,162,255,.95)";
    rr(x, y, w, h, r);
    ctx.stroke();
    ctx.restore();
  }

  // stack count badge
  if (isStackTop && stackCount > 1){
    ctx.save();
    ctx.globalAlpha = 0.92;
    const bw = 26*camera.scale, bh = 18*camera.scale;
    rr(x + w - bw - 8*camera.scale, y + 8*camera.scale, bw, bh, 7*camera.scale);
    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.lineWidth = Math.max(1, 1*camera.scale);
    ctx.stroke();

    ctx.fillStyle = "rgba(233,236,255,.92)";
    ctx.font = `${Math.max(10, 11*camera.scale)}px ui-monospace, monospace`;
    ctx.fillText(String(stackCount), x + w - bw - 2*camera.scale, y + 21*camera.scale);
    ctx.restore();
  }

  ctx.restore();
}

function players4(s){
  const src = s?.players;
  const out = [null,null,null,null];

  if (!src) return out;

  // case 1: array
  if (Array.isArray(src)){
    for (let i=0;i<4;i++){
      const p = src[i];
      out[i] = (p && typeof p === "object") ? p : null;
    }
    return out;
  }

  // case 2: object {"0":{...},"1":{...}}
  if (typeof src === "object"){
    for (let i=0;i<4;i++){
      const p = src[i] || src[String(i)] || null;
      out[i] = (p && typeof p === "object") ? p : null;
    }
    return out;
  }

  return out;
}

function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(0,0,0,.25)";
  ctx.fillRect(0,0,innerWidth,innerHeight);
  ctx.restore();

  const rects = zoneRects();
  const s = getState();
  if (!s){
    requestAnimationFrame(draw);
    return;
  }

  // ‚úÖ lu√¥n d√πng ps (ƒë√£ normalize 0..3) cho m·ªçi th·ª© li√™n quan players
  const ps = players4(s);

  const seatName = (seat)=> (ps[seat]?.name || "(empty)");

  drawZone(rects.table, "TABLE", "", false);

  const selfId = client.selfId || FB?.uid || "";
  let mySeat = -1;
  for (let i=0;i<4;i++){
    if (ps[i] && ps[i].id === selfId){ mySeat = i; break; }
  }

  // ‚úÖ privacy: ch·ªâ ch·ªß hand m·ªõi ƒë∆∞·ª£c th·∫•y m·∫∑t tr∆∞·ªõc
  const canSeeFront = (card) => {
    if (!card) return false;

    // ngo√†i hand: theo faceUp b√¨nh th∆∞·ªùng
    if (card.zone !== ZONES.hand) return !!card.faceUp;

    // trong hand: ch·ªâ owner m·ªõi th·∫•y faceUp, ng∆∞·ªùi kh√°c lu√¥n th·∫•y back
    const ownerId = (card.ownerId ?? card.owner ?? null);
    return (ownerId && ownerId === selfId) ? !!card.faceUp : false;
  };

  const tintBySeat = (seat)=> {
    const p = ps[seat];
    return p ? (COLORS?.[p.color] ?? null) : null;
  };

  // ‚úÖ 4 ng∆∞·ªùi
  drawZone(rects.handTopLeft,     "Ng∆∞·ªùi ch∆°i 1", seatName(0), mySeat===0, tintBySeat(0));
  drawZone(rects.handBottomLeft,  "Ng∆∞·ªùi ch∆°i 2", seatName(1), mySeat===1, tintBySeat(1));
  drawZone(rects.handTopRight,    "Ng∆∞·ªùi ch∆°i 3", seatName(2), mySeat===2, tintBySeat(2));
  drawZone(rects.handBottomRight, "Ng∆∞·ªùi ch∆°i 4", seatName(3), mySeat===3, tintBySeat(3));

  drawZone(rects.deck, "DECK");
  drawZone(rects.discard, "DISCARD");

  const objs = listDrawableObjects(s) || [];
  const backUrlDefault = s.assets?.backUrl || "";

  for (const o of objs){
    if (!o) continue;

    const isSelected =
      client.selected &&
      client.selected.type === o.type &&
      client.selected.id === o.id;

    let wx = o.x, wy = o.y;
    if (client.dragging &&
        client.dragging.target?.type === o.type &&
        client.dragging.target?.id === o.id &&
        client.dragging.cur){
      wx = client.dragging.cur.x - (client.dragging.offset?.dx||0);
      wy = client.dragging.cur.y - (client.dragging.offset?.dy||0);
    }

    const sp = toScreen({x: wx, y: wy});

    if (o.type === "card"){
      const c = getCardById(s, o.id);
      if (!c) continue;

      // ‚úÖ t√¨m owner ch·ªâ b·∫±ng ps (kh√¥ng ƒë·ª•ng s.players)
      const oid = (c.ownerId || c.owner || "");
      let owner = null;
      for (let i=0;i<4;i++){
        const p = ps[i];
        if (p && p.id === oid){ owner = p; break; }
      }
      const accent = owner ? (COLORS?.[owner.color] ?? null) : null;

      const frontUrl =
        (c.frontUrl || "") ||
        (s.assets?.frontBase ? (s.assets.frontBase + c.id + ".png") : "");

      const showFront = canSeeFront(c);

      drawCardAtScreen(
        sp.x, sp.y,
        showFront,
        c.frontSeed,
        accent,
        isSelected,
        false,
        0,
        frontUrl,
        backUrlDefault
      );

    } else {
      const stack = getStackById(s, o.id);
      if (!stack) continue;

      const topId = getStackTopCardId(s, stack);
      const top = topId ? getCardById(s, topId) : null;

      const topOwnerId = (top?.ownerId || top?.owner || stack.owner || "");
      let owner = null;
      for (let i=0;i<4;i++){
        const p = ps[i];
        if (p && p.id === topOwnerId){ owner = p; break; }
      }
      const accent = owner ? (COLORS?.[owner.color] ?? null) : null;

      const count = (stack.cardIds?.length || 0);

      if (top){
        if (count > 1){
          ctx.save();
          ctx.globalAlpha = 0.22;
          for (let i=1; i<Math.min(4, count); i++){
            const dx = i * 2 * camera.scale;
            const dy = i * 2 * camera.scale;
            drawCardAtScreen(sp.x+dx, sp.y+dy, false, 0, null, false, false, 0, "", backUrlDefault);
          }
          ctx.restore();
        }

        const frontUrl =
          (top.frontUrl || "") ||
          (s.assets?.frontBase ? (s.assets.frontBase + topId + ".png") : "");

        const showFrontTop = canSeeFront(top);

        drawCardAtScreen(
          sp.x, sp.y,
          showFrontTop,
          top.frontSeed,
          accent,
          isSelected,
          true,
          count,
          frontUrl,
          backUrlDefault
        );
      } else {
        ctx.save();
        ctx.globalAlpha = 0.25;
        drawCardAtScreen(sp.x, sp.y, false, 0, null, isSelected, false, 0, "", backUrlDefault);
        ctx.restore();
      }
    }
  }

  requestAnimationFrame(draw);
  renderStatusBoard?.();
}
requestAnimationFrame(draw);


function drawCountBadge(ctx, x, y, w, h, count){
  if (count == null) return;
  if (count <= 1) return; // mu·ªën hi·ªán c·∫£ "1" th√¨ b·ªè d√≤ng n√†y

  const text = String(count);

  // style
  const padX = 6, padY = 2;
  const fontSize = 12;
  ctx.save();
  ctx.font = `${fontSize}px ui-sans-serif, system-ui, Arial`;
  const tw = Math.ceil(ctx.measureText(text).width);
  const bw = tw + padX*2;
  const bh = fontSize + padY*2;

  // v·ªã tr√≠: g√≥c tr√™n-ph·∫£i c·ªßa stack rect
  const bx = Math.round(x + w - bw - 4);
  const by = Math.round(y + 4);
  const r  = 6;

  // n·ªÅn (ƒëen m·ªù)
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(0,0,0,0.75)";
  roundRect(ctx, bx, by, bw, bh, r);
  ctx.fill();

  // vi·ªÅn
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 1;
  roundRect(ctx, bx+0.5, by+0.5, bw-1, bh-1, r);
  ctx.stroke();

  // ch·ªØ
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, bx + bw/2, by + bh/2 + 0.5);

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}
  
/* =========================================================
   Status Board (gi·ªØ logic b·∫°n ƒëang d√πng) - ch·ªâ s·ª≠a seat 4 ng∆∞·ªùi
========================================================= */
const STATUS = {
  el: document.getElementById("statusBoard"),
  body: document.getElementById("sbBody"),
  toggle: document.getElementById("sbToggle"),
  lastSig: "",
  bound: false,
  editing: false,
  _timer: null,
  collapsed: true,
};

function isHost(s){
  return (s?.hostId && client.selfId === s.hostId) || !!client.isHost;
}

function ensureStatsRow(s, playerId){
  s.ui = s.ui || {};
  s.ui.statHeaders = s.ui.statHeaders || ["ATK","DEF","HP","COIN"];
  s.ui.statsByPlayer = s.ui.statsByPlayer || {};
  if (!s.ui.statsByPlayer[playerId]) s.ui.statsByPlayer[playerId] = ["", "", "", ""];
  for (let i=0;i<4;i++){
    if (s.ui.statsByPlayer[playerId][i] == null) s.ui.statsByPlayer[playerId][i] = "";
  }
  return s.ui.statsByPlayer[playerId];
}

function initStatusBoardUI(){
  if (!STATUS.el || !STATUS.body || STATUS.bound) return;
  STATUS.bound = true;

  if (STATUS.toggle){
    const apply = ()=>{
      STATUS.el.classList.toggle("collapsed", STATUS.collapsed);
      STATUS.toggle.textContent = STATUS.collapsed ? "+" : "‚àí";
    };
    STATUS.toggle.addEventListener("click", ()=>{
      STATUS.collapsed = !STATUS.collapsed;
      apply();
    });
    apply();
  }

  STATUS.body.addEventListener("input", (e)=>{
    const inp = e.target.closest("input[data-kind]");
    if (!inp) return;

    const s = getState();
    if (!s) return;

    const host = isHost(s);
    const kind = inp.dataset.kind;

    if (kind === "header"){
      if (!host) return;
      const idx = Number(inp.dataset.idx) | 0;
      const value = (inp.value ?? "").toString().slice(0, 12);
      sendIntentDebounced({ type:"set_stat_header", idx, value });
    } else if (kind === "stat"){
      const pid = inp.dataset.pid;
      const idx = Number(inp.dataset.idx) | 0;
      const value = (inp.value ?? "").toString().slice(0, 12);
      sendIntentDebounced({ type:"set_stat", playerId: pid, idx, value });
    }
  });

  STATUS.body.addEventListener("focusin", (e)=>{
    if (e.target.closest("input[data-kind]")) STATUS.editing = true;
  });
  STATUS.body.addEventListener("focusout", (e)=>{
    if (e.target.closest("input[data-kind]")){
      setTimeout(()=>{
        const active = document.activeElement;
        STATUS.editing = !!(active && STATUS.body.contains(active) && active.matches("input[data-kind]"));
      }, 0);
    }
  });
}

function sendIntentDebounced(intent){
  clearTimeout(STATUS._timer);
  STATUS._timer = setTimeout(()=> sendIntent(intent), 120);
}

function renderStatusBoard(){
  initStatusBoardUI();

  const s = getState();
  if (!s || !STATUS.el || !STATUS.body) return;
  if (STATUS.editing) return;

  s.ui = s.ui || {};
  const headers = (s.ui.statHeaders || ["ATK","DEF","HP","COIN"]).slice(0,4);
  while (headers.length < 4) headers.push("");

  const host = isHost(s);

  let sig = `v=${s.version||0}|h=${headers.join(",")}|p=`;
  const players = (s.players || []);
  for (let i=0;i<players.length;i++){
    const p = players[i];
    if (!p) continue;
    const stats = ensureStatsRow(s, p.id);
    sig += `${p.id}:${p.name||""}:${p.color||""}:${stats.join("/")};`;
  }
  if (sig === STATUS.lastSig) return;
  STATUS.lastSig = sig;

  const headerHtml = headers.map((h, idx)=>{
    const ro = host ? "" : "readonly";
    return `
      <th style="padding:6px 6px; text-align:center;">
        <input ${ro}
          data-kind="header" data-idx="${idx}"
          value="${escapeHtml(h ?? "")}"
          style="
            width: 70px;
            text-align:center;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 8px;
            color: #fff;
            padding: 4px 6px;
            outline: none;
          "
        />
      </th>
    `;
  }).join("");

  const rows = players.map(p=>{
    if (!p) return "";
    const stats = ensureStatsRow(s, p.id);

    const tds = stats.slice(0,4).map((v, idx)=>{
      return `
        <td style="padding:6px 6px; text-align:center;">
          <input
            data-kind="stat"
            data-pid="${p.id}"
            data-idx="${idx}"
            value="${escapeHtml((v ?? "").toString())}"
            title="S·ª≠a t·ª± do"
            style="
              width: 70px;
              text-align:center;
              background: rgba(0,0,0,0.25);
              border: 1px solid rgba(255,255,255,0.18);
              border-radius: 8px;
              color: #fff;
              padding: 4px 6px;
              outline: none;
            "
          />
        </td>
      `;
    }).join("");

    return `
      <tr style="border-top: 1px solid rgba(255,255,255,0.10);">
        <td style="padding:6px 8px; white-space:nowrap;">
          <span style="
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:3px;
            background:${COLORS?.[p.color] ?? "rgba(255,255,255,.35)"};
            margin-right:6px;
          "></span>
          <span style="opacity:0.92; font-weight:600;">
            ${escapeHtml(p.name || "Player")}
          </span>
        </td>
        ${tds}
      </tr>
    `;
  }).join("");

  STATUS.body.innerHTML = `
    <table style="border-collapse:collapse;width:100%;">
      <thead>
        <tr>
          <th style="padding:6px 8px;text-align:left;opacity:0.85;">Player</th>
          ${headerHtml}
        </tr>
      </thead>
      <tbody>
        ${rows || ""}
      </tbody>
    </table>
  `;
}

/* =========================================================
   19) UI bindings (Firebase-only) - B·ªé modeSelect/local/ws
========================================================= */

// Apply deck images (host)
if (UI.applyDeckBtn){
  UI.applyDeckBtn.addEventListener("click", ()=>{
    if (!client.isHost) return toast("Host m·ªõi set deck images");
    sendIntent({ type:"setAssets", frontBase: UI.frontBaseInput?.value, backUrl: UI.backUrlInput?.value });
    toast("Applied deck images");
  });
}

// Create room (Firebase)
if (UI.createBtn){
  UI.createBtn.addEventListener("click", async ()=>{
    try{
      await createRoomAsHost_Firebase();
    }catch(e){
      console.error(e);
      toast("Create error: " + (e.message || e));
    }
  });
}

// Join room (Firebase)
if (UI.joinBtn){
  UI.joinBtn.addEventListener("click", async ()=>{
    try{
      await joinRoomAsClient_Firebase();
    }catch(e){
      console.error(e);
      toast("Join error: " + (e.message || e));
    }
  });
}

// Reset (host)
if (UI.resetBtn){
  UI.resetBtn.addEventListener("click", ()=>{
    if (!client.authoritative) return;
    if (!client.isHost) return toast("Ch·ªâ Host m·ªõi reset.");
    sendIntent({type:"reset"});
  });
}

// Copy link ph√≤ng (Firebase-only)
if (UI.copyLinkBtn){
  UI.copyLinkBtn.addEventListener("click", async ()=>{
    readInputs();
    const url = new URL(location.href);
    url.searchParams.set("room", client.roomCode);
    try{
      await navigator.clipboard.writeText(url.toString());
      toast("ƒê√£ copy link ph√≤ng.");
    }catch(e){
      toast("Copy failed (tr√¨nh duy·ªát ch·∫∑n).");
    }
  });
}

// collapse panels (+/-)
document.querySelectorAll(".collapse-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const panelId = btn.dataset.target;
    const panel = document.getElementById(panelId);
    if (!panel) return;
    const collapsed = panel.classList.toggle("collapsed");
    btn.textContent = collapsed ? "+" : "‚àí";
  });
});
/* =========================================================
   20) Auth UI buttons (login/register/anon/logout/leave)
   Firebase-only
========================================================= */

// ƒë·ª£i auth ready (tr√°nh case login xong UI ch∆∞a ƒë·ªïi)
function fbWaitAuthReady(){
  fbInitOnce();
  return new Promise((resolve)=>{
    const off = FB.auth.onAuthStateChanged((u)=>{
      try{ off(); }catch(e){}
      resolve(u || null);
    });
  });
}

// ƒë·∫£m b·∫£o profile AllUser/{uid} t·ªìn t·∫°i + c√≥ setCard
async function ensureUserProfile(uid, patch){
  fbInitOnce();
  const uref = FB.db.ref(`AllUser/${uid}`);
  const snap = await uref.get();
  if (!snap.exists()){
    await uref.set({
      username: patch.username || "Player",
      email: patch.email || null,
      createdAt: Date.now(),
      setCard: {},
      ...patch,
    });
  }else{
    const cur = snap.val() || {};
    const upd = {};
    if (patch.username && (cur.username||"") !== patch.username) upd.username = patch.username;
    if (patch.email && !cur.email) upd.email = patch.email;
    if (!cur.setCard) upd.setCard = {};
    if (Object.keys(upd).length) await uref.update(upd);
  }
}

// ƒë·ªìng b·ªô runtime FB.{user,uid,username} + nameInput
async function syncRuntimeFromAuth(){
  fbInitOnce();
  const u = FB.auth.currentUser;
  if (!u) return false;

  FB.user = u;
  FB.uid = u.uid;

  const snap = await FB.db.ref(`AllUser/${FB.uid}`).get();
  const prof = snap.val() || {};
  FB.username = (prof.username || "Player").toString().slice(0,18);

  if (UI.nameInput) UI.nameInput.value = FB.username;
  return true;
}

// auto route theo auth state
let _authGateInstalled = false;
function installAuthGateOnce(){
  if (_authGateInstalled) return;
  _authGateInstalled = true;

  fbInitOnce();
  FB.auth.onAuthStateChanged(async (u)=>{
    if (!u){
      // logged out
      try{ leaveRoom(); }catch(e){}
      goAuth();
      setNetBadge("OFFLINE");
      return;
    }

    // logged in
    try{
      await syncRuntimeFromAuth();
      goLobby();
      setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
    }catch(e){
      console.error(e);
      toast("Auth sync error: " + (e.message || e));
      goAuth();
    }
  });
}

async function registerUser(){
  fbInitOnce();

  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";
  const username = (document.getElementById("authUsername")?.value || "").trim().slice(0,18);

  if (!email || !password || !username){
    toast("Nh·∫≠p ƒë·∫ßy ƒë·ªß email / m·∫≠t kh·∫©u / t√™n");
    return;
  }

  const cred = await FB.auth.createUserWithEmailAndPassword(email, password);
  const user = cred.user;

  await ensureUserProfile(user.uid, { username, email });

  // sync runtime
  FB.user = user; FB.uid = user.uid; FB.username = username;
  if (UI.nameInput) UI.nameInput.value = username;

  toast("ƒêƒÉng k√Ω th√†nh c√¥ng");
  goLobby(); // fallback (authGate c≈©ng s·∫Ω ƒë∆∞a)
}

async function loginUser(){
  fbInitOnce();

  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";

  if (!email || !password){
    toast("Nh·∫≠p email v√† m·∫≠t kh·∫©u");
    return;
  }

  await FB.auth.signInWithEmailAndPassword(email, password);

  // ƒë·ª£i auth ready r·ªìi sync
  await fbWaitAuthReady();
  await syncRuntimeFromAuth();

  toast("ƒêƒÉng nh·∫≠p th√†nh c√¥ng");
  goLobby();
}

async function playAnon(){
  fbInitOnce();

  await FB.auth.signInAnonymously();
  await fbWaitAuthReady();

  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  const uname =
    ((document.getElementById("authUsername")?.value || "").trim().slice(0,18)) ||
    "Guest";

  FB.username = uname;

  await ensureUserProfile(FB.uid, { username: FB.username });

  if (UI.nameInput) UI.nameInput.value = FB.username;

  goLobby();
  setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
  toast("Ch∆°i th·ª≠: v√†o s·∫£nh ch·ªù");
}

const loginBtn = document.getElementById("loginBtn");
const registerBtn = document.getElementById("registerBtn");
const playAnonBtn = document.getElementById("playAnonBtn");
const logoutBtn = document.getElementById("logoutBtn");
const leaveMatchBtn = document.getElementById("leaveMatchBtn");

if (registerBtn){
  registerBtn.onclick = async ()=> {
    try{ await registerUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (loginBtn){
  loginBtn.onclick = async ()=> {
    try{ await loginUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (playAnonBtn){
  playAnonBtn.onclick = async ()=>{
    try{ await playAnon(); }catch(e){ console.error(e); toast("Anonymous error: " + (e.message || e)); }
  };
}
if (logoutBtn){
  logoutBtn.onclick = async ()=>{
    try{ leaveRoom(); }catch(e){}
    try{ if (FB?.auth?.currentUser) await FB.auth.signOut(); }catch(e){}
    goAuth();
    setNetBadge("OFFLINE");
    toast("ƒê√£ ƒëƒÉng xu·∫•t");
  };
}
if (leaveMatchBtn){
  leaveMatchBtn.onclick = ()=>{
    try{ leaveRoom(); }catch(e){}
    goLobby();
    toast("ƒê√£ r·ªùi ph√≤ng");
  };
}

/* =========================================================
   Lobby UI (gi·ªØ nguy√™n logic b·∫°n g·ª≠i)
========================================================= */
(function initLobbyTabs(){
  const root = document.getElementById("lobbyScreen");
  if(!root) return;

  const tabs = Array.from(root.querySelectorAll(".tab"));
  const navs = Array.from(root.querySelectorAll(".nav-item"));
  const iconNavs = Array.from(root.querySelectorAll(".icon-btn[data-tab]"));

  let prevTabId = tabs.find(t=>t.classList.contains("active"))?.id || (tabs[0]?.id || "");

  function showTab(tabId){
    // render active
    tabs.forEach(t => t.classList.toggle("active", t.id === tabId));
    navs.forEach(b => b.classList.toggle("active", b.dataset.tab === tabId));

    // ‚úÖ ch·ªâ start list ph√≤ng khi v√†o tabRoom l·∫ßn ƒë·∫ßu
    if (tabId === "tabRoom" && !window._roomListStarted){
      window._roomListStarted = true;
      startRoomListListener();
    }

    if (prevTabId === "tabRoom" && tabId !== "tabRoom") stopRoomListListener();

    prevTabId = tabId;
  }

  navs.forEach(btn => btn.addEventListener("click", ()=> showTab(btn.dataset.tab)));
  iconNavs.forEach(btn => btn.addEventListener("click", ()=> showTab(btn.dataset.tab)));

  navs.forEach(btn => {
    btn.addEventListener("click", ()=> showTab(btn.dataset.tab));
  });
  iconNavs.forEach(btn => {
    btn.addEventListener("click", ()=> showTab(btn.dataset.tab));
  });

  // mirror Inventory actions
  const openDeckBtn = document.getElementById("openDeckBtn");
  if(openDeckBtn){
    openDeckBtn.addEventListener("click", ()=> openDeckBtn.click());
  }

  const invApply = document.getElementById("invApplyDeckBtn");
  const applyDeckBtn = document.getElementById("applyDeckBtn");
  if(invApply && applyDeckBtn){
    invApply.addEventListener("click", ()=> applyDeckBtn.click());
  }

  // Net pill reflect netBadge
  const netBadge = document.getElementById("netBadge");
  const netPill = document.getElementById("netPill");
  const netTxt = document.getElementById("netTxt");
  const dot = document.getElementById("netDot");
  if(netBadge && netPill && netTxt){
    const sync = ()=>{
      const t = (netBadge.textContent || "").trim().toUpperCase();
      netTxt.textContent = t || "OFFLINE";
      const online = t && t !== "OFFLINE";
      netPill.classList.toggle("online", online);
      if(dot) dot.style.background = online ? "#42d392" : "#a64b4b";
    };
    sync();
    new MutationObserver(sync).observe(netBadge, { childList:true, subtree:true, characterData:true });
  }

  // Paste room code
  const pasteBtn = document.getElementById("pasteRoomBtn");
  const quickIn = document.getElementById("quickRoomSearch");
  const roomInput = document.getElementById("roomInput");
  const focusBtn = document.getElementById("focusRoomBtn");
  if(pasteBtn && quickIn){
    pasteBtn.addEventListener("click", async ()=>{
      try{
        const txt = await navigator.clipboard.readText();
        quickIn.value = (txt || "").trim();
      }catch(e){}
    });
  }
  if(focusBtn && quickIn && roomInput){
    focusBtn.addEventListener("click", ()=>{
      const v = (quickIn.value || "").trim();
      if(v) roomInput.value = v;
      showTab("tabRoom");
      roomInput.focus();
    });
  }

  const uiSfx = document.getElementById("uiSfx");
  const uiSfxTxt = document.getElementById("uiSfxTxt");
  if(uiSfx && uiSfxTxt){
    const render = ()=> uiSfxTxt.textContent = uiSfx.value + "%";
    uiSfx.addEventListener("input", render);
    render();
  }
})();

(function initLobbyDock(){
  const byId = (id)=> document.getElementById(id);

  const dockRoomBtn = byId("dockRoomBtn");
  const dockBrowserBtn = byId("dockBrowserBtn");
  const dockDeckBtn = byId("dockDeckBtn");

  const dockCopyBtn = byId("dockCopyBtn");
  const dockResetBtn = byId("dockResetBtn");
  const dockJoinBtn = byId("dockJoinBtn");

  const copyLinkBtn = byId("copyLinkBtn");
  const resetBtn = byId("resetBtn");
  const joinBtn = byId("joinBtn");
  const openDeckBtn = byId("openDeckBtn");

  function showTab(tabId){
    const root = byId("lobbyScreen");
    if(!root) return;
    root.querySelectorAll(".tab").forEach(t=> t.classList.toggle("active", t.id === tabId));
    root.querySelectorAll(".nav-item").forEach(b=> b.classList.toggle("active", b.dataset.tab === tabId));
  }

  dockRoomBtn?.addEventListener("click", ()=> showTab("tabRoom"));
  dockBrowserBtn?.addEventListener("click", ()=> showTab("tabRoomBrowser"));
  dockDeckBtn?.addEventListener("click", ()=> openDeckBtn?.click());
  
  dockCopyBtn?.addEventListener("click", ()=> copyLinkBtn?.click());
  dockResetBtn?.addEventListener("click", ()=> resetBtn?.click());
  dockJoinBtn?.addEventListener("click", ()=> joinBtn?.click());

  const hint = byId("dockHint");
  if(hint){
    const map = {
      tabRoom: "T·∫°o ph√≤ng ho·∫∑c nh·∫≠p m√£ ƒë·ªÉ v√†o ph√≤ng.",
      tabRoomBrowser: "Browser: l·ªçc theo tag/preset r·ªìi Join nhanh.",
      tabInventory: "T·ªß ƒë·ªì: preset deck / cosmetics.",
      tabCustomize: "T√πy ch·ªânh: theme / sound / fps.",
      tabShop: "C·ª≠a h√†ng: cosmetics (kh√¥ng ·∫£nh h∆∞·ªüng gameplay).",
      tabNotifications: "Th√¥ng b√°o: tips & system.",
    };
    document.querySelectorAll('#lobbyScreen .nav-item[data-tab]').forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const t = btn.dataset.tab;
        if(map[t]) hint.textContent = map[t];
      });
    });
  }
})();

/* =========================================================
   21) Deck modal binds
========================================================= */
if (DECKUI.openBtn){
  DECKUI.openBtn.onclick = async ()=>{
    try{
      await refreshSetList();
      openDeckModal();
    }catch(e){
      console.error(e);
      toast("Deck modal error: " + (e.message||e));
    }
  };
}
if (DECKUI.closeBtn) DECKUI.closeBtn.onclick = closeDeckModal;
if (DECKUI.newSetBtn) DECKUI.newSetBtn.onclick = createNewSet;
if (DECKUI.saveBtn) DECKUI.saveBtn.onclick = saveCurrentSet;
if (DECKUI.deleteSetBtn) DECKUI.deleteSetBtn.onclick = deleteCurrentSet;
if (DECKUI.loadSetBtn) DECKUI.loadSetBtn.onclick = loadSelectedSet;
if (DECKUI.addCardBtn) DECKUI.addCardBtn.onclick = ()=> {
  DECKUI.list.appendChild(makeCardTypeRow());
};

/* =========================================================
   22) Auto-fill URL params (Firebase-only)
========================================================= */
(function initFromQuery(){
  const u = new URL(location.href);
  const room = u.searchParams.get("room");
  if (room && UI.roomInput) UI.roomInput.value = room.toUpperCase();
})();

addEventListener("beforeunload", ()=>{ try{ leaveRoom(); }catch(e){} });

window.addEventListener("error", (e) => {
  toast("JS error: " + (e.message || "unknown"));
});
window.addEventListener("unhandledrejection", (e) => {
  toast("Promise error: " + ((e.reason && e.reason.message) || e.reason || "unknown"));
});

/* =========================================================
   23) Boot
========================================================= */
fbInitOnce();
installAuthGateOnce();

// n·∫øu ƒë√£ login t·ª´ tr∆∞·ªõc (session), t·ª± sync v√†o lobby
fbWaitAuthReady().then(async (u)=>{
  if (u){
    try{
      await syncRuntimeFromAuth();
      goLobby();
      setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
    }catch(e){
      console.error(e);
      goAuth();
      setNetBadge("OFFLINE");
    }
  }else{
    goAuth();
    setNetBadge("OFFLINE");
  }
});

</script>
</body>
</html>
