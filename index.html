<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Tabletop Card Sandbox (4P) — Canvas + Realtime</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33cc;
      --panelSolid:#121a33;
      --border:#2a3566;
      --text:#e9ecff;
      --muted:#9aa6d6;
      --accent:#7aa2ff;
      --danger:#ff6b8b;
      --ok:#49d17c;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      background:
        radial-gradient(1200px 800px at 20% 10%, #18224b 0%, transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #1c2f66 0%, transparent 55%),
        radial-gradient(700px 600px at 50% 85%, #12214b 0%, transparent 50%),
        var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    /* Layout */
    #app{
      position:relative;
      width:100%;
      height:100%;
    }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      top:12px; left:12px;
      display:flex;
      gap:12px;
      align-items:flex-start;
      z-index:10;
      pointer-events:auto; /* let canvas interactions through */
    }
    .panel{
      pointer-events:auto;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
      min-width: 280px;
    }
    .panel header{
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .panel header .title{
      font-weight:700;
      letter-spacing:.2px;
      font-size:13px;
      color:var(--text);
    }
    .panel header .badge{
      font-size:11px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:4px 8px;
      background: rgba(0,0,0,.12);
    }
    .panel .content{
      padding:12px;
    }

    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .col{display:flex; flex-direction:column; gap:8px;}
    label{font-size:12px; color:var(--muted);}
    input,button,select{
      font-family:inherit;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:10px 12px;
      outline:none;
    }
    input::placeholder{color:rgba(233,236,255,.45)}
    button{
      cursor:pointer;
      border:1px solid rgba(122,162,255,.35);
      background: linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.08));
    }
    button:hover{border-color: rgba(122,162,255,.6)}
    button.secondary{
      border-color: rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
    }
    button.danger{
      border-color: rgba(255,107,139,.45);
      background: rgba(255,107,139,.12);
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    /* Chat */
    #chatPanel{
      position:absolute;
      right:14px;
      bottom:14px;
      width:min(420px, 42vw);
      height:min(320px, 42vh);
      z-index:20;
      display:flex;
      flex-direction:column;
      pointer-events:auto;
      border-radius:14px;
      overflow:hidden;
      background: rgba(10,12,18,.55);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    
    #chatPanel.collapsed{
      height:44px !important;
    }
    
    #chatPanel header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px 8px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
    }
    
    #chatPanel .titleRow{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    
    #chatPanel .title{
      font-weight:800;
      letter-spacing:.08em;
      font-size:11px;
      opacity:.9;
    }
    
    #chatPanel .badge{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
    }
    
    #chatPanel .actions{
      display:flex;
      align-items:center;
      gap:6px;
    }
    
    .chatToggle{
      display:flex;
      gap:4px;
      padding:3px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .chatToggle button{
      border:0;
      background: transparent;
      color: rgba(233,236,255,.72);
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      cursor:pointer;
    }
    .chatToggle button.active{
      background: rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
    }
    
    #chatPanel .collapse-btn{
      width:30px; height:30px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.85);
      cursor:pointer;
    }
    #chatPanel .collapse-btn:hover{ background: rgba(255,255,255,.10); }
    
    #chatPanel .content{
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    
    #chatLog{
      flex:1;
      overflow:auto;
      padding:10px 10px 8px 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      scroll-behavior:smooth;
    }
    
    /* scrollbar subtle */
    #chatLog::-webkit-scrollbar{ width:10px; }
    #chatLog::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border:3px solid rgba(0,0,0,0);
      background-clip: padding-box;
      border-radius:999px;
    }
    
    /* Message row */
    .msg{
      display:flex;
      gap:8px;
      align-items:flex-start;
    }
    
    .msg .dot{
      width:10px; height:10px; border-radius:999px;
      margin-top:6px;
      flex:0 0 auto;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.18);
    }
    
    .msg .bubble{
      flex:1;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding:7px 9px;
      max-width:100%;
    }
    
    .msg .meta{
      display:flex;
      gap:8px;
      align-items:baseline;
      flex-wrap:wrap;
      margin-bottom:4px;
      font-size:11px;
      color: rgba(233,236,255,.62);
    }
    .msg .name{
      font-weight:700;
      color: rgba(255,255,255,.88);
    }
    .msg .time{
      opacity:.75;
      font-variant-numeric: tabular-nums;
    }
    
    .msg .text{
      font-size:13px;
      line-height:1.35;
      color: rgba(255,255,255,.92);
      white-space:pre-wrap;
      word-break:break-word;
    }
    
    /* Fade older messages a bit (LoL vibe) */
    .msg.age2 .bubble{ opacity:.92; }
    .msg.age3 .bubble{ opacity:.82; }
    .msg.age4 .bubble{ opacity:.70; }
    
    #chatForm{
      display:flex;
      gap:8px;
      padding:10px;
      border-top:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
    }
    
    #chatInput{
      flex:1;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:10px 12px;
      color: rgba(255,255,255,.92);
      outline:none;
    }
    #chatInput::placeholder{ color: rgba(233,236,255,.45); }
    
    #chatSend{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.9);
      padding:10px 14px;
      cursor:pointer;
    }
    #chatSend:hover{ background: rgba(255,255,255,.12); }
    
    /* Small */
    @media (max-width: 880px){
      #chatPanel{ width:min(360px, 60vw); height:min(280px, 40vh); }
    }


    /* Floating help */
    #help{
      position:absolute;
      left:12px;
      bottom:12px;
      z-index:10;
      width:min(520px, 56vw);
      pointer-events:auto;
    }
    #help .panel{pointer-events:auto}
    .kbd{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      padding: 2px 6px;
      margin: 0 2px;
      border-radius: 7px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      font-size: 11px;
      color: rgba(233,236,255,.85);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,.22);
    }

    /* Toast */
    #toast{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      top:14px;
      z-index:20;
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(233,236,255,.92);
      box-shadow: var(--shadow);
      display:none;
      pointer-events:none;
      backdrop-filter: blur(8px);
      font-size: 12px;
    }

    /* Small */
    @media (max-width: 880px){
      #help{display:none;}
      #chatPanel{ width:min(360px, 60vw); height:min(280px, 40vh); }
      .hud{flex-direction:column;}
    }

     #inspector{
      position:absolute;
      z-index:30;
      display:none;
      pointer-events:auto;
      width: 280px;
      max-width: min(320px, 40vw);
    }
    
    #inspector .panel{
      background: var(--panel);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }


    .panel.collapsed .content {
      display: none;
    }
    
    .panel.collapsed {
      min-height: unset;
    }
    
    .collapse-btn {
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.25);
      color: #e9ecff;
      line-height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .collapse-btn:hover {
      background: rgba(122,162,255,.25);
    }

    .modal{
      position:absolute; inset:0;
      background: rgba(0,0,0,.55);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .modal-card{
      width:min(860px, 92vw);
      max-height:min(86vh, 780px);
      overflow:auto;
    }
    .card-url-row{
      display:flex; gap:8px; align-items:center;
    }
    .card-url-row input{ flex:1; }


    /* Make HUD smaller + collapsible */
    .hud{ gap:10px; }
    .panel{ max-width: 360px; }
    
    /* Optional: minimize buttons row */
    .hud .panel header{ cursor:default; }
    
    .screen{ display:none; width:100%; height:100%; }
    .screen.active{ display:block; }
    #authScreen{align-items:flex-start; justify-content:center; }
    #lobbyScreen .hud{ position:relative; top:auto; left:auto; padding:12px; }
    #matchScreen{ position:relative; width:100%; height:100%; }

    #statsOverlay{
      position:absolute; inset:0;
      z-index:12;
      pointer-events:none; /* chỉ input bật pointer */
    }
    .statBox{
      position:absolute;
      pointer-events:auto;
      display:flex;
      gap:6px;
      align-items:center;
      padding:6px 8px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      font-size:12px;
    }
    .statBox .dot{
      width:10px;height:10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.12);
    }
    .statBox .name{
      max-width: 110px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      color: rgba(233,236,255,.9);
      font-weight:700;
    }
    .statBox input{
      width:52px;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.22);
      color: rgba(233,236,255,.95);
    }
    .statBox label{
      font-size:11px;
      color: rgba(233,236,255,.55);
      margin-right:2px;
    }

    /* Status board (LoL-ish compact) */
    #statusBoard{
      position:absolute;
      left:12px;
      top:12px;
      z-index:30;
      width: 360px;
      max-width: min(360px, 46vw);
      border-radius: 12px;
      overflow:hidden;
      pointer-events:auto;
    
      background: rgba(10,12,18,.55);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,.92);
      font-family: system-ui, sans-serif;
      font-size: 12px;
    }
    
    #statusBoard.collapsed{
      height: 40px;
    }
    
    #statusBoard header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,0));
    }
    
    #statusBoard .title{
      font-weight:800;
      letter-spacing:.06em;
      font-size:11px;
      opacity:.9;
      user-select:none;
    }
    
    #statusBoard .right{
      display:flex;
      align-items:center;
      gap:8px;
    }
    
    #statusBoard .hint{
      font-size:11px;
      opacity:.65;
      user-select:none;
    }
    
    #statusBoard .toggleBtn{
      width:28px;
      height:28px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      cursor:pointer;
    }
    #statusBoard .toggleBtn:hover{ background: rgba(255,255,255,.10); }
    
    #statusBoard .body{
      padding: 8px;
    }
    
    #statusBoard.collapsed .body{
      display:none;
    }
    
    #statusBoard table{
      width:100%;
      border-collapse:collapse;
    }
    
    #statusBoard th, #statusBoard td{
      padding: 6px 4px;
      border-top: 1px solid rgba(255,255,255,.08);
      text-align:center;
    }
    
    #statusBoard th:first-child,
    #statusBoard td:first-child{
      text-align:left;
      padding-left: 6px;
      width: 40%;
    }
    
    #statusBoard thead th{
      border-top:none;
      padding-top: 2px;
    }
    
    .sbName{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .sbDot{
      width:10px; height:10px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 0 3px rgba(0,0,0,.18);
      flex:0 0 auto;
    }
    .sbNameText{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:600;
      opacity:.92;
    }
    
    .sbInp{
      width: 64px;
      max-width: 64px;
      text-align:center;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 6px 6px;
      outline:none;
    }
    
    .sbHdr{
      font-weight:700;
      letter-spacing:.04em;
      font-size:11px;
    }
    
    .sbHdrInp{
      width: 64px;
      max-width: 64px;
      text-align:center;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      padding: 6px 6px;
      outline:none;
    }
    .sbHdrInp[readonly]{
      opacity:.75;
      cursor: default;
    }

  </style>
</head>
<body>
<!-- =========================
  SCREEN: AUTH (mặc định hiện)
========================= -->
<div id="authScreen" class="screen active">
  <!-- Đăng nhập / Đăng ký -->
  <div class="panel" id="authPanel" style="max-width:320px; margin:40px auto;">
    <header>
      <div class="title">ĐĂNG NHẬP</div>
    </header>
    <div class="content col">
      <input id="authEmail" placeholder="Email" />
      <input id="authPassword" type="password" placeholder="Mật khẩu" />
      <input id="authUsername" placeholder="Tên hiển thị (khi đăng ký)" />

      <div class="row">
        <button id="loginBtn">Đăng nhập</button>
        <button id="registerBtn" class="secondary">Đăng ký</button>
      </div>

      <div class="row">
        <button id="playAnonBtn" class="secondary" style="flex:1">Chơi thử (Anonymous)</button>
      </div>

      <div id="authStatus" style="font-size:12px;color:var(--muted)"></div>
    </div>
  </div>
</div>


<!-- =========================
  SCREEN: LOBBY (ẩn ban đầu)
  Dùng lại roomPanel làm "Sảnh chờ"
  (Không đổi id roomPanel để JS/CSS khỏi vỡ)
========================= -->
<div id="lobbyScreen" class="screen">
  <!-- GIỮ NGUYÊN deckModal ở ngoài screen cũng được,
       nhưng để lobby vẫn ok; mình để deckModal ngoài cùng phía dưới -->
  <div class="hud">
    <div class="panel collapsible" id="roomPanel">
      <header>
        <div class="title">PHÒNG CHƠI</div>
        <div class="row" style="gap:8px">
          <div class="badge" id="netBadge">OFFLINE</div>
        </div>
        <button class="collapse-btn" data-target="roomPanel">−</button>
      </header>

      <button id="openDeckBtn" class="secondary">Deck / SetCard</button>

      <div class="content col">
        <div class="row">
          <div class="content col" style="flex:1; min-width:220px">
            <label>Front folder (host)</label>
            <input id="frontBaseInput" class="mono" placeholder="VD: ./cards/" />
          </div>
          <div class="col" style="flex:1; min-width:220px">
            <label>Back image URL</label>
            <input id="backUrlInput" class="mono" placeholder="VD: ./cards/BACK.png" />
          </div>
          <button id="applyDeckBtn" class="secondary">Apply deck images (Host)</button>
        </div>

        <div class="col">
          <div class="row">
            <div class="col" style="flex:1; min-width:150px">
              <label>Tên hiển thị</label>
              <input id="nameInput" placeholder="VD: HIC / Player" maxlength="18" />
            </div>
            <div class="col" style="min-width:120px">
              <label>Chế độ</label>
              <select id="modeSelect">
                <option value="firebase">Firebase RTDB</option>
                <option value="local">Local (4 tab)</option>
                <option value="ws">WebSocket</option>
              </select>
            </div>
          </div>

          <div id="wsRow" class="row" style="display:none">
            <div class="col" style="flex:1; min-width:200px">
              <label>WebSocket URL</label>
              <input id="wsUrlInput" class="mono" placeholder="ws://localhost:8080" />
            </div>
          </div>

          <div class="row">
            <div class="col" style="flex:1; min-width:160px">
              <label>Mã phòng</label>
              <input id="roomInput" class="mono" placeholder="Tự tạo / nhập" />
            </div>
            <button id="createBtn">Tạo phòng (Host)</button>
            <button id="joinBtn" class="secondary">Vào phòng</button>
          </div>

          <div class="row">
            <button id="copyLinkBtn" class="secondary">Copy link</button>
            <button id="resetBtn" class="danger">Reset bàn (Host)</button>
            <button id="logoutBtn" class="danger" style="margin-left:auto">Đăng xuất</button>
          </div>

          <div class="hint">
            - Local mode: mở 4 tab, cùng mã phòng để test 4 người.<br/>
            - Server authoritative: Host giữ state, client chỉ gửi intent.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


<!-- =========================
  SCREEN: MATCH (ẩn ban đầu)
  Giữ nguyên #app và mọi id bên trong
========================= -->
<div id="matchScreen" class="screen">
  <div id="app">
    <canvas id="c"></canvas>
    <div id="statsOverlay"></div>
    <div id="toast"></div>

    <div class="hud">
      <!-- Trạng thái -->
      <div class="panel collapsible" id="sttPanel">
        <header>
          <div class="title">TRẠNG THÁI</div>
          <div class="badge" id="roomBadge">—</div>
          <button class="collapse-btn" data-target="sttPanel">−</button>
        </header>
        <div class="content col">
          <div class="row" style="justify-content:space-between">
            <div class="col" style="gap:4px">
              <div style="font-size:12px; color:var(--muted)">Bạn là</div>
              <div id="meLine" style="font-weight:700">—</div>
            </div>
            <div class="col" style="gap:4px; align-items:flex-end">
              <div style="font-size:12px; color:var(--muted)">Host</div>
              <div id="hostLine" style="font-weight:700">—</div>
            </div>
          </div>

          <div class="row" style="justify-content:space-between">
            <div class="col" style="gap:6px">
              <div style="font-size:12px; color:var(--muted)">Người chơi (tối đa 6)</div>
              <div id="playersLine" style="font-size:13px; line-height:1.4">—</div>
            </div>
          </div>

          <!-- ===== SETUP / WAITING ROOM (NEW) ===== -->
          <div id="setupBox" class="col" style="gap:8px; margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,.08)">
            <div style="font-size:12px; color:var(--muted); font-weight:700;">PHÒNG CHỜ / SETUP</div>
          
            <div id="setupPhaseLine" class="hint" style="opacity:.95">
              Đang chờ host...
            </div>
          
            <!-- Host-only controls -->
            <div id="hostSetupControls" class="col" style="gap:8px; display:none">
              <label>Host: chọn setCard để chơi</label>
              <select id="hostSetSelect" style="width:100%"></select>
          
              <div class="row">
                <button id="hostRefreshSetsBtn" class="secondary" style="flex:1">Refresh set</button>
                <button id="hostLoadDeckBtn" class="secondary" style="flex:1">Load deck</button>
              </div>
          
              <button id="startGameBtn" style="width:100%">Bắt đầu chơi</button>
            </div>
          </div>
          <!-- ===== /SETUP ===== -->
          
          <div class="row">
            <button id="leaveMatchBtn" class="danger" style="flex:1">Rời phòng</button>
          </div>

          <div class="hint">
            Privacy: bài trong <b>hand</b> của người khác chỉ hiện mặt sau với bạn.
          </div>
        </div>
      </div>
    </div>

    <!-- Bảng score -->
    <div id="statusBoard" class="collapsed">
      <header>
        <div class="title">Bảng điểm</div>
        <div class="right">
          <div class="hint" id="sbHint">—</div>
          <button class="toggleBtn" id="sbToggle" type="button">+</button>
        </div>
      </header>
      <div class="body" id="sbBody"></div>
    </div>


    
    <!-- Chat -->
    <div id="chatPanel" class="collapsible">
      <header>
        <div class="titleRow">
          <div class="title">CHAT</div>
          <div class="badge" id="chatBadge">0</div>
        </div>
    
        <div class="actions">
          <div class="chatToggle" id="chatToggle">
            <button type="button" data-mode="all" class="active">ALL</button>
            <button type="button" data-mode="team">TEAM</button>
          </div>
          <button class="collapse-btn" data-target="chatPanel" type="button">−</button>
        </div>
      </header>
    
      <div class="content">
        <div id="chatLog"></div>
        <form id="chatForm" autocomplete="off">
          <input id="chatInput" placeholder="Enter để chat..." />
          <button id="chatSend" type="submit">Send</button>
        </form>
      </div>
    </div>


    <!-- Inspector -->
    <div id="inspector">
      <div class="panel" style="height:100%; display:flex; flex-direction:column;">
        <header>
          <div class="title">CARD INSPECTOR</div>
          <div class="badge" id="insBadge">—</div>
        </header>

        <div class="content" style="display:flex; flex-direction:column; gap:10px; height:100%;">
          <div id="insPreview" style="
            flex:1;
            border:1px solid rgba(255,255,255,.12);
            border-radius: 14px;
            background: rgba(0,0,0,.18);
            display:flex; align-items:center; justify-content:center;
            overflow:hidden;
          ">
            <div style="color:rgba(233,236,255,.55); font-size:12px">Chọn 1 lá bài...</div>
          </div>

          <div class="row" style="justify-content:space-between">
            <button id="btnFlip" class="secondary" style="flex:1">Flip</button>
            <button id="btnDiscard" class="danger" style="flex:1">Discard</button>
          </div>
          <div class="row" style="justify-content:space-between">
            <button id="btnUnstack" class="secondary" style="flex:1">Unstack</button>
            <button id="btnShuffle" class="secondary" style="flex:1">Shuffle</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Help -->
    <div class="panel collapsible" id="help">
      <div class="panel">
        <header>
          <div class="title">PHÍM TẮT / TƯƠNG TÁC</div><div class="badge">Canvas</div>
          <button class="collapse-btn" data-target="help">−</button>
        </header>
        <div class="content hint">
          <div>
            <span class="kbd">Kéo thả</span> chuột để di chuyển bài (table / hand).<br/>
            <span class="kbd">D</span> rút 1 lá từ Deck về Hand của bạn (đứng gần Deck hoặc chọn Deck).<br/>
            <span class="kbd">F</span> lật lá / chồng (stack).<br/>
            <span class="kbd">S</span> trộn chồng (deck/stack).<br/>
            <span class="kbd">U</span> tách 1 lá ra khỏi chồng (lấy top).<br/>
            <span class="kbd">G</span> gom chồng: thả 1 lá lên lá khác (auto), hoặc nhấn G khi đang kéo để ép gom.<br/>
            <span class="kbd">Click</span> chọn lá/chồng. <span class="kbd">Esc</span> bỏ chọn.
          </div>
        </div>
      </div>
    </div>

  </div>
</div>


<!-- =========================
  POPUP: Deck / SetCard (giữ nguyên)
========================= -->
<div id="deckModal" class="modal" style="display:none;">
  <div class="modal-card panel">
    <header style="display:flex;align-items:center;justify-content:space-between;gap:10px">
      <div class="title">DECK / SET CARD</div>
      <button id="closeDeckBtn" class="collapse-btn">×</button>
    </header>

    <div class="content col" style="gap:10px">
      <div class="row" style="justify-content:space-between">
        <div class="badge" id="deckUserBadge">—</div>
        <button id="newSetBtn" class="secondary">+ Tạo set mới</button>
      </div>

      <div class="col" style="gap:6px">
        <label>Set đã lưu</label>
        <div class="row">
          <select id="setSelect" style="flex:1; min-width:220px"></select>
          <button id="loadSetBtn" class="secondary">Load</button>
          <button id="deleteSetBtn" class="danger">Xóa</button>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);width:100%">

      <div class="col" style="gap:6px">
        <label>Tên set</label>
        <input id="setNameInput" placeholder="VD: Poker / Game A" />
      </div>

      <div class="col" style="gap:6px">
        <label>Back URL (mặt sau — 1 link)</label>
        <input id="setBackUrlInput" class="mono" placeholder="https://.../back.png" />
      </div>

      <div class="row" style="justify-content:space-between">
        <div class="hint">Front URL (mặt trước). Bấm <b>+</b> để thêm lá.</div>
        <button id="addCardUrlBtn" class="secondary">+ Card</button>
      </div>

      <div id="cardUrlList" class="col" style="gap:8px; max-height:240px; overflow:auto; padding-right:6px"></div>

      <div class="row" style="justify-content:flex-end">
        <button id="saveSetBtn">Lưu set</button>
        <button id="loadSetToRoomBtn" class="secondary">Host: Load set vào Room</button>
      </div>

      <div class="hint" style="opacity:.9">
        - Khi host load set vào room: <b>D</b> sẽ rút ngẫu nhiên 1 lá từ set.<br/>
        - Người khác vào room sẽ tự dùng deck của host.
      </div>
    </div>
  </div>
</div>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-database-compat.js"></script> 
<script>
/* =========================================================
   0) Utils / Core helpers
========================================================= */
"use strict";

const clamp   = (v, a, b) => Math.max(a, Math.min(b, v));
const randInt = (a, b) => (Math.random() * (b - a + 1) + a) | 0;
const now     = () => Date.now();
const uid     = () => (crypto?.randomUUID ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + "_" + Date.now()));
const deepClone = (obj) => (typeof structuredClone === "function" ? structuredClone(obj) : JSON.parse(JSON.stringify(obj)));

function escapeHtml(str){
  return (str ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function toast(text, ms=1600){
  const el = document.getElementById("toast");
  if (!el) { console.log("[toast]", text); return; } // <-- chống crash
  el.textContent = text;
  el.style.display = "block";
  clearTimeout(el._t);
  el._t = setTimeout(()=> el.style.display="none", ms);
}

/* =========================================================
   1) Constants / Layout
========================================================= */
const COLORS = {
  red:   "#ff5c7a",
  blue:  "#5aa7ff",
  green: "#4ad37d",
  yellow:"#ffd166",
};
const COLOR_ORDER = ["red","blue","green","yellow"];

const ZONES = {
  table: "table",
  hand: "hand",
  deck: "deck",
  discard: "discard",
};

const CARD = { w: 86, h: 122, r: 12 };

const TABLE = {
  w: 1700,
  h: 900,
  margin: 40,
  handH: 150,
  sideW: 220,
  rightW: 260,
};

function zoneRects(){
  const m = TABLE.margin;
  const { w, h, handH, sideW, rightW } = TABLE;

  const tableRect = {
    x: m + sideW,
    y: m + handH,
    w: w - 2*m - sideW - rightW,
    h: h - 2*m - 2*handH
  };

  return {
    table: tableRect,

    handTopLeft: {
      x: tableRect.x,
      y: m,
      w: tableRect.w / 2,
      h: handH
    },
    handTopRight: {
      x: tableRect.x + tableRect.w / 2,
      y: m,
      w: tableRect.w / 2,
      h: handH
    },

    handBottomLeft: {
      x: tableRect.x,
      y: tableRect.y + tableRect.h,
      w: tableRect.w / 2,
      h: handH
    },
    handBottomRight: {
      x: tableRect.x + tableRect.w / 2,
      y: tableRect.y + tableRect.h,
      w: tableRect.w / 2,
      h: handH
    },

    handRightTop: {
      x: w - m - rightW,
      y: tableRect.y,
      w: rightW,
      h: tableRect.h / 2
    },
    handRightBottom: {
      x: w - m - rightW,
      y: tableRect.y + tableRect.h / 2,
      w: rightW,
      h: tableRect.h / 2
    },

    deck: {
      x: m,
      y: tableRect.y,
      w: sideW,
      h: tableRect.h / 2
    },
    discard: {
      x: m,
      y: tableRect.y + tableRect.h / 2,
      w: sideW,
      h: tableRect.h / 2
    }
  };
}

/* =========================================================
   2) Canvas / Camera
========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

const camera = { scale: 1, offsetX: 0, offsetY: 0 };

function updateCamera(){
  const pad = 18;
  const sx = (innerWidth - pad*2) / TABLE.w;
  const sy = (innerHeight - pad*2) / TABLE.h;
  camera.scale = Math.min(sx, sy);
  camera.offsetX = (innerWidth - TABLE.w * camera.scale) / 2;
  camera.offsetY = (innerHeight - TABLE.h * camera.scale) / 2;
}
updateCamera();
addEventListener("resize", updateCamera);

function toScreen(p){
  return { x: camera.offsetX + p.x * camera.scale, y: camera.offsetY + p.y * camera.scale };
}
function toWorld(p){
  return { x: (p.x - camera.offsetX) / camera.scale, y: (p.y - camera.offsetY) / camera.scale };
}

/* =========================================================
   3) UI refs (giữ nguyên id của bạn)
========================================================= */
const UI = {
  modeSelect: document.getElementById("modeSelect"),
  wsRow: document.getElementById("wsRow"),
  wsUrlInput: document.getElementById("wsUrlInput"),
  nameInput: document.getElementById("nameInput"),
  roomInput: document.getElementById("roomInput"),
  createBtn: document.getElementById("createBtn"),
  joinBtn: document.getElementById("joinBtn"),
  copyLinkBtn: document.getElementById("copyLinkBtn"),
  resetBtn: document.getElementById("resetBtn"),
  netBadge: document.getElementById("netBadge"),
  roomBadge: document.getElementById("roomBadge"),
  meLine: document.getElementById("meLine"),
  hostLine: document.getElementById("hostLine"),
  playersLine: document.getElementById("playersLine"),
  chatBadge: document.getElementById("chatBadge"),
  chatLog: document.getElementById("chatLog"),
  chatForm: document.getElementById("chatForm"),
  chatInput: document.getElementById("chatInput"),
  frontBaseInput: document.getElementById("frontBaseInput"),
  backUrlInput: document.getElementById("backUrlInput"),
  applyDeckBtn: document.getElementById("applyDeckBtn"),
  setupBox: document.getElementById("setupBox"),
  setupPhaseLine: document.getElementById("setupPhaseLine"),
  hostSetupControls: document.getElementById("hostSetupControls"),
  hostSetSelect: document.getElementById("hostSetSelect"),
  hostRefreshSetsBtn: document.getElementById("hostRefreshSetsBtn"),
  hostLoadDeckBtn: document.getElementById("hostLoadDeckBtn"),
  startGameBtn: document.getElementById("startGameBtn"),

};

  

/* =========================================================
   4) Screens Router
   - Bạn đang dùng lẫn: screenAuth/screenLobby/screenMatch và authScreen/lobbyScreen/matchScreen
   - FIX: Tự detect cái nào tồn tại
========================================================= */
const SCREENS = {
  auth:  document.getElementById("authScreen"),
  lobby: document.getElementById("lobbyScreen"),
  match: document.getElementById("matchScreen"),
};

function setScreen(name){
  for (const k in SCREENS){
    const el = SCREENS[k];
    if (el) el.classList.remove("active");
  }
  if (SCREENS[name]) SCREENS[name].classList.add("active");
}

function goAuth(){ setScreen("auth"); }
function goLobby(){ setScreen("lobby"); }
function goMatch(){ setScreen("match"); try{ resize(); updateCamera(); }catch(e){} }

goAuth();


let _hostSetsCache = {}; // {setId: data}

async function refreshHostSetSelect(){
  await fbEnsureAuth();
  if (!UI.hostSetSelect) return;

  const snap = await FB.db.ref(`AllUser/${FB.uid}/setCard`).get();
  _hostSetsCache = snap.val() || {};

  UI.hostSetSelect.innerHTML = "";
  const ids = Object.keys(_hostSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(chưa có setCard)";
    UI.hostSetSelect.appendChild(op);
    return;
  }

  for (const id of ids){
    const set = _hostSetsCache[id] || {};
    const cnt = Object.keys(set.cards || {}).length;
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${set.name || id} (${cnt} loại)`;
    UI.hostSetSelect.appendChild(op);
  }
}

async function hostLoadSelectedSetToRoom_FromSaved(){
  if (!client.isHost) return toast("Chỉ host mới load deck");
  if (!(client.transport instanceof FirebaseTransport)) return toast("Chỉ dùng được trong Firebase mode");
  await fbEnsureAuth();

  const setId = UI.hostSetSelect?.value || "";
  if (!setId) return toast("Chưa chọn set");

  // nếu cache trống thì refresh
  if (!_hostSetsCache[setId]) await refreshHostSetSelect();
  const data = _hostSetsCache[setId];
  if (!data) return toast("Set không tồn tại");

  const types = Object.values(data.cards || {}).map(t=>({
    name: t?.name || "",
    frontUrl: (t?.frontUrl || "").trim(),
    count: Math.max(1, parseInt(t?.count, 10) || 1),
  })).filter(t => t.frontUrl && t.count > 0);

  const total = types.reduce((s,t)=>s + (t.count|0), 0);
  if (total <= 0) return toast("Set rỗng (chưa có URL)");

  const backUrl = (data.backUrl || "").trim();

  // update room meta để người khác / host refresh vẫn biết deckSource
  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.child("meta").update({
    deckSource: { uid: FB.uid, setId },
    deckBackUrl: backUrl,
    deckTotal: total
  });

  // build deck vào host state + write state
  if (client.host && client.host.state){
    client.host.state.assets = client.host.state.assets || { frontBase:"", backUrl:"" };
    client.host.state.assets.backUrl = backUrl;

    buildPhysicalDeckFromTypes(client.host.state, types, "stack_deck");
    client.host.bumpVersion?.();
    await client.transport.writeState(client.host.state);
  }

  toast(`Loaded deck: ${types.length} loại / ${total} lá`);
}

if (UI.hostRefreshSetsBtn){
  UI.hostRefreshSetsBtn.onclick = async ()=>{
    try{ await refreshHostSetSelect(); toast("Đã refresh set"); }
    catch(e){ console.error(e); toast(e.message || e); }
  };
}

if (UI.hostLoadDeckBtn){
  UI.hostLoadDeckBtn.onclick = async ()=>{
    try{ await hostLoadSelectedSetToRoom_FromSaved(); }
    catch(e){ console.error(e); toast(e.message || e); }
  };
}

if (UI.startGameBtn){
  UI.startGameBtn.onclick = ()=>{
    if (!client.isHost) return toast("Chỉ host mới bắt đầu");
    sendIntent({ type:"startGame" });
    toast("Bắt đầu!");
  };
}

  
/* =========================================================
   5) Inspector (card inspector popup)
========================================================= */
const INS = {
  badge: document.getElementById("insBadge"),
  preview: document.getElementById("insPreview"),
  btnFlip: document.getElementById("btnFlip"),
  btnDiscard: document.getElementById("btnDiscard"),
  btnUnstack: document.getElementById("btnUnstack"),
  btnShuffle: document.getElementById("btnShuffle"),
};

function getWorldPosOfTarget(st, target){
  if (!st || !target) return null;
  if (target.type === "card"){
    const c = st.cards?.[target.id];
    if (!c) return null;
    return {x: c.x, y: c.y};
  } else {
    const s = st.stacks?.[target.id];
    if (!s) return null;
    return {x: s.x, y: s.y};
  }
}

function positionInspectorNearTarget(){
  const st = getState();
  const sel = client.selected;
  if (!st || !sel) return;

  const wp = getWorldPosOfTarget(st, sel);
  if (!wp) return;

  const sp = toScreen(wp);
  const ins = document.getElementById("inspector");
  if (!ins) return;

  const pad = 10;
  const offsetX = 20;
  const offsetY = -20;

  const rect = ins.getBoundingClientRect();
  let left = sp.x + offsetX;
  let top  = sp.y + offsetY;

  left = clamp(left, pad, innerWidth - rect.width - pad);
  top  = clamp(top,  pad, innerHeight - rect.height - pad);

  ins.style.left = left + "px";
  ins.style.top  = top + "px";
}

function showInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "block";
  updateInspector();
  requestAnimationFrame(positionInspectorNearTarget);
}
function hideInspectorPopup(){
  const ins = document.getElementById("inspector");
  if (!ins) return;
  ins.style.display = "none";
}

function updateInspector(){
  const st = getState();
  const sel = client.selected;

  if (!INS.badge || !INS.preview) return;

  if (!st || !sel){
    INS.badge.textContent = "—";
    INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Chọn 1 lá bài...</div>`;
    return;
  }

  // ===== DECK (SPECIAL CASE) =====
  if (sel.type === "stack" && sel.id === "stack_deck"){
    const count = st.stacks?.stack_deck?.cardIds?.length || 0;
    INS.badge.textContent = "DECK";
    INS.preview.innerHTML = `
      <div style="text-align:center;font-size:13px">
        <div>${count} cards</div>
        <div style="opacity:.6;margin-top:6px">Press D to draw</div>
        <div style="opacity:.4;margin-top:4px">Press S to shuffle</div>
      </div>
    `;
    return;
  }

  // ===== CARD =====
  if (sel.type === "card"){
    const c = st.cards?.[sel.id];
    INS.badge.textContent = sel.id + (c?.lockedBy ? " (LOCK)" : "");

    // FIX: ưu tiên frontUrl (setCard), nếu không có thì mới dùng frontBase+id.png
    const frontUrl = c?.frontUrl
      ? c.frontUrl
      : (st.assets?.frontBase ? (st.assets.frontBase + sel.id + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c?.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">
          No image set. Host hãy set Back URL hoặc load setCard.
        </div>`;
    return;
  }

  // ===== STACK (NORMAL) =====
  if (sel.type === "stack"){
    const s = st.stacks?.[sel.id];
    const topId = s?.cardIds?.[0];
    INS.badge.textContent = `${sel.id} (${s?.cardIds?.length || 0})`;

    if (!topId){
      INS.preview.innerHTML = `<div style="color:rgba(233,236,255,.55); font-size:12px">Empty stack</div>`;
      return;
    }

    const c = st.cards?.[topId];
    const frontUrl = c?.frontUrl
      ? c.frontUrl
      : (st.assets?.frontBase ? (st.assets.frontBase + topId + ".png") : "");
    const backUrl  = st.assets?.backUrl || "";
    const url = (c?.faceUp && frontUrl) ? frontUrl : backUrl;

    INS.preview.innerHTML = url
      ? `<img src="${url}" style="width:100%; height:100%; object-fit:contain;">`
      : `<div style="padding:12px; font-size:12px; color:rgba(233,236,255,.6)">No image set.</div>`;
  }
}

/* =========================================================
   6) Networking Abstraction (Local / WS / Firebase)
========================================================= */
class NetTransport {
  constructor(){ this.onMessage = ()=>{}; this.onStatus = ()=>{}; }
  send(_msg) {}
  close() {}
}

class LocalBroadcastTransport extends NetTransport {
  constructor(roomCode, selfId){
    super();
    this.roomCode = roomCode;
    this.selfId = selfId;
    this.bc = new BroadcastChannel("ttc_" + roomCode);
    this.bc.onmessage = (ev) => {
      const msg = ev.data;
      if (!msg || msg._from === this.selfId) return;
      this.onMessage(msg);
    };
    this.onStatus({connected:true, mode:"local"});
  }
  send(msg){
    this.bc.postMessage({...msg, _from:this.selfId});
  }
  close(){
    this.onStatus({connected:false, mode:"local"});
    this.bc.close();
  }
}

class LocalStorageTransport extends NetTransport {
  constructor(roomCode, selfId){
    super();
    this.roomCode = roomCode;
    this.selfId = selfId;
    this.key = "ttc_ls_" + roomCode;

    this._onStorage = (ev) => {
      if (ev.key !== this.key || !ev.newValue) return;
      try{
        const msg = JSON.parse(ev.newValue);
        if (!msg || msg._from === this.selfId) return;
        this.onMessage(msg);
      }catch(e){}
    };
    window.addEventListener("storage", this._onStorage);
    this.onStatus({connected:true, mode:"local"});
  }

  send(msg){
    try{
      const payload = JSON.stringify({...msg, _from:this.selfId, _t: Date.now()});
      localStorage.setItem(this.key, payload);
    }catch(e){}
  }

  close(){
    window.removeEventListener("storage", this._onStorage);
    this.onStatus({connected:false, mode:"local"});
  }
}

class WebSocketTransport extends NetTransport {
  constructor(url){
    super();
    this.ws = new WebSocket(url);
    this.ws.onopen = () => this.onStatus({connected:true, mode:"ws"});
    this.ws.onclose = () => this.onStatus({connected:false, mode:"ws"});
    this.ws.onerror = () => this.onStatus({connected:false, mode:"ws"});
    this.ws.onmessage = (ev) => {
      try{
        const msg = JSON.parse(ev.data);
        this.onMessage(msg);
      }catch(e){}
    };
  }
  send(msg){
    if (this.ws.readyState === 1) this.ws.send(JSON.stringify(msg));
  }
  close(){ try{ this.ws.close(); }catch(e){} }
}

/* =========================================================
   7) Game State / Redaction (Authoritative on Host)
========================================================= */
function makeFreshTableState(roomCode, hostId){
  const st = {
    roomCode,
    hostId,
    players: [],
    cards: {},
    stacks: {},
    chat: [],
    version: 1,
    assets: { frontBase:"", backUrl:"" },
    _deckPool: [], // FIX: bạn dùng _deckPool trong draw => phải có sẵn
    game: { phase: "setup" },
  };

  const rects = zoneRects();
  const deckX = rects.deck.x + rects.deck.w/2;
  const deckY = rects.deck.y + rects.deck.h/2;

  const deckStackId = "stack_deck";
  st.stacks[deckStackId] = { id: deckStackId, zone: ZONES.deck, owner: null, x: deckX, y: deckY, cardIds: [] };

  for(let i=1;i<=40;i++){
    const id = "C" + String(i).padStart(2,"0");
    st.cards[id] = {
      id,
      frontSeed: i,
      faceUp: false,
      x: deckX,
      y: deckY,
      zone: ZONES.deck,
      owner: null,
      ownerId: null,
      stackId: deckStackId,
      order: i,
    };
    st.stacks[deckStackId].cardIds.push(id);
  }
  return st;
}

function buildPhysicalDeckFromTypes(st, types, deckStackId="stack_deck"){
  // types: [{name, frontUrl, count}]
  const deck = st.stacks[deckStackId];
  if (!deck) throw new Error("Missing stack_deck");

  // Xóa các card cũ thuộc deckStack (tùy bạn: hoặc giữ cards khác)
  // Ở đây mình làm "rebuild sạch": xóa toàn bộ cards và stacks thường,
  // giữ discard stack + players + assets.
  const rects = zoneRects();
  const deckX = rects.deck.x + rects.deck.w/2;
  const deckY = rects.deck.y + rects.deck.h/2;

  // reset cards + reset stacks (giữ discard + deck)
  const keepDeck = st.stacks["stack_deck"];

  st.cards = {};
  st.stacks = {
    stack_deck: {...keepDeck, x:deckX, y:deckY, zone:ZONES.deck, owner:null, cardIds:[]},
  };

  // build deck cards
  let running = 1;
  for (const t of types){
    const frontUrl = (t.frontUrl||"").trim();
    const count = Math.max(1, parseInt(t.count,10)||1);
    const name = (t.name||"").trim();

    if (!frontUrl) continue;

    for (let k=0; k<count; k++){
      const id = "D" + String(running).padStart(4,"0") + "_" + uid().slice(0,6);
      st.cards[id] = {
        id,
        faceUp: false,
        x: deckX, y: deckY,
        zone: ZONES.deck,
        owner: null,
        stackId: "stack_deck",
        order: running,
        frontSeed: running,       // fallback text
        frontUrl: frontUrl,       // << IMPORTANT
        typeName: name            // optional
      };
      st.stacks.stack_deck.cardIds.push(id);
      running++;
    }
  }

  // Nếu muốn: auto shuffle ngay khi build
  for(let i=st.stacks.stack_deck.cardIds.length-1;i>0;i--){
    const j = randInt(0,i);
    const a = st.stacks.stack_deck.cardIds;
    [a[i], a[j]] = [a[j], a[i]];
  }

  // bump
  st.version = (st.version||0) + 1;
}

function ensureStateShape(state){
  if (!state || typeof state !== "object") return null;

  const s = deepClone(state);

  if (!Array.isArray(s.players)) s.players = [];
  if (!s.cards || typeof s.cards !== "object") s.cards = {};
  if (!s.stacks || typeof s.stacks !== "object") s.stacks = {};
  if (!Array.isArray(s.chat)) s.chat = [];
  if (!s.assets || typeof s.assets !== "object") s.assets = { frontBase:"", backUrl:"" };
  if (!Array.isArray(s._deckPool)) s._deckPool = [];
  if (typeof s.version !== "number") s.version = 1;

  // ✅ thêm game.phase (setup/playing)
  if (!s.game || typeof s.game !== "object") s.game = { phase: "setup" };
  if (!s.game.phase) s.game.phase = "setup";

  return s;
}

function redactStateForViewer(state, viewerId){
  const s = ensureStateShape(state);
  if (!s) return null;

  const viewer = s.players.find(p => p && p.id === viewerId) || null;

  for (const cardId in s.cards){
    const c = s.cards[cardId];
    if (!c) continue;

    if (c.zone === ZONES.hand && c.owner && c.owner !== viewerId){
      c.faceUp = false;
      c.frontSeed = 0;
      if (c.frontUrl) c.frontUrl = "";
    }
  }

  s._viewer = viewer ? {id: viewer.id, name: viewer.name, color: viewer.color} : null;
  return s;
}

/* =========================================================
   8) Host Controller (Authoritative)
========================================================= */
function canInteract(card, actorId){
  if (!card) return false;
  if (card.zone === ZONES.hand) return card.owner === actorId;
  return true; // table/deck/discard allow (deck dragging is blocked separately)
}
function canInteractStack(stack, actorId){
  if (!stack) return false;
  if (stack.zone === ZONES.hand) return stack.owner === actorId;
  return true;
}
const ensureUIState = (st) => {
  st.ui = st.ui || {};
  st.ui.statHeaders = st.ui.statHeaders || ["ATK","DEF","HP","COIN"];
  st.ui.statsByPlayer = st.ui.statsByPlayer || {};
};
  
class HostController {
  constructor(roomCode, hostId){
    this.roomCode = roomCode;
    this.hostId = hostId;
    this.state = makeFreshTableState(roomCode, hostId);
  }
  
  bumpVersion(){ this.state.version = (this.state.version||0) + 1; }

  addOrUpdatePlayer({id,name}){
    // FIX: chống players undefined
    if (!Array.isArray(this.state.players)) this.state.players = [];

    let p = this.state.players.find(x=>x && x.id===id);
    if (!p){
      if (this.state.players.length >= 6) return {ok:false, reason:"Room full"};

      const used = new Set(this.state.players.map(x=>x.color).filter(Boolean));
      const color = COLOR_ORDER.find(c=>!used.has(c)) || COLOR_ORDER[this.state.players.length % COLOR_ORDER.length];
      const seat = this.state.players.length;
      p = {id, name: name || "Player", color, seat, connectedAt: now()};
      this.state.players.push(p);
      ensureUIState(this.state);
      if (!this.state.ui.statsByPlayer[p.id]) this.state.ui.statsByPlayer[p.id] = ["","","",""];
    }else{
      p.name = name || p.name;
    }
    this.bumpVersion();
    return {ok:true, player:p};
  }

  removePlayer(id){
    this.state.players = (this.state.players||[]).filter(p=>p && p.id!==id);
    this.bumpVersion();
  }

  applyIntent(fromId, action){
    const st = this.state = ensureStateShape(this.state) || makeFreshTableState(this.roomCode, this.hostId);
    ensureUIState(st);
    const player = st.players.find(p=>p.id===fromId);
    if (!player) return {ok:false, reason:"Not in room"};

    const rects = zoneRects();
    const ensureCard = (id) => st.cards[id];
    const ensureStack = (id) => st.stacks[id];

    const detachFromStack = (cardId) => {
      const c = ensureCard(cardId);
      if (!c || !c.stackId) return;
      const stack = ensureStack(c.stackId);
      if (!stack) { c.stackId = null; return; }
      stack.cardIds = (stack.cardIds||[]).filter(id=>id!==cardId);
      c.stackId = null;
      if ((stack.cardIds?.length||0) === 0 && stack.id !== "stack_deck"){
        delete st.stacks[stack.id];
      }
    };

    const attachToStackTop = (cardId, stackId) => {
      const c = ensureCard(cardId);
      const stack = ensureStack(stackId);
      if (!c || !stack) return;
      detachFromStack(cardId);
      c.stackId = stackId;
      c.zone = stack.zone;
      c.owner = (stack.zone === ZONES.hand) ? stack.owner : null; // chỉ hand mới có owner
      c.x = stack.x; c.y = stack.y;
      stack.cardIds = stack.cardIds || [];
      stack.cardIds.unshift(cardId);
    };

    const createStackFromCard = (cardId) => {
      const c = ensureCard(cardId);
      if (!c) return null;
    
      const sid = "stack_" + uid().slice(0,8);
    
      const zone = c.zone ?? ZONES.table;
      const owner = (zone === ZONES.hand) ? (c.ownerId ?? c.owner ?? null) : null;
    
      st.stacks[sid] = {
        id: sid,
        zone,
        owner,      // luôn string hoặc null
        x: c.x,
        y: c.y,
        cardIds: [cardId],
      };
    
      c.stackId = sid;
      return sid;
    };


    const HAND_ZONES = [
      { key: "handTopLeft", seat: 0 },
      { key: "handBottomLeft", seat: 1 },
      { key: "handTopRight", seat: 2 },
      { key: "handBottomRight", seat: 3 },
      { key: "handRightTop", seat: 4 },
      { key: "handRightBottom", seat: 5 },
    ];

    function normalizeCardZoneFromPos(x, y){
      for (const hz of HAND_ZONES){
        const r = rects[hz.key];
        if (!r) continue;

        const inRect = (x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h);
        if (!inRect) continue;

        const ownerPlayer = st.players.find(pp => pp.seat === hz.seat);
        if (!ownerPlayer){
          return { zone: ZONES.table, owner: null };
        }
        return { zone: ZONES.hand, owner: ownerPlayer.id };
      }
      return { zone: ZONES.table, owner: null };
    }

    const seatToHandKey = (seat) => {
      switch (seat){
        case 0: return "handTopLeft";
        case 1: return "handBottomLeft";
        case 2: return "handTopRight";
        case 3: return "handBottomRight";
        case 4: return "handRightTop";
        case 5: return "handRightBottom";
        default: return null;
      }
    };

    switch(action.type){
      case "move": {
        const {targetType, id, x, y} = action;

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};

          // chặn kéo card trực tiếp từ deck
          if (c.stackId === "stack_deck") return {ok:false, reason:"Use draw (D) to take from deck"};

          detachFromStack(id);

          const z = normalizeCardZoneFromPos(x, y);
          c.x = x; c.y = y;
          c.zone = z.zone;
          
          if (z.zone === ZONES.hand){
            const handOwner = z.owner ?? null;
            if (!handOwner) {
              c.zone = ZONES.table;
              c.owner = null;
            } else {
              c.owner = handOwner;
              c.ownerId = handOwner;
            }
          } else {
            c.owner = null;
          }
          c.stackId = null;
        }

        if (targetType === "stack") {
          const s = ensureStack(id);
          if (!s) return {ok:false, reason:"Missing stack"};
          if (s.id === "stack_deck") return {ok:false, reason:"Deck fixed"};
          if (!canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
        
          const z = normalizeCardZoneFromPos(x, y);
        
          s.x = x; 
          s.y = y;
        
          const handOwner = (z.zone === ZONES.hand) ? (z.owner ?? null) : null;
          if (z.zone === ZONES.hand && !handOwner) {
            s.zone = ZONES.table;
            s.owner = null;
          } else {
            s.zone = z.zone;
            s.owner = handOwner;
          }
        
          for (const cid of (s.cardIds || [])) {
            const c = ensureCard(cid);
            if (!c) continue;
        
            c.x = s.x;
            c.y = s.y;
            c.zone = s.zone;
            c.owner = (s.zone === ZONES.hand) ? s.owner : null;
        
            if (s.zone === ZONES.hand && s.owner) c.ownerId = s.owner;
          }
        }


        this.bumpVersion();
        return {ok:true};
      }

      case "flip": {
        const {targetType, id} = action;

        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};
          c.faceUp = !c.faceUp;
        } else {
          const s = ensureStack(id);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
          const topId = s.cardIds?.[0];
          if (topId){
            const c = ensureCard(topId);
            if (c) c.faceUp = !c.faceUp;
          }
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "shuffle": {
        const {stackId} = action;
        const s = ensureStack(stackId);
        if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};

        for(let i=(s.cardIds?.length||0)-1;i>0;i--){
          const j = randInt(0,i);
          [s.cardIds[i], s.cardIds[j]] = [s.cardIds[j], s.cardIds[i]];
        }

        this.bumpVersion();
        return {ok:true};
      }

      case "draw": {
        const player = st.players.find(p=>p.id===fromId);
        if (!player) return { ok:false, reason:"No player" };
      
        const handKey = seatToHandKey(player.seat);
        const handRect = rects[handKey];
        if (!handRect) return { ok:false, reason:"No hand zone" };
      
        const deck = st.stacks["stack_deck"];
        if (!deck || deck.cardIds.length === 0)
          return { ok:false, reason:"Deck empty" };
      
        const cid = deck.cardIds.shift();     // rút 1 lá khỏi bộ bài
        const c = ensureCard(cid);
        if (!c) return { ok:false, reason:"Card missing" };
      
        c.zone = ZONES.hand;
        c.owner = fromId;
        c.ownerId = fromId;
        c.faceUp = true;
        c.x = handRect.x + handRect.w/2 + randInt(-60,60);
        c.y = handRect.y + handRect.h/2 + randInt(-20,20);
        c.stackId = null;
        c.tintOwner = fromId;
      
        this.bumpVersion();
        return { ok:true };
      }


      case "discard": {
        const {targetType, id} = action;
        const rects = zoneRects();
        const r = rects.discard;
      
        const placeInDiscard = (c) => {
          if (!c) return;
          // nếu card đang nằm trong stack nào đó thì tách ra
          if (c.stackId) detachFromStack(c.id);
      
          c.zone = ZONES.discard;
          c.owner = null;          // ai cũng thao tác
          c.faceUp = true;
          c.stackId = null;
      
          // ✅ bay vào vùng discard (rải thoải mái)
          c.x = r.x + randInt(30, Math.max(30, r.w - 30));
          c.y = r.y + randInt(30, Math.max(30, r.h - 30));
          // ✅ giữ ownerId để còn màu
          // c.ownerId giữ nguyên, không đụng
        };
      
        if (targetType === "card"){
          const c = ensureCard(id);
          if (!c || !canInteract(c, fromId)) return {ok:false, reason:"No access"};
          placeInDiscard(c);
        } else {
          const s = ensureStack(id);
          if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
      
          const ids = [...(s.cardIds||[])];
          for (const cid of ids){
            const c = ensureCard(cid);
            if (!c) continue;
            placeInDiscard(c);
          }
      
          // xóa stack sau khi bung ra
          if (s.id !== "stack_deck") delete st.stacks[s.id];
        }
      
        this.bumpVersion();
        return {ok:true};
      }


      case "stack": {
        const { dragTargetType, dragId, dropOnType, dropOnId } = action;
      
        let dragCardIds = [];
        let dragStackId = null;
      
        // 1) Xác định các card đang kéo
        if (dragTargetType === "card") {
          const c = ensureCard(dragId);
          if (!c || !canInteract(c, fromId)) return { ok: false, reason: "No access" };
          dragCardIds = [dragId];
          dragStackId = c.stackId; // có thể null nếu card đang rời stack
        } else {
          const s = ensureStack(dragId);
          if (!s || !canInteractStack(s, fromId)) return { ok: false, reason: "No access" };
          dragCardIds = [...(s.cardIds || [])];
          dragStackId = s.id;
        }
      
        // 2) Xác định dropStackId (stack nhận)
        let dropStackId = null;
      
        if (dropOnType === "card") {
          const c2 = ensureCard(dropOnId);
          if (!c2) return { ok: false, reason: "Missing drop card" };
      
          // chặn gom lên card thuộc DECK cố định
          if (c2.stackId === "stack_deck") {
            return { ok: false, reason: "Cannot stack onto deck" };
          }
      
          // nếu card đang rời stack -> tạo stack mới từ card đó
          dropStackId = c2.stackId || createStackFromCard(c2.id);
        } else {
          const s2 = ensureStack(dropOnId);
          if (!s2) return { ok: false, reason: "Missing drop stack" };
      
          // chặn gom lên DECK cố định
          if (s2.id === "stack_deck") {
            return { ok: false, reason: "Cannot stack onto deck" };
          }
      
          dropStackId = s2.id;
        }
      
        if (!dropStackId) return { ok: false, reason: "No drop stack" };
        if (dragStackId && dragStackId === dropStackId) return { ok: true };
      
        const dropStack = ensureStack(dropStackId);
        if (!dropStack) return { ok: false, reason: "Drop stack missing (race)" };
        if (!canInteractStack(dropStack, fromId)) return { ok: false, reason: "No access" };
      
        // 3) Chuẩn bị danh sách card sẽ attach lên top của dropStack
        const moving = [...dragCardIds];
      
        // 4) Bóc nguồn (xóa stack nguồn hoặc detach card khỏi stack)
        if (dragTargetType === "stack") {
          const s = ensureStack(dragId);
          if (s && s.id !== "stack_deck") delete st.stacks[s.id];
        } else {
          detachFromStack(dragId);
        }
      
        // 5) Attach các card lên top dropStack (giữ thứ tự)
        for (let i = moving.length - 1; i >= 0; i--) {
          attachToStackTop(moving[i], dropStackId);
        }
      
        // 6) CHỐT owner/zone của dropStack: không bao giờ undefined
        if (dropStack.zone === ZONES.hand) {
          dropStack.owner = dropStack.owner ?? null;
      
          // nếu đang ở hand mà không có owner -> trả về table
          if (!dropStack.owner) {
            dropStack.zone = ZONES.table;
            dropStack.owner = null;
          }
        } else {
          dropStack.owner = null;
        }
      
        // 7) Update toàn bộ card trong dropStack theo stack mới
        for (const cid of (dropStack.cardIds || [])) {
          const c = ensureCard(cid);
          if (!c) continue;
      
          c.x = dropStack.x;
          c.y = dropStack.y;
          c.zone = dropStack.zone;
      
          // hand privacy: card trong hand có owner (string|null), không bao giờ undefined
          c.owner = (dropStack.zone === ZONES.hand) ? dropStack.owner : null;
      
          // nếu muốn đổi CHỦ THẬT khi đưa stack vào hand người khác
          if (dropStack.zone === ZONES.hand && dropStack.owner) {
            c.ownerId = dropStack.owner;
          }
        }
      
        this.bumpVersion();
        return { ok: true };
      }


      case "unstack": {
        const {stackId} = action;
        const s = ensureStack(stackId);
        if (!s || !canInteractStack(s, fromId)) return {ok:false, reason:"No access"};
        if ((s.cardIds?.length||0) <= 1) return {ok:true};

        const top = s.cardIds.shift();
        const c = ensureCard(top);
        if (!c) return {ok:false, reason:"Missing card"};

        c.stackId = null;
        c.x = s.x + randInt(-90,90);
        c.y = s.y + randInt(-60,60);
        c.zone = s.zone;
        
        // ✅ chỉ HAND mới có owner; còn lại null để ai cũng thao tác
        c.owner = (s.zone === ZONES.hand) ? s.owner : null;

        this.bumpVersion();
        return {ok:true};
      }

      case "chat": {
        const text = (action.text || "").toString().slice(0, 300);
        if (!text.trim()) return {ok:true};
        st.chat.push({id: uid(), at: now(), fromId, text});
        if (st.chat.length > 120) st.chat.splice(0, st.chat.length - 120);
        this.bumpVersion();
        return {ok:true};
      }

      case "reset": {
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        const keepPlayers = deepClone(st.players);
        this.state = makeFreshTableState(st.roomCode, st.hostId);
        this.state.players = keepPlayers;
        this.bumpVersion();
        return {ok:true};
      }

      case "setAssets": {
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        st.assets.frontBase = (action.frontBase||"").trim();
        st.assets.backUrl = (action.backUrl||"").trim();
        this.bumpVersion();
        return {ok:true};
      }

      case "join": {
        // no-op; host side already addOrUpdatePlayer
        this.bumpVersion();
        return {ok:true};
      }

      case "startGame": {
        // host only
        if (fromId !== st.hostId) return {ok:false, reason:"Host only"};
        st.game = st.game || {};
        st.game.phase = "playing";
        st.game.startedAt = now();
        this.bumpVersion();
        return {ok:true};
      }

      case "set_stat_header": {
        if (st.hostId && fromId !== st.hostId) return { ok:false, reason:"Host only" };
      
        ensureUIState(st);
      
        const idx = (action.idx | 0);
        const value = (action.value ?? "").toString().slice(0, 12);
      
        if (idx < 0 || idx > 3) return { ok:false, reason:"Bad index" };
      
        while (st.ui.statHeaders.length < 4) st.ui.statHeaders.push("");
        st.ui.statHeaders[idx] = value;
      
        this.bumpVersion();
        return { ok:true };
      }
      
      case "set_stat": {
        ensureUIState(st);
      
        const playerId = action.playerId;
        const idx = (action.idx | 0);
        const value = (action.value ?? "").toString().slice(0, 12);
      
        if (idx < 0 || idx > 3) return { ok:false, reason:"Bad index" };
      
        // ✅ ai cũng sửa được chỉ số của bất kỳ ai
        const p = (st.players || []).find(pp => pp.id === playerId);
        if (!p) return { ok:false, reason:"Player not found" };
      
        if (!st.ui.statsByPlayer[playerId]) st.ui.statsByPlayer[playerId] = ["", "", "", ""];
        while (st.ui.statsByPlayer[playerId].length < 4) st.ui.statsByPlayer[playerId].push("");
      
        st.ui.statsByPlayer[playerId][idx] = value;
      
        this.bumpVersion();
        return { ok:true };
      }

      default:
        return {ok:false, reason:"Unknown action"};
    }
  }
}

/* =========================================================
   9) Firebase (Auth + RTDB)
========================================================= */
const firebaseConfig = {
  apiKey: "AIzaSyBze3rgBuJ8Ex7c_yWnEVu76huNAuSFll8",
  authDomain: "tablegame-dc4a8.firebaseapp.com",
  databaseURL: "https://tablegame-dc4a8-default-rtdb.firebaseio.com",
  projectId: "tablegame-dc4a8",
  storageBucket: "tablegame-dc4a8.firebasestorage.app",
  messagingSenderId: "715606656270",
  appId: "1:715606656270:web:a1c4055c2d307201f1035f",
  measurementId: "G-KHWGKGT3GE"
};

let FB = { app:null, auth:null, db:null, user:null, uid:null, username:null };

function fbInitOnce(){
  if (FB.app) return;
  FB.app = firebase.initializeApp(firebaseConfig);
  FB.auth = firebase.auth();
  FB.db = firebase.database();
}

async function fbEnsureAuth(){
  fbInitOnce();
  if (!FB.auth.currentUser) await FB.auth.signInAnonymously();

  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  // ưu tiên nameInput (lobby), nếu rỗng thì fallback "Player"
  FB.username = ((UI.nameInput?.value || "").trim().slice(0,18)) || "Player";

  const uref = FB.db.ref(`AllUser/${FB.uid}`);
  const snap = await uref.get();

  if (!snap.exists()){
    await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
  }else{
    const cur = snap.val() || {};
    if ((cur.username||"") !== FB.username){
      await uref.update({ username: FB.username });
    }
    if (!cur.setCard) await uref.update({ setCard:{} });
  }
}

async function fbAllocateRoomNo(){
  const db = FB.db;

  const freeRef = db.ref("RoomIndex/freeNos");
  const freeSnap = await freeRef.get();
  if (freeSnap.exists()){
    const obj = freeSnap.val() || {};
    const nums = Object.keys(obj).map(x=>parseInt(x,10)).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
    for (const n of nums){
      const oneRef = db.ref(`RoomIndex/freeNos/${n}`);
      const r = await oneRef.transaction((cur)=>{ if (cur === true) return null; return; });
      if (r.committed) return n;
    }
  }

  const nextRef = db.ref("RoomIndex/nextNo");
  const res = await nextRef.transaction((cur)=> (typeof cur !== "number" ? 1 : cur + 1));
  const newVal = res.snapshot.val();
  const roomNo = Math.max(1, newVal - 1);
  return roomNo;
}

async function fbReleaseRoomNo(roomNo){
  if (!roomNo) return;
  await FB.db.ref(`RoomIndex/freeNos/${roomNo}`).set(true);
}

class FirebaseTransport extends NetTransport {
  constructor(roomId){
    super();
    this.roomId = roomId; // FIX: trước đây nhiều bạn viết this.roomId=this.roomId
    this.roomRef = FB.db.ref(`AllRoom/${this.roomId}`);
    this.intentsRef = this.roomRef.child("intents");
    this.stateRef = this.roomRef.child("state");
    this.presRef = this.roomRef.child(`presence/${FB.uid}`);

    this._stateCb = null;
    this._intentsCb = null;
    this._connectedRef = FB.db.ref(".info/connected");
    this._connectedCb = null;
    this.onStatus({connected:true, mode:"firebase"});

    this.usersRef = this.roomRef.child("users");
    this._usersCb = null;
  }
  
  listenUsers(onUsers){
    this._usersCb = (snap)=> onUsers(snap.val() || {});
    this.usersRef.on("value", this._usersCb);
  }
  
  async attachPresence(){
    this._connectedCb = async (snap)=>{
      if (snap.val() === true){
        await this.presRef.set(true);
        this.presRef.onDisconnect().remove();
      }
    };
    this._connectedRef.on("value", this._connectedCb);
  }

  listenState(onState){
    this._stateCb = (snap)=> onState(snap.val());
    this.stateRef.on("value", this._stateCb);
  }

  listenIntentsAsHost(onIntent){
    this._intentsCb = (snap)=>{
      const v = snap.val();
      if (!v) return;
      onIntent(v, snap.key);
    };
    this.intentsRef.limitToLast(200).on("child_added", this._intentsCb);
  }

  async sendIntent(action){
    const payload = { fromUid: FB.uid, fromName: FB.username, at: Date.now(), action };
    await this.intentsRef.push(payload);
  }

  async writeState(state){
    await this.stateRef.set(state);
  }

  close(){
    try{
      if (this._stateCb) this.stateRef.off("value", this._stateCb);
      if (this._intentsCb) this.intentsRef.off("child_added", this._intentsCb);
      if (this._connectedCb) this._connectedRef.off("value", this._connectedCb);
      if (this._usersCb) this.usersRef.off("value", this._usersCb);
      this.presRef.remove();
    }catch(e){}
    this.onStatus({connected:false, mode:"firebase"});
  }
}

/* =========================================================
   10) Client State + Transport wiring
========================================================= */
const client = {
  selfId: uid(),
  selfName: "",
  roomCode: "",
  roomId: "",
  roomMeta: { roomNo:null, roomId:null },

  isHost: false,
  transport: null,
  host: null,
  authoritative: null,
  lastVersion: 0,
  selected: null,
  dragging: null,
};

function setNetBadge(text, color=null){
  if (!UI.netBadge) return;
  UI.netBadge.textContent = text;
  UI.netBadge.style.borderColor = color ? color : "rgba(255,255,255,.12)";
}

function getState(){
  if (client.isHost && client.host){
    return client.authoritative || redactStateForViewer(client.host.state, client.selfId);
  }
  return client.authoritative;
}

function setStatusUI(){
  const s = client.authoritative;
  if (!s){
    UI.roomBadge && (UI.roomBadge.textContent = "—");
    UI.meLine && (UI.meLine.textContent = "—");
    UI.hostLine && (UI.hostLine.textContent = "—");
    UI.playersLine && (UI.playersLine.textContent = "—");
    UI.chatBadge && (UI.chatBadge.textContent = "—");
    updateInspector();
    return;
  }

  UI.roomBadge && (UI.roomBadge.textContent = "ROOM " + s.roomCode);
  UI.chatBadge && (UI.chatBadge.textContent = "v" + s.version);

  const me = s.players.find(p=>p.id===client.selfId);
  if (UI.meLine){
    if (me){
      UI.meLine.innerHTML = `<span style="display:inline-flex;align-items:center;gap:8px">
        <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[me.color]};box-shadow:0 0 0 3px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.18)"></span>
        <span>${escapeHtml(me.name)} (${me.color})</span>
      </span>`;
    }else{
      UI.meLine.textContent = "(chưa vào phòng)";
    }
  }

  const hostP = s.players.find(p=>p.id===s.hostId);
  if (UI.hostLine){
    UI.hostLine.innerHTML = hostP
      ? `<span style="display:inline-flex;align-items:center;gap:8px">
          <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[hostP.color]};border:1px solid rgba(255,255,255,.18)"></span>
          <span>${escapeHtml(hostP.name)}</span>
        </span>`
      : "—";
  }

  if (UI.playersLine){
    UI.playersLine.innerHTML = s.players.map(p=>{
      return `<div style="display:flex;align-items:center;gap:8px;margin:2px 0">
        <span style="width:10px;height:10px;border-radius:999px;background:${COLORS[p.color]};border:1px solid rgba(255,255,255,.18)"></span>
        <span style="color:rgba(233,236,255,.92)">${escapeHtml(p.name)}</span>
        <span style="color:rgba(233,236,255,.55);font-size:12px">(${p.color})</span>
        ${p.id===s.hostId ? `<span style="margin-left:auto;color:var(--muted);font-size:11px;border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:999px">HOST</span>` : ""}
      </div>`;
    }).join("");
  }

  updateInspector();

  // nếu inspector đang mở mà target mất -> hide, còn thì reposition
  const ins = document.getElementById("inspector");
  if (ins && ins.style.display === "block"){
    const sel = client.selected;
    if (!sel) hideInspectorPopup();
    else {
      const wp = getWorldPosOfTarget(s, sel);
      if (!wp) hideInspectorPopup();
      else positionInspectorNearTarget();
    }
  }

  // ===== Setup box UI =====
  const phase = s.game?.phase || "setup";
  if (UI.setupBox){
    UI.setupBox.style.display = (phase === "setup") ? "" : "none";
  }
  if (UI.setupPhaseLine){
    UI.setupPhaseLine.textContent = (phase === "setup")
      ? "Đang ở phòng chờ. Host chọn deck và bấm Bắt đầu."
      : "Đang chơi...";
  }
  
  // host controls: chỉ host + firebase
  const hostCanSetup = client.isHost && (client.transport instanceof FirebaseTransport);
  if (UI.hostSetupControls){
    UI.hostSetupControls.style.display = hostCanSetup && phase === "setup" ? "" : "none";
    if (hostCanSetup && phase === "setup"){
      // auto load list 1 lần nếu dropdown rỗng
      if (UI.hostSetSelect && UI.hostSetSelect.options.length === 0){
        refreshHostSetSelect().catch(()=>{});
      }
    }
  }
  renderChat();
}

function sendToServer(msg){
  if (!client.transport) return;
  client.transport.send(msg);
}

async function sendIntentFirebase(action){
  if (!(client.transport instanceof FirebaseTransport)) return;
  await client.transport.sendIntent(action);
}

function sendIntent(action){
  if (UI.modeSelect?.value === "firebase"){
    sendIntentFirebase(action);
    return;
  }
  sendToServer({
    type: "intent",
    roomCode: client.roomCode,
    fromId: client.selfId,
    action,
    at: now(),
  });
}

function installTransport(t){
  if (client.transport) client.transport.close();
  client.transport = t;

  t.onStatus = (st) => {
    if (st.connected){
      if (st.mode === "firebase") setNetBadge("FIREBASE", "rgba(73,209,124,.65)");
      else if (st.mode === "ws") setNetBadge("WS", "rgba(73,209,124,.55)");
      else setNetBadge("LOCAL", "rgba(73,209,124,.55)");
    } else {
      setNetBadge("OFFLINE", "rgba(255,255,255,.12)");
    }
  };

  t.onMessage = (msg) => {
    if (!msg) return;

    // Firebase transport không dùng protocol local/ws ở đây
    if (client.transport instanceof FirebaseTransport) return;

    // Local/WS
    if (msg.roomCode !== client.roomCode) return;

    if (msg.type === "hello" && client.isHost && client.host){
      const res = client.host.addOrUpdatePlayer({id: msg.fromId, name: msg.name});
      if (!res.ok){
        sendToServer({type:"deny", roomCode: client.roomCode, toId: msg.fromId, reason: res.reason});
        return;
      }
      client.host.applyIntent(client.host.hostId, {type:"chat", text:`${msg.name} joined.`});
      broadcastStateRaw();
      return;
    }

    if (msg.type === "bye" && client.isHost && client.host){
      client.host.removePlayer(msg.fromId);
      client.host.applyIntent(client.host.hostId, {type:"chat", text:`A player left.`});
      broadcastStateRaw();
      return;
    }

    if (msg.type === "deny"){
      if (msg.toId === client.selfId){
        toast("Không vào được phòng: " + (msg.reason || "Denied"));
        leaveRoom();
      }
      return;
    }

    if (msg.type === "intent"){
      if (client.isHost && client.host){
        const r = client.host.applyIntent(msg.fromId, msg.action);
        if (!r.ok && msg.fromId === client.selfId) toast("Action fail: " + r.reason);
        broadcastStateRaw();
      }
      return;
    }

    if (msg.type === "stateRaw"){
      if (client.isHost) return;
      const red = redactStateForViewer(msg.state, client.selfId);
      if (red && (red.version >= (client.lastVersion||0))){
        client.authoritative = red;
        client.lastVersion = red.version;
        setStatusUI();
      }
      return;
    }
  };
}

/* =========================================================
   11) Room: Local/WS create/join/leave
========================================================= */
function genRoomCode(){
  const a = Math.random().toString(36).slice(2, 6).toUpperCase();
  const b = Math.random().toString(36).slice(2, 6).toUpperCase();
  return `${a}-${b}`;
}

function readInputs(){
  client.selfName = (UI.nameInput?.value || "").trim().slice(0,18) || "Player";
  client.roomCode = (UI.roomInput?.value || "").trim().toUpperCase();
  if (!client.roomCode) client.roomCode = genRoomCode();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;
}

function makeTransportForCurrentMode(){
  const mode = UI.modeSelect?.value || "local";

  if (mode === "ws"){
    const url = (UI.wsUrlInput?.value || "").trim() || "ws://localhost:8080";
    return new WebSocketTransport(url);
  }

  try{
    if (typeof BroadcastChannel !== "undefined"){
      return new LocalBroadcastTransport(client.roomCode, client.selfId);
    }
  }catch(e){}
  return new LocalStorageTransport(client.roomCode, client.selfId);
}

function broadcastStateRaw(){
  if (!client.isHost || !client.host) return;
  const st = client.host.state;

  sendToServer({type:"stateRaw", roomCode: client.roomCode, state: deepClone(st), at: now()});

  client.authoritative = redactStateForViewer(st, client.selfId);
  client.lastVersion = client.authoritative.version;
  setStatusUI();
}

function createRoomAsHost_LocalOrWS(){
  readInputs();

  client.isHost = true;
  client.host = new HostController(client.roomCode, client.selfId);

  const t = makeTransportForCurrentMode();
  installTransport(t);

  // host add itself
  client.host.addOrUpdatePlayer({ id: client.selfId, name: client.selfName });

  client.authoritative = redactStateForViewer(client.host.state, client.selfId);
  client.lastVersion = client.authoritative.version;

  setStatusUI();
  broadcastStateRaw();

  toast("Đã tạo phòng (Host)");
  goMatch();
}

function joinRoomAsClient_LocalOrWS(){
  readInputs();
  client.isHost = false;
  client.host = null;

  const t = makeTransportForCurrentMode();
  installTransport(t);

  sendToServer({type:"hello", roomCode: client.roomCode, fromId: client.selfId, name: client.selfName, at: now()});
  toast("Đang vào phòng...");
  goMatch();
}

function leaveRoom(){
  if (!client.roomCode) return;

  try{
    if (!client.isHost){
      sendToServer({type:"bye", roomCode: client.roomCode, fromId: client.selfId, at: now()});
    }
  }catch(e){}

  if (client.transport) client.transport.close();
  client.transport = null;
  client.isHost = false;
  client.host = null;
  client.authoritative = null;
  client.lastVersion = 0;
  client.selected = null;
  client.dragging = null;

  setStatusUI();
  setNetBadge("OFFLINE");
}

/* =========================================================
   12) Room: Firebase create/join
========================================================= */
async function createRoomAsHost_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  const roomNo = await fbAllocateRoomNo();
  const roomId = `room${roomNo}`;

  client.roomId = roomId.toLowerCase();
  client.roomCode = roomId.toUpperCase();
  if (UI.roomInput) UI.roomInput.value = client.roomCode;

  client.isHost = true;
  client.host = new HostController(client.roomCode, FB.uid);
  client.host.addOrUpdatePlayer({ id: FB.uid, name: FB.username });

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.set({
    meta: {
      roomNo,
      roomId,
      hostUid: FB.uid,
      status: "active",
      createdAt: Date.now(),
      maxPlayers: 6,
      deckSource: null,
      deckBackUrl: "",
    },
    presence: {},
    users: {},
    intents: {},
    state: client.host.state,
  });

  await roomRef.child(`users/${FB.uid}`).set({ username: FB.username, seat: 0, atk: 0, def: 0, hp: 20 });

  client.authoritative = redactStateForViewer(client.host.state, FB.uid);
  client.lastVersion = client.authoritative.version;
  setStatusUI();

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);
  t.listenUsers((users)=>{
    // nhét vào authoritative để overlay đọc được
    if (!client.authoritative) client.authoritative = {};
    client.authoritative._users = users;
  });
  await t.attachPresence();

  t.listenIntentsAsHost(async (msg, intentKey)=>{
    const action = msg.action;
    const fromId = msg.fromUid;

    client.host.addOrUpdatePlayer({ id: fromId, name: msg.fromName });

    const r = client.host.applyIntent(fromId, action);
    if (!r.ok && fromId === FB.uid) toast("Action fail: " + r.reason);

    await t.writeState(client.host.state);

    try{ await FB.db.ref(`AllRoom/${client.roomId}/intents/${intentKey}`).remove(); }catch(e){}
  });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    if (client.isHost && client.host){
      client.host.state = st;
      client.authoritative = redactStateForViewer(st, FB.uid);
    } else {
      client.authoritative = redactStateForViewer(st, FB.uid);
    }
    client.lastVersion = st.version || client.lastVersion;
    setStatusUI();
  });

  toast(`Đã tạo room: ${roomId}`);
  client.roomMeta = { roomNo, roomId };

  installFirebaseRoomCleanupAsHost(client.roomId, roomNo);

  goMatch();
}

async function joinRoomAsClient_Firebase(){
  await fbEnsureAuth();

  client.selfId = FB.uid;
  client.selfName = FB.username;

  readInputs();
  client.roomId = client.roomCode.toLowerCase();
  if (!client.roomId.startsWith("room")) return toast("Nhập room dạng: room1 / ROOM1");

  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  const metaSnap = await roomRef.child("meta").get();
  if (!metaSnap.exists()) return toast("Room không tồn tại / đã đóng");

  await roomRef.child(`users/${FB.uid}`).set({ username: FB.username, seat: -1, atk: 0, def: 0, hp: 20 });

  client.isHost = false;
  client.host = null;

  const t = new FirebaseTransport(client.roomId);
  installTransport(t);

  t.listenUsers((users)=>{
    // nhét vào authoritative để overlay đọc được
    if (!client.authoritative) client.authoritative = {};
    client.authoritative._users = users;
  });
  
  await t.attachPresence();

  await t.sendIntent({ type: "join" });

  t.listenState((st)=>{
    if (!st || typeof st !== "object") return;
    const red = redactStateForViewer(st, FB.uid);
    if (!red) return;
    client.authoritative = red;
    client.lastVersion = red.version || client.lastVersion;
    setStatusUI();
  });

  toast("Đã vào " + client.roomCode);
  goMatch();
}

function installFirebaseRoomCleanupAsHost(roomId, roomNo){
  const presRef = FB.db.ref(`AllRoom/${roomId}/presence`);
  presRef.on("value", async (snap)=>{
    if (!client.isHost) return;
    const v = snap.val() || {};
    const keys = Object.keys(v);
    if (keys.length === 0){
      try{ await FB.db.ref(`AllRoom/${roomId}`).remove(); }catch(e){}
      try{ await fbReleaseRoomNo(roomNo); }catch(e){}
    }
  });
}

/* =========================================================
   13) Deck/SetCard Modal (RTDB)
========================================================= */
const DECKUI = {
  modal: document.getElementById("deckModal"),
  openBtn: document.getElementById("openDeckBtn"),
  closeBtn: document.getElementById("closeDeckBtn"),
  userBadge: document.getElementById("deckUserBadge"),

  setSelect: document.getElementById("setSelect"),
  newSetBtn: document.getElementById("newSetBtn"),
  loadSetBtn: document.getElementById("loadSetBtn"),
  deleteSetBtn: document.getElementById("deleteSetBtn"),

  setNameInput: document.getElementById("setNameInput"),
  backUrlInput: document.getElementById("setBackUrlInput"),
  addCardBtn: document.getElementById("addCardUrlBtn"),
  list: document.getElementById("cardUrlList"),

  saveBtn: document.getElementById("saveSetBtn"),
  loadToRoomBtn: document.getElementById("loadSetToRoomBtn"),
};

let deckSetsCache = {};
let deckCurrentSetId = null;

function openDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "flex"; }
function closeDeckModal(){ if (DECKUI.modal) DECKUI.modal.style.display = "none"; }

function makeCardTypeRow({frontUrl="", count=1, name=""} = {}){
  const row = document.createElement("div");
  row.className = "card-url-row";

  const inpName = document.createElement("input");
  inpName.className = "mono";
  inpName.placeholder = "Tên loại (optional)";
  inpName.value = name;

  const inpUrl = document.createElement("input");
  inpUrl.className = "mono";
  inpUrl.placeholder = "https://.../front.png";
  inpUrl.value = frontUrl;

  const inpCount = document.createElement("input");
  inpCount.type = "number";
  inpCount.min = "1";
  inpCount.step = "1";
  inpCount.value = String(Math.max(1, parseInt(count,10)||1));
  inpCount.style.width = "86px";

  const del = document.createElement("button");
  del.className = "danger";
  del.textContent = "X";
  del.onclick = ()=> row.remove();

  row.appendChild(inpName);
  row.appendChild(inpUrl);
  row.appendChild(inpCount);
  row.appendChild(del);
  return row;
}


function fillEditorFromSet(setId, data){
  deckCurrentSetId = setId;
  DECKUI.setNameInput.value = data?.name || "";
  DECKUI.backUrlInput.value = data?.backUrl || "";
  DECKUI.list.innerHTML = "";

  const cardsObj = data?.cards || {};
  const types = Object.values(cardsObj);

  for (const t of types){
    DECKUI.list.appendChild(makeCardTypeRow({
      name: t.name || "",
      frontUrl: t.frontUrl || "",
      count: t.count || 1
    }));
  }
  if (types.length === 0){
    DECKUI.list.appendChild(makeCardTypeRow());
  }
}
function editorToSetData(){
  const name = (DECKUI.setNameInput.value||"").trim() || "Untitled";
  const backUrl = (DECKUI.backUrlInput.value||"").trim();

  const rows = [...DECKUI.list.querySelectorAll(".card-url-row")];

  const cards = {};
  let idx = 1;
  for (const row of rows){
    const inputs = row.querySelectorAll("input");
    const rowName  = (inputs[0]?.value || "").trim();
    const frontUrl = (inputs[1]?.value || "").trim();
    const count    = Math.max(1, parseInt(inputs[2]?.value || "1", 10) || 1);

    if (!frontUrl) continue;

    cards["t"+idx] = { name: rowName, frontUrl, count };
    idx++;
  }

  return { name, backUrl, cards, updatedAt: Date.now() };
}


async function refreshSetList(){
  await fbEnsureAuth();
  if (DECKUI.userBadge) DECKUI.userBadge.textContent = `UID: ${FB.uid.slice(0,6)}... | ${FB.username}`;

  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard`);
  const snap = await ref.get();
  deckSetsCache = snap.val() || {};

  if (!DECKUI.setSelect) return;

  DECKUI.setSelect.innerHTML = "";
  const ids = Object.keys(deckSetsCache);

  if (ids.length === 0){
    const op = document.createElement("option");
    op.value = "";
    op.textContent = "(chưa có set)";
    DECKUI.setSelect.appendChild(op);
    deckCurrentSetId = null;
    fillEditorFromSet(null, {name:"", backUrl:"", cards:{}});
    return;
  }

  for (const id of ids){
    const op = document.createElement("option");
    op.value = id;
    op.textContent = `${deckSetsCache[id]?.name || id} (${Object.keys(deckSetsCache[id]?.cards||{}).length})`;
    DECKUI.setSelect.appendChild(op);
  }

  const pick = (deckCurrentSetId && deckSetsCache[deckCurrentSetId]) ? deckCurrentSetId : ids[0];
  DECKUI.setSelect.value = pick;
  fillEditorFromSet(pick, deckSetsCache[pick]);
}

async function createNewSet(){
  await fbEnsureAuth();
  const newId = "set_" + uid().slice(0,8);
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${newId}`);
  await ref.set({ name:"New Set", backUrl:"", cards:{}, createdAt: Date.now(), updatedAt: Date.now() });
  await refreshSetList();
  if (DECKUI.setSelect) DECKUI.setSelect.value = newId;
  fillEditorFromSet(newId, deckSetsCache[newId]);
}

async function saveCurrentSet(){
  await fbEnsureAuth();
  if (!deckCurrentSetId) await createNewSet();
  const data = editorToSetData();
  const ref = FB.db.ref(`AllUser/${FB.uid}/setCard/${deckCurrentSetId}`);
  await ref.update(data);
  toast("Đã lưu set");
  await refreshSetList();
}

async function deleteCurrentSet(){
  await fbEnsureAuth();
  const id = DECKUI.setSelect?.value;
  if (!id) return;
  await FB.db.ref(`AllUser/${FB.uid}/setCard/${id}`).remove();
  toast("Đã xóa set");
  deckCurrentSetId = null;
  await refreshSetList();
}

async function loadSelectedSet(){
  const id = DECKUI.setSelect?.value;
  if (!id || !deckSetsCache[id]) return;
  fillEditorFromSet(id, deckSetsCache[id]);
  toast("Đã load set vào editor");
}

async function hostLoadSetToRoom(){
  if (!client.isHost) return toast("Chỉ host mới load set vào room");
  if (!(client.transport instanceof FirebaseTransport)) return toast("Chỉ dùng được trong Firebase mode");

  const id = deckCurrentSetId || DECKUI.setSelect.value;
  if (!id) return toast("Chưa chọn set");

  // lấy data từ editor
  const data = editorToSetData();

  if (!deckCurrentSetId){
    await createNewSet();
  }
  await saveCurrentSet();

  // extract types
  const types = Object.values(data.cards || {}).map(t=>({
    name: t.name || "",
    frontUrl: t.frontUrl || "",
    count: t.count || 1,
  })).filter(t=>t.frontUrl && t.count>0);

  const total = types.reduce((s,t)=>s + (t.count|0), 0);
  if (total <= 0) return toast("Set rỗng (chưa có url)");

  const backUrl = data.backUrl || "";

  // update meta
  const roomRef = FB.db.ref(`AllRoom/${client.roomId}`);
  await roomRef.child("meta").update({
    deckSource: { uid: FB.uid, setId: id },
    deckBackUrl: backUrl,
    deckTotal: total
  });

  // BUILD physical deck on host state
  if (client.host && client.host.state){
    client.host.state.assets.backUrl = backUrl;
    buildPhysicalDeckFromTypes(client.host.state, types, "stack_deck");
    client.host.bumpVersion?.();
    await client.transport.writeState(client.host.state);
  }

  toast(`Loaded deck: ${types.length} loại / ${total} lá`);
}


/* =========================================================
   14) Images cache
========================================================= */
const imgCache = new Map();
function loadImg(url){
  if (!url) return null;
  if (imgCache.has(url)) return imgCache.get(url);
  const im = new Image();
  im.src = url;
  imgCache.set(url, im);
  return im;
}

/* =========================================================
   15) Chat
========================================================= */
const CHATUI = {
  mode: "all", // "all" | "team"
  lastCount: 0,
};

function fmtTime(ts){
  try{
    const d = new Date(ts);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }catch(e){
    return "";
  }
}

function getPlayerById(s, id){
  return (s.players || []).find(p => p && p.id === id) || null;
}

function renderChat(){
  const s = getState();
  if (!s) return;

  const log = document.getElementById("chatLog");
  const badge = document.getElementById("chatBadge");
  if (!log || !badge) return;

  const msgs = (s.chat || []);
  badge.textContent = String(msgs.length);

  // Nếu bạn muốn TEAM filter thật thì filter ở đây.
  const visible = msgs; // CHATUI.mode === "team" ? msgs.filter(...) : msgs;

  // Re-render đơn giản (vì max 120 msg vẫn nhẹ)
  log.innerHTML = "";

  // class age: làm mờ tin nhắn cũ
  const n = visible.length;

  for (let i = 0; i < n; i++){
    const m = visible[i];
    const p = getPlayerById(s, m.fromId);
    const name = p?.name || "Player";
    const dot = p ? (COLORS?.[p.color] || "rgba(255,255,255,.55)") : "rgba(255,255,255,.35)";
    const time = m.at ? fmtTime(m.at) : "";

    let ageCls = "";
    const age = n - i;
    if (age > 18) ageCls = "age4";
    else if (age > 12) ageCls = "age3";
    else if (age > 7) ageCls = "age2";

    const row = document.createElement("div");
    row.className = `msg ${ageCls}`;
    row.innerHTML = `
      <div class="dot" style="background:${dot}"></div>
      <div class="bubble">
        <div class="meta">
          <span class="name">${escapeHtml(name)}</span>
          <span class="time">${escapeHtml(time)}</span>
        </div>
        <div class="text">${escapeHtml(m.text || "")}</div>
      </div>
    `;
    log.appendChild(row);
  }

  // auto scroll khi có tin mới (như LoL)
  if (msgs.length !== CHATUI.lastCount){
    log.scrollTop = log.scrollHeight;
    CHATUI.lastCount = msgs.length;
  }
}

// toggle ALL/TEAM
(function initChatToggle(){
  const tg = document.getElementById("chatToggle");
  if (!tg) return;
  tg.addEventListener("click", (e)=>{
    const btn = e.target.closest("button[data-mode]");
    if (!btn) return;
    CHATUI.mode = btn.dataset.mode;

    tg.querySelectorAll("button").forEach(b=>b.classList.toggle("active", b===btn));
    renderChat();
  });
})();

// submit form -> send intent
(function initChatForm(){
  const form = document.getElementById("chatForm");
  const input = document.getElementById("chatInput");
  if (!form || !input) return;

  form.addEventListener("submit", (e)=>{
    e.preventDefault();
    const text = (input.value || "").trim();
    if (!text) return;
    input.value = "";
    sendIntent({ type:"chat", text });
  });

  // Enter gửi, Shift+Enter xuống dòng (LoL style thường không multiline, nhưng bạn có thể giữ)
})();


/* =========================================================
   16) Input / HitTest / Drag
========================================================= */
function mousePos(ev){
  const rect = canvas.getBoundingClientRect();
  return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
}

function cardZ(c){
  let z = 10;
  if (c.zone === ZONES.table) z = 50;
  if (c.zone === ZONES.discard) z = 50;
  if (c.zone === ZONES.hand) z = 80;
  if (c.zone === ZONES.deck) z = 40;
  return z + (c.order||0)*0.001;
}
  
function stackZ(s){
  let z = 12;
  if (s.zone === ZONES.table) z = 55;
  if (s.zone === ZONES.hand) z = 85;
  if (s.zone === ZONES.deck) z = 42;
  if (s.zone === ZONES.discard) z = 55;
  return z + (s.cardIds?.length||0)*0.01;
}

function listDrawableObjects(state){
  const out = [];
  if (!state) return out;

  for (const sid in state.stacks){
    const s = state.stacks[sid];
    if (!s) continue;
    out.push({type:"stack", id:sid, x:s.x, y:s.y, zone:s.zone, owner:s.owner, z: stackZ(s)});
  }
  for (const cid in state.cards){
    const c = state.cards[cid];
    if (!c || c.stackId) continue;
    out.push({type:"card", id:cid, x:c.x, y:c.y, zone:c.zone, owner:c.owner, z: cardZ(c)});
  }
  out.sort((a,b)=>a.z-b.z);
  return out;
}

function hitTest(worldX, worldY){
  const state = getState();
  if (!state) return null;

  const objs = listDrawableObjects(state);
  for (let i=objs.length-1; i>=0; i--){
    const o = objs[i];
    const w = CARD.w, h = CARD.h;
    const x0 = o.x - w/2, y0 = o.y - h/2;
    if (worldX >= x0 && worldX <= x0+w && worldY >= y0 && worldY <= y0+h){
      if (o.zone === ZONES.hand && o.owner && o.owner !== client.selfId) return null;
      return {type:o.type, id:o.id};
    }
  }
  return null;
}

function calcDragOffset(state, target, p){
  if (target.type === "card"){
    const c = state.cards[target.id];
    if (!c) return {dx:0,dy:0};
    return {dx: p.x - c.x, dy: p.y - c.y};
  } else {
    const s = state.stacks[target.id];
    if (!s) return {dx:0,dy:0};
    return {dx: p.x - s.x, dy: p.y - s.y};
  }
}

canvas.addEventListener("mousedown", (ev)=>{
  const st = getState();
  if (!st) return;

  const p = toWorld(mousePos(ev));
  const hit = hitTest(p.x, p.y);

  if (hit){
    client.selected = hit;
    updateInspector();
    client.dragging = { target: hit, start: p, offset: calcDragOffset(st, hit, p), moved:false };
  }else{
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
  }
});

addEventListener("mousemove", (ev)=>{
  if (!client.dragging) return;
  hideInspectorPopup();
  const st = getState();
  if (!st) return;
  const p = toWorld(mousePos(ev));
  client.dragging.moved = true;
  client.dragging.cur = p;
});

addEventListener("mouseup", (ev)=>{
  if (!client.dragging) return;

  const st = getState();
  const drag = client.dragging;
  client.dragging = null;
  if (!st) return;

  const p = toWorld(mousePos(ev));

  if (!drag.moved){
    showInspectorPopup();
    return;
  }

  const hit = hitTest(p.x, p.y);
  if (hit && !(hit.type===drag.target.type && hit.id===drag.target.id)){
    hideInspectorPopup();
    sendIntent({ type:"stack", dragTargetType: drag.target.type, dragId: drag.target.id, dropOnType: hit.type, dropOnId: hit.id });
    return;
  }

  hideInspectorPopup();
  sendIntent({
    type:"move",
    targetType: drag.target.type,
    id: drag.target.id,
    x: p.x - (drag.offset?.dx||0),
    y: p.y - (drag.offset?.dy||0),
  });
});

/* =========================================================
   17) Keyboard + Inspector buttons
========================================================= */
if (INS.btnFlip) INS.btnFlip.onclick = ()=>{
  if (!client.selected) return;
  sendIntent({type:"flip", targetType: client.selected.type, id: client.selected.id});
};
if (INS.btnDiscard) INS.btnDiscard.onclick = ()=>{
  if (!client.selected) return;
  sendIntent({type:"discard", targetType: client.selected.type, id: client.selected.id});
};
if (INS.btnUnstack) INS.btnUnstack.onclick = ()=>{
  const sel = client.selected;
  if (!sel || sel.type!=="stack") return;
  sendIntent({type:"unstack", stackId: sel.id});
};
if (INS.btnShuffle) INS.btnShuffle.onclick = ()=>{
  const sel = client.selected;
  if (sel?.type==="stack") sendIntent({type:"shuffle", stackId: sel.id});
  else sendIntent({type:"shuffle", stackId:"stack_deck"});
};

addEventListener("keydown", (ev)=>{
  if (ev.target && (ev.target.tagName==="INPUT" || ev.target.tagName==="TEXTAREA")) return;

  const st = getState();
  if (!st) return;

  const key = ev.key.toLowerCase();
  if (key === "escape"){
    client.selected = null;
    hideInspectorPopup();
    updateInspector();
    return;
  }
  if (key === "d"){
    sendIntent({type:"draw"});
    toast("Draw 1");
    return;
  }
  if (key === "f"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"flip", targetType: sel.type, id: sel.id});
    return;
  }
  if (key === "s"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"shuffle", stackId: sel.id});
    else sendIntent({type:"shuffle", stackId:"stack_deck"});
    return;
  }
  if (key === "u"){
    const sel = client.selected;
    if (sel && sel.type==="stack") sendIntent({type:"unstack", stackId: sel.id});
    return;
  }
  if (key === "x"){
    const sel = client.selected;
    if (!sel) return;
    sendIntent({type:"discard", targetType: sel.type, id: sel.id});
    return;
  }
});

/* =========================================================
   18) Rendering helpers + main loop
========================================================= */
function rr(x,y,w,h,r){
  ctx.beginPath();
  const r2 = Math.min(r, w/2, h/2);
  ctx.moveTo(x+r2, y);
  ctx.arcTo(x+w, y, x+w, y+h, r2);
  ctx.arcTo(x+w, y+h, x, y+h, r2);
  ctx.arcTo(x, y+h, x, y, r2);
  ctx.arcTo(x, y, x+w, y, r2);
  ctx.closePath();
}

function drawZone(rect, label, subtitle="", highlight=false, tint=null){
  const s0 = toScreen({x:rect.x, y:rect.y});
  const s1 = toScreen({x:rect.x+rect.w, y:rect.y+rect.h});
  const x = s0.x, y = s0.y, w = (s1.x-s0.x), h = (s1.y-s0.y);

  ctx.save();

  rr(x,y,w,h,18);

  // base
  ctx.globalAlpha = highlight ? 0.85 : 0.35;
  ctx.fillStyle = highlight ? "rgba(122,162,255,.22)" : "rgba(0,0,0,.10)";
  ctx.fill();

  // tint color for player zone
  if (tint){
    ctx.globalAlpha = highlight ? 0.18 : 0.10;
    ctx.fillStyle = tint;
    ctx.fill();
  }

  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(233,236,255,.85)";
  ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
  ctx.fillText(label, x+12, y+18);

  if (subtitle){
    ctx.globalAlpha = 0.6;
    ctx.fillText(subtitle, x+12, y+34);
  }

  ctx.restore();
}

function drawCardAtScreen(
  cx, cy,
  faceUp,
  frontSeed,
  accent=null,
  isSelected=false,
  isStackTop=false,
  stackCount=0,
  frontUrl="",
  backUrl=""
){
  const w = CARD.w * camera.scale;
  const h = CARD.h * camera.scale;
  const x = cx - w/2, y = cy - h/2;
  const r = CARD.r * camera.scale;

  ctx.save();

  ctx.globalAlpha = 0.35;
  rr(x+4, y+6, w, h, r);
  ctx.fillStyle = "rgba(0,0,0,.65)";
  ctx.fill();
  ctx.globalAlpha = 1;

  rr(x, y, w, h, r);
  ctx.fillStyle = faceUp ? "rgba(255,255,255,.07)" : "rgba(0,0,0,.20)";
  ctx.fill();
  ctx.strokeStyle = isSelected ? "rgba(122,162,255,.85)" : "rgba(255,255,255,.14)";
  ctx.lineWidth = isSelected ? 2 : 1;
  ctx.stroke();

  if (accent){
    ctx.globalAlpha = 0.75;
    rr(x+8, y+8, w-16, 14*camera.scale, 9*camera.scale);
    ctx.fillStyle = accent;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  const url = faceUp ? (frontUrl || "") : (backUrl || "");
  const img = url ? loadImg(url) : null;

  if (img && img.complete && img.naturalWidth > 0){
    const padX = 6*camera.scale;
    const topPad = 28*camera.scale;
    const botPad = 10*camera.scale;
    rr(x+padX, y+topPad, w-2*padX, h-topPad-botPad, 10*camera.scale);
    ctx.clip();
    ctx.globalAlpha = 0.95;

    const iw = img.naturalWidth, ih = img.naturalHeight;
    const availW = w-2*padX;
    const availH = h-topPad-botPad;
    const scale = Math.min(availW/iw, availH/ih);
    const dw = iw*scale, dh = ih*scale;

    ctx.drawImage(img, x + (w-dw)/2, y + topPad + (availH-dh)/2, dw, dh);
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = "rgba(233,236,255,.9)";
    ctx.font = `${Math.max(10, 12*camera.scale)}px ui-monospace, monospace`;
    if (faceUp && frontSeed){
      const n = String(frontSeed).padStart(2,"0");
      ctx.fillText("CARD " + n, x + 12*camera.scale, y + 34*camera.scale);
    } else {
      ctx.fillText("BACK", x + 12*camera.scale, y + 34*camera.scale);
    }
  }

  if (isStackTop && stackCount>1){
    ctx.globalAlpha = 0.95;
    rr(x+w-34*camera.scale, y+10*camera.scale, 24*camera.scale, 18*camera.scale, 8*camera.scale);
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.stroke();
    ctx.fillStyle = "rgba(233,236,255,.86)";
    ctx.font = `${Math.max(10, 11*camera.scale)}px ui-monospace, monospace`;
    ctx.fillText(String(stackCount), x+w-28*camera.scale, y+24*camera.scale);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);

  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(0,0,0,.25)";
  ctx.fillRect(0,0,innerWidth,innerHeight);
  ctx.restore();

  const rects = zoneRects();
  const s = getState();
  if (!s){
    requestAnimationFrame(draw);
    return;
  }

  const seatName = (seat)=>{
    const p = s.players.find(pp=>pp.seat===seat);
    return p ? p.name : "(empty)";
  };

  drawZone(rects.table, "TABLE", "", false);

  const selfId = client.selfId ?? client.playerId ?? client.uid ?? FB?.uid;
  const me = s.players.find(p => p.id === selfId);
  const mySeat = me ? (Number(me.seat) | 0) : -1;
  
  const playerBySeat = (seat)=> s.players.find(pp => (Number(pp.seat)|0) === seat) || null;
  const tintBySeat = (seat)=>{
    const p = playerBySeat(seat);
    return p ? (COLORS?.[p.color] ?? p.color ?? null) : null;
  };
  
  drawZone(rects.handTopLeft,     "Người chơi 1", seatName(0), mySeat===0, tintBySeat(0));
  drawZone(rects.handTopRight,    "Người chơi 3", seatName(2), mySeat===2, tintBySeat(2));
  drawZone(rects.handBottomLeft,  "Người chơi 2", seatName(1), mySeat===1, tintBySeat(1));
  drawZone(rects.handBottomRight, "Người chơi 4", seatName(3), mySeat===3, tintBySeat(3));
  drawZone(rects.handRightTop,    "Người chơi 5", seatName(4), mySeat===4, tintBySeat(4));
  drawZone(rects.handRightBottom, "Người chơi 6", seatName(5), mySeat===5, tintBySeat(5));

  drawZone(rects.deck, "DECK");
  drawZone(rects.discard, "DISCARD");

  const objs = listDrawableObjects(s);
  const backUrlDefault = s.assets?.backUrl || "";

  for (const o of objs){
    const isSelected = client.selected && client.selected.type === o.type && client.selected.id === o.id;

    let wx = o.x, wy = o.y;
    if (client.dragging &&
        client.dragging.target.type === o.type &&
        client.dragging.target.id === o.id &&
        client.dragging.cur){
      wx = client.dragging.cur.x - (client.dragging.offset?.dx||0);
      wy = client.dragging.cur.y - (client.dragging.offset?.dy||0);
    }

    const sp = toScreen({x: wx, y: wy});

    if (o.type === "card"){
      const c = s.cards[o.id];
      if (!c) continue;

      const owner = s.players.find(p=>p.id===(c.ownerId || c.owner));
      const accent = owner ? COLORS[owner.color] : null;

      const frontUrl = c.frontUrl || (s.assets?.frontBase ? (s.assets.frontBase + c.id + ".png") : "");
      drawCardAtScreen(sp.x, sp.y, !!c.faceUp, c.frontSeed, accent, isSelected, false, 0, frontUrl, backUrlDefault);
    } else {
      const stack = s.stacks[o.id];
      if (!stack) continue;

      const topId = stack.cardIds?.[0];
      const top = topId ? s.cards[topId] : null;

      const topOwnerId = top?.ownerId || top?.owner || stack.owner;
      const owner = s.players.find(p=>p.id===topOwnerId);
      const accent = owner ? COLORS[owner.color] : null;

      if (top){
        const frontUrl = top.frontUrl || (s.assets?.frontBase ? (s.assets.frontBase + topId + ".png") : "");
        drawCardAtScreen(sp.x, sp.y, !!top.faceUp, top.frontSeed, accent, isSelected, true, stack.cardIds.length, frontUrl, backUrlDefault);

        if (stack.cardIds.length > 1){
          ctx.save();
          ctx.globalAlpha = 0.25;
          for (let i=1; i<Math.min(4, stack.cardIds.length); i++){
            const dx = i * 2 * camera.scale;
            const dy = i * 2 * camera.scale;
            drawCardAtScreen(sp.x+dx, sp.y+dy, false, 0, null, false, false, 0, "", backUrlDefault);
          }
          ctx.restore();
        }
      }
    }
  }
  updateStatsOverlay();
  requestAnimationFrame(draw);
  renderStatusBoard();
}
requestAnimationFrame(draw);

const STATS_UI = { root: document.getElementById("statsOverlay") };
const _statInputs = new Map(); // key: uid

function seatRectKey(seat){
  switch (seat){
    case 0: return "handTopLeft";
    case 1: return "handBottomLeft";
    case 2: return "handTopRight";
    case 3: return "handBottomRight";
    case 4: return "handRightTop";
    case 5: return "handRightBottom";
    default: return null;
  }
}

function ensureStatBoxForUser(userId){
  if (_statInputs.has(userId)) return _statInputs.get(userId);

  const box = document.createElement("div");
  box.className = "statBox";

  const dot = document.createElement("div");
  dot.className = "dot";

  const name = document.createElement("div");
  name.className = "name";
  name.textContent = "Player";

  const mkField = (labelText)=>{
    const wrap = document.createElement("div");
    const lab = document.createElement("label");
    lab.textContent = labelText;
    const inp = document.createElement("input");
    inp.type = "number";
    inp.step = "1";
    inp.value = "0";
    wrap.appendChild(lab);
    wrap.appendChild(inp);
    return {wrap, inp};
  };

  const atk = mkField("ATK");
  const def = mkField("DEF");
  const hp  = mkField("HP");

  box.appendChild(dot);
  box.appendChild(name);
  box.appendChild(atk.wrap);
  box.appendChild(def.wrap);
  box.appendChild(hp.wrap);

  // realtime update to RTDB (ai cũng sửa)
  const commit = async (uid, patch)=>{
    if (!(client.transport instanceof FirebaseTransport)) return;
    if (!client.roomId) return;
    try{
      await FB.db.ref(`AllRoom/${client.roomId}/users/${uid}`).update(patch);
    }catch(e){}
  };

  const bind = (inp, key)=> {
    inp.addEventListener("change", ()=>{
      const v = parseInt(inp.value,10);
      commit(userId, {[key]: Number.isFinite(v) ? v : 0});
    });
    inp.addEventListener("keydown", (e)=>{
      if (e.key === "Enter"){
        e.preventDefault();
        inp.blur();
      }
    });
  };

  bind(atk.inp, "atk");
  bind(def.inp, "def");
  bind(hp.inp,  "hp");

  STATS_UI.root && STATS_UI.root.appendChild(box);

  const obj = { box, dot, name, atk: atk.inp, def: def.inp, hp: hp.inp };
  _statInputs.set(userId, obj);
  return obj;
}

function updateStatsOverlay(){
  const root = STATS_UI.root;
  if (!root) return;

  const s = getState();
  if (!s){
    root.style.display = "none";
    return;
  }
  root.style.display = "block";

  const rects = zoneRects();

  // lấy data realtime users (firebase) nếu có, không thì fallback players
  const users = (client.transport instanceof FirebaseTransport)
    ? (client.authoritative?._users || null
    : null;

  for (const p of (s.players||[])){
    const key = seatRectKey(p.seat);
    const r = key ? rects[key] : null;
    if (!r) continue;

    const ui = ensureStatBoxForUser(p.id);

    ui.dot.style.background = COLORS[p.color] || "rgba(233,236,255,.35)";
    ui.name.textContent = p.name || "Player";

    // set value from RTDB users if present
    const u = users?.[p.id] || null;
    if (u){
      ui.atk.value = String(u.atk ?? 0);
      ui.def.value = String(u.def ?? 0);
      ui.hp.value  = String(u.hp  ?? 0);
    }

    // position: góc phải trên vùng hand của người đó
    const sp0 = toScreen({x:r.x, y:r.y});
    const sp1 = toScreen({x:r.x+r.w, y:r.y+r.h});

    ui.box.style.left = (sp1.x - 260) + "px";
    ui.box.style.top  = (sp0.y + 8) + "px";
  }
}

  const STATUS = {
  el: document.getElementById("statusBoard"),
  lastSig: "",
  bound: false,
  editing: false,
  _timer: null,
};

function initStatusBoardUI(){
  if (!STATUS.el || STATUS.bound) return;
  STATUS.bound = true;

  // event delegation: chỉ bind 1 lần
  STATUS.el.addEventListener("input", (e)=>{
    const inp = e.target.closest("input[data-kind]");
    if (!inp) return;

    const s = getState();
    if (!s) return;

    const host = isHost(s);
    const kind = inp.dataset.kind;

    if (kind === "header"){
      if (!host) return;
      const idx = Number(inp.dataset.idx) | 0;
      const value = (inp.value ?? "").toString().slice(0, 12);
      sendIntentDebounced({ type:"set_stat_header", idx, value });
    } else if (kind === "stat"){
      const pid = inp.dataset.pid;
      const idx = Number(inp.dataset.idx) | 0;
      const value = (inp.value ?? "").toString().slice(0, 12);
      sendIntentDebounced({ type:"set_stat", playerId: pid, idx, value });
    }
  });

  // khi đang gõ -> đừng re-render làm mất caret
  STATUS.el.addEventListener("focusin", (e)=>{
    if (e.target.closest("input[data-kind]")) STATUS.editing = true;
  });
  STATUS.el.addEventListener("focusout", (e)=>{
    if (e.target.closest("input[data-kind]")){
      // delay nhẹ để focus chuyển giữa các input không bị bật/tắt
      setTimeout(()=>{
        const active = document.activeElement;
        STATUS.editing = !!(active && STATUS.el.contains(active) && active.matches("input[data-kind]"));
      }, 0);
    }
  });
}

// debounce gửi intent
function sendIntentDebounced(intent){
  clearTimeout(STATUS._timer);
  STATUS._timer = setTimeout(()=> sendIntent(intent), 120);
}

function renderStatusBoard(){
  initStatusBoardUI();

  const s = getState();
  if (!s || !STATUS.el) return;

  // nếu đang edit input thì không rebuild DOM (tránh lag + mất con trỏ)
  if (STATUS.editing) return;

  // đảm bảo shape
  s.ui = s.ui || {};
  const headers = (s.ui.statHeaders || ["ATK","DEF","HP","COIN"]).slice(0,4);
  while (headers.length < 4) headers.push("");

  const host = isHost(s);

  // tạo "signature" nhẹ để chỉ update khi data đổi
  // (dùng version + headers + players + stats)
  let sig = `v=${s.version||0}|h=${headers.join(",")}|p=`;
  const players = (s.players || []);
  for (let i=0;i<players.length;i++){
    const p = players[i];
    if (!p) continue;
    const stats = ensureStatsRow(s, p.id); // đảm bảo có 4 ô
    sig += `${p.id}:${p.name||""}:${p.color||""}:${stats.join("/")};`;
  }

  if (sig === STATUS.lastSig) return; // ✅ không đổi thì thôi
  STATUS.lastSig = sig;

  // ===== render HTML (chỉ chạy khi sig đổi) =====
  const headerHtml = headers.map((h, idx)=>{
    // dùng readonly thay vì disabled để vẫn click/copy được
    const ro = host ? "" : "readonly";
    const title = host ? "Host có thể đổi tên cột" : "Chỉ host sửa tên cột";
    return `
      <th style="padding:6px 6px; text-align:center;">
        <input ${ro}
          data-kind="header" data-idx="${idx}"
          value="${escapeHtml(h ?? "")}"
          title="${title}"
          style="
            width: 70px;
            text-align:center;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 8px;
            color: #fff;
            padding: 4px 6px;
            outline: none;
          "
        />
      </th>
    `;
  }).join("");

  const rows = players.map(p=>{
    if (!p) return "";
    const stats = ensureStatsRow(s, p.id);

    const tds = stats.slice(0,4).map((v, idx)=>{
      return `
        <td style="padding:6px 6px; text-align:center;">
          <input
            data-kind="stat"
            data-pid="${p.id}"
            data-idx="${idx}"
            value="${escapeHtml((v ?? "").toString())}"
            title="Sửa tự do"
            style="
              width: 70px;
              text-align:center;
              background: rgba(0,0,0,0.25);
              border: 1px solid rgba(255,255,255,0.18);
              border-radius: 8px;
              color: #fff;
              padding: 4px 6px;
              outline: none;
            "
          />
        </td>
      `;
    }).join("");

    return `
      <tr style="border-top: 1px solid rgba(255,255,255,0.10);">
        <td style="padding:6px 8px; white-space:nowrap;">
          <span style="
            display:inline-block;
            width:10px;
            height:10px;
            border-radius:3px;
            background:${COLORS?.[p.color] ?? "rgba(255,255,255,.35)"};
            margin-right:6px;
          "></span>
          <span style="opacity:0.92; font-weight:600;">
            ${escapeHtml(p.name || "Player")}
          </span>
        </td>
        ${tds}
      </tr>
    `;
  }).join("");

  STATUS.el.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
      <div style="font-weight:800;letter-spacing:.04em;opacity:0.95;">SCOREBOARD</div>
      <div style="opacity:0.65;font-size:11px;">
        ${host ? "Host sửa tên cột" : "Header: host-only"}
      </div>
    </div>

    <table style="border-collapse:collapse;width:100%;">
      <thead>
        <tr>
          <th style="padding:6px 8px;text-align:left;opacity:0.85;">Player</th>
          ${headerHtml}
        </tr>
      </thead>
      <tbody>
        ${rows || ""}
      </tbody>
    </table>
  `;
}

// chống XSS (vì dùng innerHTML)
function escapeHtml(str){
  return (str ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}


/* =========================================================
   19) UI bindings (bind 1 lần)
========================================================= */
if (UI.modeSelect){
  UI.modeSelect.addEventListener("change", ()=>{
    if (UI.wsRow) UI.wsRow.style.display = (UI.modeSelect.value === "ws") ? "flex" : "none";
  });
}

if (UI.applyDeckBtn){
  UI.applyDeckBtn.addEventListener("click", ()=>{
    if (!client.isHost) return toast("Host mới set deck images");
    sendIntent({ type:"setAssets", frontBase: UI.frontBaseInput?.value, backUrl: UI.backUrlInput?.value });
    toast("Applied deck images");
  });
}

if (UI.createBtn){
  UI.createBtn.addEventListener("click", async ()=>{
    try{
      if (UI.modeSelect?.value === "firebase") await createRoomAsHost_Firebase();
      else createRoomAsHost_LocalOrWS();
    }catch(e){
      console.error(e);
      toast("Create error: " + (e.message || e));
    }
  });
}

if (UI.joinBtn){
  UI.joinBtn.addEventListener("click", async ()=>{
    try{
      if (UI.modeSelect?.value === "firebase") await joinRoomAsClient_Firebase();
      else joinRoomAsClient_LocalOrWS();
    }catch(e){
      console.error(e);
      toast("Join error: " + (e.message || e));
    }
  });
}

if (UI.resetBtn){
  UI.resetBtn.addEventListener("click", ()=>{
    if (!client.authoritative) return;
    if (!client.isHost) return toast("Chỉ Host mới reset.");
    sendIntent({type:"reset"});
  });
}

if (UI.copyLinkBtn){
  UI.copyLinkBtn.addEventListener("click", async ()=>{
    readInputs();
    const url = new URL(location.href);
    url.searchParams.set("room", client.roomCode);
    url.searchParams.set("mode", UI.modeSelect?.value || "local");
    if (UI.modeSelect?.value === "ws"){
      const ws = (UI.wsUrlInput?.value || "").trim();
      if (ws) url.searchParams.set("ws", ws);
    }
    try{
      await navigator.clipboard.writeText(url.toString());
      toast("Đã copy link phòng.");
    }catch(e){
      toast("Copy failed (trình duyệt chặn).");
    }
  });
}

document.querySelectorAll(".collapse-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const panelId = btn.dataset.target;
    const panel = document.getElementById(panelId);
    if (!panel) return;
    const collapsed = panel.classList.toggle("collapsed");
    btn.textContent = collapsed ? "+" : "−";
  });
});

/* =========================================================
   20) Auth UI buttons (login/register/anon/logout/leave)
========================================================= */
async function registerUser(){
  fbInitOnce();
  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";
  const username = (document.getElementById("authUsername")?.value || "").trim();

  if (!email || !password || !username){
    toast("Nhập đầy đủ email / mật khẩu / tên");
    return;
  }

  const cred = await FB.auth.createUserWithEmailAndPassword(email, password);
  const user = cred.user;

  await FB.db.ref(`AllUser/${user.uid}`).set({
    username,
    email,
    createdAt: Date.now(),
    setCard: {}
  });

  // sync runtime
  FB.user = user; FB.uid = user.uid; FB.username = username;
  if (UI.nameInput) UI.nameInput.value = username;

  toast("Đăng ký thành công");
  goLobby();
}

async function loginUser(){
  fbInitOnce();
  const email = (document.getElementById("authEmail")?.value || "").trim();
  const password = document.getElementById("authPassword")?.value || "";

  if (!email || !password){
    toast("Nhập email và mật khẩu");
    return;
  }

  await FB.auth.signInWithEmailAndPassword(email, password);

  // sau login, lấy username từ profile nếu có
  FB.user = FB.auth.currentUser;
  FB.uid = FB.user.uid;

  const snap = await FB.db.ref(`AllUser/${FB.uid}`).get();
  const prof = snap.val() || {};
  FB.username = (prof.username || "Player").slice(0,18);

  if (UI.nameInput) UI.nameInput.value = FB.username;

  toast("Đăng nhập thành công");
  goLobby();
}

const loginBtn = document.getElementById("loginBtn");
const registerBtn = document.getElementById("registerBtn");
const playAnonBtn = document.getElementById("playAnonBtn");
const logoutBtn = document.getElementById("logoutBtn");
const leaveMatchBtn = document.getElementById("leaveMatchBtn");

if (registerBtn){
  registerBtn.onclick = async ()=> {
    try{ await registerUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (loginBtn){
  loginBtn.onclick = async ()=> {
    try{ await loginUser(); }catch(e){ console.error(e); toast(e.message || e); }
  };
}
if (playAnonBtn){
  playAnonBtn.onclick = async ()=>{
    try{
      fbInitOnce();
      await FB.auth.signInAnonymously();
      FB.user = FB.auth.currentUser;
      FB.uid = FB.user.uid;

      const uname =
        ((document.getElementById("authUsername")?.value || "").trim().slice(0,18)) ||
        "Guest";
      FB.username = uname;

      const uref = FB.db.ref(`AllUser/${FB.uid}`);
      const snap = await uref.get();
      if (!snap.exists()){
        await uref.set({ username: FB.username, createdAt: Date.now(), setCard:{} });
      }else{
        await uref.update({ username: FB.username });
        const cur = snap.val() || {};
        if (!cur.setCard) await uref.update({ setCard:{} });
      }

      if (UI.nameInput) UI.nameInput.value = FB.username;

      goLobby();
      toast("Chơi thử: vào sảnh chờ");
    }catch(e){
      console.error(e);
      toast("Anonymous error: " + (e.message || e));
    }
  };
}
if (logoutBtn){
  logoutBtn.onclick = async ()=>{
    try{ if (FB?.auth?.currentUser) await FB.auth.signOut(); }catch(e){}
    try{ leaveRoom(); }catch(e){}
    goAuth();
    toast("Đã đăng xuất");
  };
}
if (leaveMatchBtn){
  leaveMatchBtn.onclick = ()=>{
    try{ leaveRoom(); }catch(e){}
    goLobby();
    toast("Đã rời phòng");
  };
}

/* =========================================================
   21) Deck modal binds
========================================================= */
if (DECKUI.openBtn){
  DECKUI.openBtn.onclick = async ()=>{
    try{
      await refreshSetList();
      openDeckModal();
    }catch(e){
      console.error(e);
      toast("Deck modal error: " + (e.message||e));
    }
  };
}
if (DECKUI.closeBtn) DECKUI.closeBtn.onclick = closeDeckModal;
if (DECKUI.newSetBtn) DECKUI.newSetBtn.onclick = createNewSet;
if (DECKUI.saveBtn) DECKUI.saveBtn.onclick = saveCurrentSet;
if (DECKUI.deleteSetBtn) DECKUI.deleteSetBtn.onclick = deleteCurrentSet;
if (DECKUI.loadSetBtn) DECKUI.loadSetBtn.onclick = loadSelectedSet;
if (DECKUI.addCardBtn) DECKUI.addCardBtn.onclick = ()=>{
    DECKUI.list.appendChild(makeCardTypeRow());
  };
if (DECKUI.loadToRoomBtn) DECKUI.loadToRoomBtn.onclick = hostLoadSetToRoom;

/* =========================================================
   22) Auto-fill URL params
========================================================= */
(function initFromQuery(){
  const u = new URL(location.href);
  const room = u.searchParams.get("room");
  const mode = u.searchParams.get("mode");
  const ws = u.searchParams.get("ws");
  if (room && UI.roomInput) UI.roomInput.value = room.toUpperCase();
  if (mode && UI.modeSelect && (mode==="local" || mode==="ws" || mode==="firebase")){
    UI.modeSelect.value = mode;
    if (UI.wsRow) UI.wsRow.style.display = mode === "ws" ? "flex" : "none";
  }
  if (ws && UI.wsUrlInput) UI.wsUrlInput.value = ws;
})();

addEventListener("beforeunload", ()=>{ try{ leaveRoom(); }catch(e){} });

window.addEventListener("error", (e) => {
  toast("JS error: " + (e.message || "unknown"));
});
window.addEventListener("unhandledrejection", (e) => {
  toast("Promise error: " + ((e.reason && e.reason.message) || e.reason || "unknown"));
});

/* =========================================================
   23) Boot
========================================================= */
goAuth();
setNetBadge("OFFLINE");

</script>
</body>
</html>
